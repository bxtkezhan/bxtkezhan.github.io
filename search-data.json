[
    
    
    
        
            {
                "id": 0,
                "href": "https://bxtkezhan.github.io/portfolio/lorem-ipsum/",
                "title": "What is Lorem Ipsum?",
                "section": "portfolio",
                "date" : "2022.05.15",
                "body": "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\u0026rsquo;s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\nIn this post, you’ll learn:\nLorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam tincidunt mauris eu risus. Vestibulum auctor dapibus neque. Nunc dignissim risus id metus. Cras ornare tristique elit. Vivamus vestibulum ntulla nec ante. Praesent placerat risus quis eros. Fusce pellentesque suscipit nibh. Integer vitae libero ac risus egestas placerat. Vestibulum commodo felis quis tortor. Ut aliquam sollicitudin leo. Cras iaculis ultricies nulla. Donec quis dui at dolor tempor interdum. Text came from: https://www.lipsum.com/\n"
            }
    
        ,
            {
                "id": 1,
                "href": "https://bxtkezhan.github.io/about/",
                "title": "About Me",
                "section": "",
                "date" : "2022.04.26",
                "body": "Hi I\u0026rsquo;m the developer of Arberia Theme for Hugo. If you want to know some about me read this short bio.\nMy name is Vincenzo Antedoro. I\u0026rsquo;m an engineer who helps those who want to invest in renewables. For the rest he enjoys teaching with the method of learning by doing.\nVisualize my profile at my personal blog: https://antedoro.it/about/\n"
            }
    
        ,
            {
                "id": 2,
                "href": "https://bxtkezhan.github.io/portfolio/why-do-we-use-it/",
                "title": "Why do we use it?",
                "section": "portfolio",
                "date" : "2022.05.15",
                "body": "It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using \u0026lsquo;Content here, content here\u0026rsquo;, making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for \u0026rsquo;lorem ipsum\u0026rsquo; will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).\nIn this course, you’ll learn how to:\nLorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam tincidunt mauris eu risus. Vestibulum auctor dapibus neque. Nunc dignissim risus id metus. Cras ornare tristique elit. Vivamus vestibulum ntulla nec ante. Praesent placerat risus quis eros. Fusce pellentesque suscipit nibh. Integer vitae libero ac risus egestas placerat. Vestibulum commodo felis quis tortor. Ut aliquam sollicitudin leo. Cras iaculis ultricies nulla. Donec quis dui at dolor tempor interdum. "
            }
    
        ,
            {
                "id": 3,
                "href": "https://bxtkezhan.github.io/portfolio/where-can-i-get-some/",
                "title": "Where can I get some?",
                "section": "portfolio",
                "date" : "2022.05.15",
                "body": "There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don\u0026rsquo;t look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn\u0026rsquo;t anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc.\nText came from: https://www.lipsum.com/\n"
            }
    
        ,
            {
                "id": 4,
                "href": "https://bxtkezhan.github.io/portfolio/where-does-it-come-from/",
                "title": "Where does it come from?",
                "section": "portfolio",
                "date" : "2022.05.15",
                "body": "Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of \u0026ldquo;de Finibus Bonorum et Malorum\u0026rdquo; (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \u0026ldquo;Lorem ipsum dolor sit amet..\u0026rdquo;, comes from a line in section 1.10.32.\nThe standard chunk of Lorem Ipsum used since the 1500s is reproduced below for those interested. Sections 1.10.32 and 1.10.33 from \u0026ldquo;de Finibus Bonorum et Malorum\u0026rdquo; by Cicero are also reproduced in their exact original form, accompanied by English versions from the 1914 translation by H. Rackham.\n"
            }
    
        ,
            {
                "id": 5,
                "href": "https://bxtkezhan.github.io/ai%E5%8A%A9%E6%89%8B-google-gemini/",
                "title": "AI助手 Google Gemini",
                "section": "posts",
                "date" : "2024.01.14",
                "body": "随着GPT系列的对话生成语言模型的推出和发展，我们可以比较轻松的借助这些工具搭建出AI助手服务。可以说，GPT系列的语言模型就是搭建个人助手服务的一个要素。\n要素: 某个项目工程的研发需要依赖一个或多个基础资源，这些资源可以被称作该项目工程的研发要素，简称为要素。\n注册申请API Key 通过科学的上网方式，我们可以有效地从ai.google.dev获取所需的Gemini-Pro API Key。\n安装依赖 使用Python来做尝试，官方文档推荐了对应的SDK，我们可以安装一下:\npip install -q -U google-generativeai 通过SDK启用模型 我们先引入SDK:\nimport google.generativeai as genai 接下来配置API Key:\ngenai.configure(api_key=\u0026#39;你的API Key\u0026#39;) 可以看一下有哪些内容生成类型的模型:\nfor m in genai.list_models(): if \u0026#39;generateContent\u0026#39; in m.supported_generation_methods: print(m.name) 目前来说有两个生成类型的模型:\n\u0026lsquo;gemini-pro\u0026rsquo;: 文本对话模型 \u0026lsquo;gemini-pro-vision\u0026rsquo;: 具有视觉理解的文本对话模型 选择并启用文本对话模型:\nmodel = genai.GenerativeModel(\u0026#39;gemini-pro\u0026#39;) 尝试对话 现在，我们可以发送一段文本指令，让其返回一段内容:\nresponse = model.generate_content(\u0026#39;写一首七言律诗，描述冬日萧瑟的田间景色。\u0026#39;) generate_content方法会返回response对象，我们可以通过它的text属性查看模型生成的内容:\nprint(response.text) 上述代码的打印输出「一般不会相同」:\n寒风萧萧冷气侵， 枯草败叶满目陈。 农田寂静无人迹， 唯有寒鸦绕树鸣。 沟渠冰封水尽涸， 枝头衰柳苦伶仃。 落日西沉归山去， 田间萧瑟倍凄清。 我们再让它回答一个编程问题:\nresponse = model.generate_content(\u0026#39;使用golang编写一个简单的http文件服务器。\u0026#39;) print(response.text) 上述代码的打印输出「一般不会相同」:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { // Specify the directory that you want to serve files from dir := \u0026#34;static\u0026#34; // Create a new HTTP file server fs := http.FileServer(http.Dir(dir)) // Create a new HTTP server server := \u0026amp;http.Server{ Addr: \u0026#34;:8080\u0026#34;, Handler: fs, } // Start the HTTP server log.Printf(\u0026#34;Listening on port :8080\u0026#34;) if err := server.ListenAndServe(); err != nil { // Handle the error fmt.Println(err) os.Exit(1) } } package main: This line indicates that this is the main Go source file for the program.\nimport (...):: This line includes the necessary standard libraries for the program to function.\nfunc main(): This is the entry point for the program, where execution begins.\ndir := \u0026quot;static\u0026quot;: This line specifies the directory from which the program will serve files.\nfs := http.FileServer(http.Dir(dir)): This line creates a new HTTP file server that serves files from the specified directory.\nserver := \u0026amp;http.Server{...}: This line creates a new HTTP server object. The Addr field specifies the port on which the server will listen for requests, and the Handler field specifies the HTTP file server that will handle the requests.\nserver.ListenAndServe(): This line starts the HTTP server. If an error occurs while starting the server, it is printed to the console and the program exits with an exit code of 1.\nTo use this program, you can follow these steps:\nCreate a directory named \u0026ldquo;static\u0026rdquo; in the same directory as the program file.\nCopy the files that you want to serve to the \u0026ldquo;static\u0026rdquo; directory.\nRun the program using the command go run main.go.\nOpen a web browser and navigate to http://localhost:8080 to access the files in the \u0026ldquo;static\u0026rdquo; directory.\n多伦对话模式 除了这种单次内容生成，SDK还支持多伦对话:\nmodel = genai.GenerativeModel(\u0026#39;gemini-pro\u0026#39;) chat = model.start_chat(history=[]) response = chat.send_message( \u0026#34;Pretend you\\\u0026#39;re a snowman and stay in character for each response.\u0026#34;) print(response.text) response = chat.send_message( \u0026#34;What\\\u0026#39;s your favorite season of the year?\u0026#34;) print(response.text) 今天我们简单的了解了一下Gemini AI的开发使用，如果你对更多Gemini相关的内容感兴趣，可以翻看一下它的官方文档做进一步的学习。\n"
            }
    
        ,
            {
                "id": 6,
                "href": "https://bxtkezhan.github.io/%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E5%A5%B3%E6%80%A7%E6%85%95%E5%BC%BA%E7%8E%B0%E8%B1%A1%E7%9A%84%E7%9C%8B%E6%B3%95/",
                "title": "谈谈我对「女性慕强」现象的看法",
                "section": "posts",
                "date" : "2024.01.02",
                "body": "最近有刷到对「女性慕强」现象批评的文章和视频，觉得挺有意思。正好，我也有点想写些关于技术以外的内容的文章。\n「女性慕强」的定义 由于我主要看到的文章讲的「女性慕强」指的都是女性崇尚和追求比自身优秀强大的男性的现象，所以我这里姑且定义「女性慕强」为：\n女性崇尚以及追求比自身显著优秀和强大的男性的行为现象。\n有了明确的定义后，就可以来谈谈作为男性的我，对于该现象的个人看法。首先我觉得作为男性，即便不认可也最好不要公开且明显的反对这一现象，不然很可能会暴露自己是个弱鸡的……\n首先，从我有限的理性和情感上考虑，我都不反对「女性慕强」，毕竟这好像也没有什么明显不合理的地方。为了能够更加客观理性的论述，我还是在网上找了一些所谓专家的分析视频。\n基本上专家们的说法大致都是：「女性慕强，是刻录在女性基因里的天性，是女性不够独立自主的一个表现。」。我这边暂且不讨论一个所谓刻录在基因里的天性和不够独立自主人格有啥必然联系，我这里、我现在、我只想说的是：这也太无聊了，以至于我在构思文章的中途就决定要更换写作主题了。来，下面我们进入一个新的主题。\n使用huggingface上的模型构建离线翻译系统 语言翻译是个常见的应用需求，由于某些因素，我们不可以调用效果较好的商用翻译api，这时就需要我们构建自己的离线翻译工具。使用huggingface上的模型就可以快速构建较为理想的离线语言翻译系统。\n使用如下Python代码可以简单构建中文与英文的翻译系统：\nfrom transformers import pipeline translation_zh_en = pipeline( \u0026#39;translation\u0026#39;, model=\u0026#39;Helsinki-NLP/opus-mt-zh-en\u0026#39;, device=\u0026#39;cpu\u0026#39;) print(translation_zh_en(\u0026#39;你手若有行善的力量，不可推辞，就当向那应得的人施行。\u0026#39;)) translation_en_zh = pipeline( \u0026#39;translation\u0026#39;, model=\u0026#39;Helsinki-NLP/opus-mt-en-zh\u0026#39;, device=\u0026#39;cpu\u0026#39;) print(translation_en_zh(\u0026#39;My son, let not them depart from thine eyes; keep sound wisdom and discretion;\u0026#39;)) 运行后输出为:\n[{\u0026#39;translation_text\u0026#39;: \u0026#39;And if your hand has the power to do good, then do it to those who deserve it.\u0026#39;}] [{\u0026#39;translation_text\u0026#39;: \u0026#39;我的儿子啊!你不要让他们离开你的眼睛,你应当保持周全的智慧和谨慎。\u0026#39;}] 真的非常非常简单实用。下面说一下构建该系统需要的环境依赖。\n一、Python3运行环境 你需要准备一下Python3的运行环境，使用当前主流的版本就可以了。\n二、安装transformers包 需要安装transfomers包才可以很轻松的使用huggingface上的模型。\n安装方法类似其它的Python包的安装方法，一般来说可以直接使用pip工具。\npip install \u0026#39;transformers[torch]\u0026#39; 详细内容可以参考官方文档 DOC-LINK。\n三、下载模型文件 初次运行上述代码会自动进行模型文件的下载，可能比较耗时，需要耐心等待。\n能不能自己写模型做翻译系统 如果你需要造轮子，答案肯定是可以！不过代码篇幅会比较大，我一时半会儿也不想写文章。如果实在感兴趣，或者需要开发，可以进行商业咨询。\n"
            }
    
        ,
            {
                "id": 7,
                "href": "https://bxtkezhan.github.io/%E5%85%B3%E4%BA%8E%E5%9C%A3%E7%BB%8F%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98/",
                "title": "关于圣经阅读方法的问题",
                "section": "posts",
                "date" : "2024.01.02",
                "body": "发现一些华文区圣经阅读的问题，这里先描述第一类问题：由于读经方法导致忽略上下文，经文主旨，没有考虑写作背景，写作目的，受众对象，以及错误理解字词原义。\n问题出处《哥林多後書 3:6》中关于字句和精意的释义 中文和合本圣经中有一句经文《哥林多後書 3:6》「字句是叫人死、精意是叫人活」。\n这句经文常被用来支持一些“寓意解经法”，这里提到的“寓意解经法”主要指强调圣经的文字并不是圣经想要表达的意思，而真正的意思只能通过所谓背后的寓意来了解的一种解经方法。\n但是我们仔细查考就会发现这里精意一词根本不是说的经文中隐秘的含意，即“精意”不是说“经意”。\n我们看到英文版本的圣经以及圣经新译本：\n圣经新译本 (CNV Simplified) 他使我们有资格作新约的仆役，这新约不是从仪文来的，而是从圣灵来的；因为仪文会使人死，而圣灵却使人活。\n2 Corinthians 3:6 King James Bible Who also hath made us able ministers of the new testament; not of the letter, but of the spirit: for the letter killeth, but the spirit giveth life.\n2 Corinthians 3:6 English Revised Version who also made us sufficient as ministers of a new covenant; not of the letter, but of the spirit: for the letter killeth, but the spirit giveth life.\n这些版本都没有使用“精意”这个词，而是使用“圣灵”。我们再看一下圣经原文的用词，即 通用希腊文 的用词：\nTransliteration Greek English Morphology hos ὃς who RelPro-NMS kai καὶ also Conj hikanōsen ἱκάνωσεν has made competent V-AIA-3S hēmas ἡμᾶς us [as] PPro-A1P diakonous διακόνους ministers N-AMP kainēs καινῆς of a new Adj-GFS diathēkēs διαθήκης, covenant; N-GFS ou οὐ not Adv grammatos γράμματος of [the] letter, N-GNS alla ἀλλὰ but Conj pneumatos πνεύματος· of [the] Spirit; N-GNS to τὸ the Art-NNS gar γὰρ indeed Conj gramma γράμμα letter N-NNS apoktennei ἀποκτέννει*, kills, V-PIA-3S to τὸ - Art-NNS de δὲ but Conj pneuma πνεῦμα [the] Spirit N-NNS zōopoiei ζωοποιεῖ. gives life. V-PIA-3S 我们看到对应的词是 πνεῦμα，这个词对照各个版本中各个位置的释义，其含意就是 灵/圣灵。\nMatthew 3:16 N-ANS\nGRK: εἶδεν τὸ πνεῦμα τοῦ θεοῦ\nNAS: and he saw the Spirit of God\nKJV: he saw the Spirit of God\nINT: he saw the Spirit of God\nMatthew 10:20 N-NNS\nGRK: ἀλλὰ τὸ πνεῦμα τοῦ πατρὸς\nNAS: For it is not you who speak, but [it is] the Spirit of your Father\nKJV: but the Spirit of your\nINT: but the Spirit of the Father\nMatthew 12:18 N-ANS\nGRK: θήσω τὸ πνεῦμά μου ἐπ\u0026rsquo;\nNAS: I WILL PUT MY SPIRIT UPON HIM, AND HE SHALL PROCLAIM\nKJV: I will put my spirit upon him,\nINT: I will put the Spirit of me upon\n……\n上下文和背景\n常说解释圣经要看上下文。在这一段经文里，保罗提到神立他们做新约的执事（在这里『执事』不是指教会的岗位，是指执行人，服事的人），而提到的对比是旧约的执事。所以他提到摩西的律法，称律法为『用字刻在石头上』的，并且解释说律法是『属死的职事』（第7节），是『定罪的职事』（第9节）。 这不是说保罗认为律法是不好的，但是就如他在其他书信里解释的，律法的功用是叫人知罪、叫人知道我们不能靠自己得救、叫人知道若是按律法审判的话，人都会被定罪、都会灭亡。因此，律法在这里被称为『属死的职事』。 但是保罗说他们承担的是新约的执事，而这新约执事的职事，是把耶稣为人钉十字架的道理传开，叫人因信耶稣而得生命、得永生。 他也把这个职事称为『属灵的职事』（第 8 节）和『称义的职事』（第 9 节）。虽然这是保罗和他的同工的职事，但至终人的信主和得救，不是他们能做到的。那是圣灵的工作。 所以在这个背景之下，保罗说神使他们承担的，不是字句的执事，而是（圣）灵的执事，并且说明字句（指旧约律法）是叫人死、灵（指圣灵）是叫人活。\n上文整理自一位基督徒朋友的博客 https://notbreadalone.org/?p=1397\n再者，根据通篇书信来看，当时保罗发现了哥林多教会正面临一些问题，其中一个严重的问题就是一些信主的犹太基督徒在进入教会后开始强调摩西律法以及主张需要通过肉体的割礼才能得救，为了及时纠正哥林多教会的一些错误，于是保罗就写了这封书信。\n根据上下文，历史背景，写作目的，以及圣经原文释义，那句话其实就是指：律法的字句是使人知罪并定罪，人却不能通过律法得救，因为没有一个人靠律法站得稳，而人因为信主得着圣灵内住，生出悔改，在耶稣基督里成为新造的人，却可以得着生命。\n之所以和合本圣经中使用“精意”一词指圣灵，可能是由于文法或者其它因素，毕竟和合本圣经成书年代较早，而中文文法，用词习惯在此之后有过一定程度的变更「例如：新文化运动」。\n这种“寓意解经法”常常出现的问题是： 一、很容易忽略上下文。 即便可以在上下文找到经文比喻所指的事物，也还是优先从很远的位置搜集特定的经文来尝试做释义。这样容易因为个人倾向，选择性的挑选经文进行讲解。因为圣经正典成书年代跨度很长，并且地域跨度也很广，不同的书写者会受到不同的文化背景的影响使用有各自特定风格的比喻，导致常常会有一个事物可以指代多个含意，而如果不看上下文以及写作背景就很容易挑选特定经文来支撑个人的观点。\n举例说明：\n箴言 14:12 有一条路，人以为是正路，走到尽头却是死亡之路。\n有人把这句经文解释为“看到圣经的字句，自以为理解了，却没有看到字句背后精意「隐藏的含意」”，但是你翻看前后文就会知道，这里其实是指上下文中提到的一系列愚妄、傲慢、奸淫、狂暴、虚伪的人所偏好的行为。\n箴言中有如下经文进行对照：\n箴言 12:15 愚妄人所行的在自己眼中看为正直，唯智慧人肯听人的劝教。\n虽然“自以为是的认定自己明白圣经”这一行为可以被归类到这里所说的死亡之路，但箴言这里并不是说所谓字句和精意的事情，其实按照圣经原文根本没有精意这个词，这也是为什么新修版本不采用和合本中精意这一词，而是直接使用和原文以及英文相同的圣灵一词的一个重要原因。可以理解为精意这一词仅出现在中文和合本，换句话说就是在和合本发布之前根本没人提精意这个词，而发布之后使用英文或新修本的人也不会看到精意这一词。\n注意：我这里并不是说圣经不会使用比喻，异相，对照，预表等手法来描述事物，我强调的是先参考上下文以及写作背景，写作目的进行理解。而对于一些启示类的经卷和章节，在合宜的时候使用以经解经的方法尝试理解和验证其中的比喻、异相、预表……另外，在一些上帝明确打算封上的异相和预言，我们应该关注的重点是上帝愿意显明的教训，例如：虽然启示录难以完全读懂，但是启示录中耶稣基督给众教会的信，劝勉人谦卑、坚忍、对主忠心、有爱心、有盼望的这些内容是明明白白显出来的，也是我们应当特别重视的。\n二、忽略经文的主旨和写作用意以及受众对象。 我们知道圣经旧约里面很多先知的言语都是由上帝吩咐他们去告诫以色列人并劝以色列人悔改的，有的先知被指派向皇宫贵族进行劝戒，如：以赛亚；而有的被告知向贫苦的百姓进行劝戒，如：弥迦。如果向受教育程度不高甚至很低的平民即时传讲的信息还必须要通过“寓意解经法”这种方法四处翻查圣经才能明白，那恐怕是行不通的。而且新约初期，圣经正典——66卷书 还没有成册，旧约世代更是连福音书和使徒书信都没有，甚至由于旧约时间跨度很长，以色列早期时代连旧约正典中的许多先知书都还没有记载到，根本无法用所谓的“寓意解经法”，如果神果真想要差派先知先见去劝戒以色列人，那先知先见传讲的道理就不可能需要用这么麻烦且在当时几乎无法操作的方法来弄懂。而圣经中很多地方，神在想表达自己情感的时候就常常使用动人的诗歌，想要述说劝戒的道理和法则的时候就倾向于用平直的话来宣告。\n同样的道理，使徒书信也有很多是为了劝戒当时的信徒，教会而书写的。需要即时指出当时教会的一些问题并纠正他们。从可操作性，实用性，紧迫性来看“寓意解经法”都不是很多书信的优选理解方法。\n注意：我这里并不是说圣经不会使用比喻，异相，对照，预表等手法来描述事物。圣经的内容很丰富，表现事物的手法很多样，文章体裁也很多，散文、诗歌、启示文学、历史文献……我想说的是不要想着只用某一种方法去全面解释整部圣经，并且高举某个方法，甚至重视某个方法超过重视圣灵。各个版本中只有和合本出现精意这个词而且只出现在《哥林多後書 3:6》这一处，圣灵则是在各个版本中的各个地方经常出现，为什么不更加关注呢？\n三、容易养成无视经文的意思，而去自己私自臆测的习惯。 这里再简单列举已经发现的“寓意解经法”派系讲解员的几个错误：\n案例一、没有根据上下文阅读而导致搞错人称指代对象，如：误以为指代的对象是神。\n申命記 4:26 我今日就呼天唤地向你们作证，你们必在过约旦河取得为业的地上迅速灭亡；你们必不能在那地长久生存，必全被消灭。\n申命記 30:19 我今日呼天唤地向你们作证，我把生与死，福与祸，都摆在你面前了；所以你要选择生命，好让你和你的後裔都可以活着，\n申命記 31:28 你们要把你们各支派的众长老和官长都召集到我这里来，我好把这些话说给他们听，并且呼天唤地对他们作证。\n讲解员说这里是 神 在呼天唤地的做见证，但其实根据上下文我们可以知道这里在呼天唤地做见证的其实是摩西。请查看如下背景经文：\n背景 (Context)\n申命記 4 25「你們在那地住久了，生子生孫，就雕刻偶像，彷彿什麼形象，敗壞自己，行耶和華你神眼中看為惡的事，惹他發怒。 26我今日呼天喚地向你們作見證，你們必在過約旦河得為業的地上速速滅盡。你們不能在那地上長久，必盡行除滅。 27耶和華必使你們分散在萬民中，在他所領你們到的萬國裡，你們剩下的人數稀少。…\n申命記 30 18我今日明明告訴你們：你們必要滅亡！在你過約旦河進去得為業的地上，你的日子必不長久。 19我今日呼天喚地向你作見證，我將生死禍福陳明在你面前，所以你要揀選生命，使你和你的後裔都得存活。 20且愛耶和華你的神，聽從他的話，專靠他，因為他是你的生命，你的日子長久也在乎他。這樣，你就可以在耶和華向你列祖亞伯拉罕、以撒、雅各起誓應許所賜的地上居住。」\n申命記 31 …27因為我知道你們是悖逆的，是硬著頸項的。我今日還活著與你們同在，你們尚且悖逆耶和華，何況我死後呢？ 28你們要將你們支派的眾長老和官長都招聚了來，我好將這些話說於他們聽，並呼天喚地見證他們的不是。 29我知道我死後，你們必全然敗壞，偏離我所吩咐你們的道，行耶和華眼中看為惡的事，以手所做的惹他發怒，日後必有禍患臨到你們。」\n其实从逻辑上也能作出合理判断，即这里是摩西在呼天唤地的……，我们从语气上看，就知道这里呼天唤地……有种以下向上请求的意思，但 神 是要高过天地一切万有的，不会向人一样用卑微的姿态这样呼唤天地。如果是神来呼唤的话，应该是怎样的呢？正好诗篇中也有一段：\n诗篇 50 1 大能者神耶和华已经发言招呼天下，从日出之地到日落之处。 2 从全美的锡安中，神已经发光了。 3 我们的神要来，决不闭口。有烈火在他面前吞灭，有暴风在他四围大刮。 4 他招呼上天下地，为要审判他的民， 5 说：“招聚我的圣民到我这里来，就是那些用祭物与我立约的人。” 6 诸天必表明他的公义，因为神是施行审判的。\n神在对天地的时候，是一种大君王的姿态，是一种不容抗拒的至高权威的姿态。\n案例二、错误理解词汇，并强行带入个人倾向。\n哥林多前书 15:2 你们若持守我所传给你们的道，就必靠这福音得救，不然就是徒然相信了。\n这一句中，讲解员为了强行带入「字句和精意」的想法，将“徒然\u0026quot;一词硬生生翻译为「迷迷糊糊不知道“精意”」。但是明显”徒然“的意思应该是徒劳，白白的，空的，例如：徒劳无功，就是指白白劳作没有果效。整句的理解应该是：你们若持守我所传给你们的道，就一定能靠这福音得救，如果不能持守，就无法靠这福音得救，那么你们就是白白相信了。因为虽然一开始相信了，却无法坚持到底，以至于不能得救，那么起初的相信也只是枉然。\n我们可以对照圣经原文以及英文版本来进行确认：\nTransliteration Greek English Morphology di’ δι’ by Prep hou οὗ which RelPro-GNS kai καὶ also Conj sōzesthe σῴζεσθε, you are being saved, V-PIM/P-2P tini τίνι to the IPro-DMS logō λόγῳ word N-DMS euēngelisamēn εὐηγγελισάμην I proclaimed V-AIM-1S hymin ὑμῖν, to you; PPro-D2P ei εἰ if Conj katechete κατέχετε, you hold fast, V-PIA-2P ektos ἐκτὸς unless Adv ei εἰ if Conj mē μὴ not, Adv eikē εἰκῇ in vain Adv episteusate ἐπιστεύσατε. you have believed. V-AIA-2P 英文与希腊文对应“徒然”的词分别是in vain、εἰκῇ ，都是指“徒劳，空，白白的，没有意义的”，参考该词汇在各个版本中的含意也可验证：\nRomans 13:4 Adv\nGRK: οὐ γὰρ εἰκῇ τὴν μάχαιραν\nNAS: the sword for nothing; for it is a minister\nKJV: not the sword in vain: for he is\nINT: not indeed in vain the sword\n1 Corinthians 15:2 Adv\nGRK: εἰ μὴ εἰκῇ ἐπιστεύσατε\nNAS: to you, unless you believed in vain.\nKJV: unless ye have believed in vain.\nINT: if not in vain you believed\nGalatians 3:4 Adv\nGRK: τοσαῦτα ἐπάθετε εἰκῇ εἴ γε\nNAS: so many things in vain\u0026ndash; if\nKJV: so many things in vain? if [it be] yet\nINT: So many things did you suffer in vain if indeed\nGalatians 3:4 Adv\nGRK: γε καὶ εἰκῇ\nNAS: if indeed it was in vain?\nKJV: in vain? if [it be] yet in vain.\nINT: indeed also in vain\nGalatians 4:11 Adv\nGRK: μή πως εἰκῇ κεκοπίακα εἰς\nNAS: I have labored over you in vain.\nKJV: you labour in vain.\nINT: lest perhaps in vain I have toiled as to\n……\n我们再看一下这段经文的上下文背景：\n哥林多前書 15 1弟兄們，我如今把先前所傳給你們的福音告訴你們知道。這福音你們也領受了，又靠著站立得住， 2並且你們若不是徒然相信，能以持守我所傳給你們的，就必因這福音得救。 3我當日所領受又傳給你們的，第一就是：基督照聖經所說，為我們的罪死了，…\n这里强调的是领受了「即听道并相信了」，还需要靠着领受的道站立得住「能够立得稳，坚守住」，要一直坚持到底就必定得救，而如果不能坚持靠领受的道站立得住就无法用领受的道得救，那么所领受的就不能带来得救的果效，这就是徒劳无功了。\n以上是我关于所谓“寓意解经法”的一部分看法，还有一些问题仍在考虑是否继续整理，如果有必要我也愿意做更多的整理和分享，也期待有朋友愿意在解经方法的问题上和我做讨论。\n"
            }
    
        ,
            {
                "id": 8,
                "href": "https://bxtkezhan.github.io/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%ABmfcc%E7%89%B9%E5%BE%81/",
                "title": "语音识别・MFCC特征",
                "section": "posts",
                "date" : "2023.08.28",
                "body": "做语音识别前常常需要先对音频文件做预编码处理，然后将处理后的数据送入模型做进一步的推理或者训练。\n一般来说音频这种时讯数据可以使用傅里叶变换来取得特征，对于时长比较长的音频数据可以做短时傅里叶变换，及先将较长的时讯数据按照时长进行分段，对每一个小段单独做傅里叶变换，然后整合起来。\n短时傅里叶变换仍旧有其表征上的不足，一般来说工业界倾向于使用梅尔频率倒谱系数「Mel Frequency Cepstrum Coefficient，MFCC」来做语音识别的音频预编码。\n关于MFCC的具体细节可以参考资料: http://practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs\n在Python当中可以借用librosa快速实现MFCC操作，代码示例如下:\nimport matplotlib.pyplot as plt import librosa audio_path = \u0026#39;your_audio.mp3\u0026#39; audio, sr = librosa.load(audio_path, sr=32000) print(audio.shape, sr) librosa.display.waveshow(audio, sr=sr) plt.show() mfccs = librosa.feature.mfcc(y=audio, sr=sr, n_mfcc=20) print(mfccs.shape, mfccs.dtype, mfccs.min(), mfccs.max()) librosa.display.specshow(mfccs, sr=sr, x_axis=\u0026#39;time\u0026#39;) plt.show() 使用librosa.load可以从路径载入音频，一般来说可以指定采样率sr。librosa提供了可视化工具librosa.display.waveshow，可以帮助我们显示载入后的音频波形。\nlibrosa.feature.mfcc可以从音频数据中提取MFCC特征，我们需要指定采样率sr，默认情况下会返回nxm的数组，n默认为20，可以使用n_mfcc参数进行指定，m对应时间轴方向。我们可以通过可视化工具librosa.display.specshow来进行观察。\n"
            }
    
        ,
            {
                "id": 9,
                "href": "https://bxtkezhan.github.io/%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E6%8A%80%E6%9C%AF%E8%BF%9B%E8%A1%8Cpcb%E5%9B%BE%E5%83%8F%E8%BF%9E%E6%8E%A5%E7%BA%BF%E6%A3%80%E6%B5%8B/",
                "title": "使用计算机视觉技术进行PCB图像连接线检测",
                "section": "posts",
                "date" : "2023.06.12",
                "body": "上篇 使用计算机视觉技术进行PCB图像焊点检测\n引入需要的工具包 我们会使用 matplotlib 进行绘图，并使用 numpy 处理数组相关的数值计算，以及使用 opencv 提供的计算机视觉工具，请确保工作环境可以正确引入并使用它们。\n%matplotlib inline import matplotlib.pyplot as plt import cv2 as cv import numpy as np 载入并缩放图像 读取一张图像，将其进行缩放，使最长边对齐image_max_side的值，该值的设置可以根据经验，实际处理的图像和任务来做调整。\nimage_max_side = 1024 source_image = cv.imread(\u0026#39;./samples/10.JPG\u0026#39;) scale = image_max_side / max(source_image.shape[:2]) source_image = cv.resize(source_image, None, fx=scale, fy=scale, interpolation=cv.INTER_AREA) plt.imshow(source_image) plt.show() 引入核心函数 我们会需要使用到segmentation_dots以及segmentation_links这两个核心功能函数。后者负责连线检测，前者则是对上一节中焊点检测的封装，之所以需要使用到焊点检测，主要是因为连线检测函数需要使用到焊点检测的结果。\nfrom utils import segmentation_dots from utils import segmentation_links 焊点检测函数如下:\ndef segmentation_dots(image:np.ndarray, main_channel:int=1) -\u0026gt; np.ndarray: # convert to single channel frame = image.copy() frame[..., main_channel] = 255 gray = cv.cvtColor(frame, cv.COLOR_RGB2GRAY) # binarization normal = ((gray - gray.min()) / max(1, (gray.max() - gray.min())) * 255).astype(np.uint8) blur = cv.GaussianBlur(normal, (7, 7), 0) ret, thresh = cv.threshold(blur, 127, 255, cv.THRESH_OTSU) # morphology closing kernel = np.ones((5, 5), np.uint8) closing = cv.morphologyEx(thresh, cv.MORPH_CLOSE, kernel, iterations=1) # redundancy edges edges = cv.Canny(closing, 100, 200) edges = cv.morphologyEx(edges, cv.MORPH_CLOSE, kernel, iterations=3) # composition final = closing * (edges \u0026lt; 127).astype(np.uint8) return final 连线检测函数如下，如果觉得不熟悉，可以结合上一节中的内容对比焊点检测函数进行具体的了解:\ndef segmentation_links(image:np.ndarray, dots_mask:np.ndarray, main_channel:int=1) -\u0026gt; np.ndarray: # copy main channel gray = image[..., main_channel].copy() # binarization normal = ((gray - gray.min()) / max(1, (gray.max() - gray.min())) * 255).astype(np.uint8) blur = cv.GaussianBlur(normal, (5, 5), 0) ret, thresh = cv.threshold(255 - blur, 127, 255, cv.THRESH_OTSU) # dilate mask of dots kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, (5, 5)) dilated = cv.morphologyEx(dots_mask, cv.MORPH_DILATE, kernel, iterations=1) # composition final = 255 - thresh * (dilated \u0026lt; 127).astype(np.uint8) return final 结合焊点检测结果实现连线检测 简单调用两个函数完成检测:\ndots_mask = segmentation_dots(source_image) final = segmentation_links(source_image, dots_mask) 对检测结果进行可视化:\nplt.figure(figsize=(15, 10)) plt.subplot(131) plt.imshow(dots_mask, cmap=\u0026#39;gray\u0026#39;) plt.subplot(132) plt.imshow(final, cmap=\u0026#39;gray\u0026#39;) plt.subplot(133) plt.imshow(source_image, cmap=\u0026#39;gray\u0026#39;) plt.show() "
            }
    
        ,
            {
                "id": 10,
                "href": "https://bxtkezhan.github.io/%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E6%8A%80%E6%9C%AF%E8%BF%9B%E8%A1%8Cpcb%E5%9B%BE%E5%83%8F%E7%84%8A%E7%82%B9%E6%A3%80%E6%B5%8B/",
                "title": "使用计算机视觉技术进行PCB图像焊点检测",
                "section": "posts",
                "date" : "2023.05.10",
                "body": "引入需要的工具包 我们会使用 matplotlib 进行绘图，并使用 numpy 处理数组相关的数值计算，以及使用 opencv 提供的计算机视觉工具，请确保工作环境可以正确引入并使用它们。\n%matplotlib inline import matplotlib.pyplot as plt import cv2 as cv import numpy as np 载入并缩放图像 读取一张图像，将其进行缩放，使最长边对齐image_max_side的值，该值的设置可以根据经验，实际处理的图像和任务来做调整。\nimage_max_side = 1024 source_image = cv.imread(\u0026#39;./samples/10.JPG\u0026#39;) scale = image_max_side / max(source_image.shape[:2]) source_image = cv.resize(source_image, None, fx=scale, fy=scale, interpolation=cv.INTER_AREA) plt.imshow(source_image) plt.show() 色彩处理 PCB板感光油的常见颜色为红，绿，蓝。我们可以借助这个特性使图像中集中分布感光油色彩的颜色通道相同，以此来使得非感光油区域与感光油区域之间的差异显著化。\n例如：当前PCB的感光油为绿色，则我们将每一个像素中的第二个「下标为1」值设为255。\nframe = source_image.copy() frame[..., 1] = 255 gray = cv.cvtColor(frame, cv.COLOR_RGB2GRAY) plt.imshow(gray, cmap=\u0026#39;gray\u0026#39;) plt.show() 图像二值化特征 我们在色彩处理的基础上，首先对图像进行了归一化操作，然后使用7x7核的高斯模糊，接下来使用大律法进行图像二值化。\n高斯模糊可以消除一些噪声的影响，使用7x7的核是一个经验，可以根据实际情况使用不同尺寸的核进行实验比对。\nnormal = ((gray - gray.min()) / max(1, (gray.max() - gray.min())) * 255).astype(np.uint8) blur = cv.GaussianBlur(normal, (7, 7), 0) ret, thresh = cv.threshold(blur, 127, 255, cv.THRESH_OTSU) plt.imshow(thresh, cmap=\u0026#39;gray\u0026#39;) plt.show() 形态学处理 我们使用形态学处理的闭合操作将个别二值化后出现破碎的焊点色块进行闭合。\nkernel = np.ones((5, 5), np.uint8) closing = cv.morphologyEx(thresh, cv.MORPH_CLOSE, kernel, iterations=1) plt.imshow(closing, cmap=\u0026#39;gray\u0026#39;) plt.show() 提取“拉丝”线 使用边缘检测的方法我们可以获取各个色块的边缘线，对这些线反复进行形态学闭合操作，可以将细长的色块「即“拉丝”线的色块」有效的提取出来。\nedges = cv.Canny(closing, 100, 200) edges = cv.morphologyEx(edges, cv.MORPH_CLOSE, kernel, iterations=3) plt.imshow(edges, cmap=\u0026#39;gray\u0026#39;) plt.show() 去除“拉丝” 将检测到的“拉丝”色块从之前形态学处理过的二值化图像中移除，得到最终的二值化特征。\nfinal = closing * (edges \u0026lt; 127).astype(np.uint8) plt.figure(figsize=(10, 10)) plt.subplot(121) plt.imshow(final, cmap=\u0026#39;gray\u0026#39;) plt.subplot(122) plt.imshow(source_image, cmap=\u0026#39;gray\u0026#39;) plt.show() 获取色块的位置和大小信息 我们使用 opencv 提供的findContours工具可以快速提取出这些焊点色块的轮廓，然后调用boundingRect之类的工具可以检测出焊点位置和大小等信息。\ncontours, _ = cv.findContours(final, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE) boxes = [] for cont in contours: x, y, w, h = cv.boundingRect(cont[:, 0]) if max(w, h) \u0026gt; min(final.shape) / 2: continue if min(w, h) \u0026lt; 5: continue boxes.append(cv.boxPoints(((x + w / 2, y + h / 2), (w, h), 0)).astype(np.int32)) view = source_image.copy() cv.polylines(view, boxes, True, (255, 0, 0), 2, cv.LINE_AA) plt.figure(figsize=(8, 8)) plt.imshow(view) plt.show() 下篇 使用计算机视觉技术进行PCB图像连接线检测\n"
            }
    
        ,
            {
                "id": 11,
                "href": "https://bxtkezhan.github.io/godot%E5%BC%80%E5%8F%913d%E5%8A%A8%E4%BD%9C/",
                "title": "Godot开发・3D动作",
                "section": "posts",
                "date" : "2023.04.23",
                "body": "今天我们来学习使用Godot 3D模式下的物体运动操作，我们主要会使用到RigidBody3D「刚体」, StaticBody3D「静态」, Camera3D「相机」, DirectionalLight3D「定向光源」这四个节点。当然，除了这几个主要的节点，我们还会使用到处理碰撞检测的CollisionShape3D节点，Godot预置的3D模型，立方体CSGBox3D节点与圆柱体CSGCylinder3D节点。\n创建场景并安放节点 我们新建一个项目，并把会用到的节点按着如下结构放置在场景中:\nNode[重命名为Root] StaticBody3D CollisionShape3D CSGBox3D RigidBody3D CollisionShape3D CSGCylinder3D Camera3D DirectionalLight3D 设置节点 我们为StaticBody3D的子节点CollisionShape3D设置属性Shape，这里我们给定一个BoxShape属性并且把Size x改为10m，z改为10m:\n我们将StaticBody3D的子节点CSGBox3D中的Size也做同样的修改，使物理实体对齐碰撞检测的Shape:\n我们选中RigidBody3D节点，然后设置它的位置Position，将y改为3.5m:\n我们将Camera3D节点的位置Position和旋转角度Rotation也做修改:\n我们最后再对DirectionalLight3D节点的位置Position和旋转角度Rotation做修改:\n现在我们可以按键盘快捷键F6，运行该场景进行预览:\n插入控制脚本 我们右键节点RigidBody3D，点击Attach Script选项，为其添加脚本，并把如下内容写入脚本:\nextends RigidBody3D # Called when the node enters the scene tree for the first time. func _ready(): pass # Replace with function body. # Called every frame. \u0026#39;delta\u0026#39; is the elapsed time since the previous frame. func _physics_process(delta): if Input.is_action_pressed(\u0026#34;ui_left\u0026#34;): linear_velocity.x = -3 if Input.is_action_pressed(\u0026#34;ui_right\u0026#34;): linear_velocity.x = 3 if Input.is_action_pressed(\u0026#34;ui_up\u0026#34;): linear_velocity.z = -3 if Input.is_action_pressed(\u0026#34;ui_down\u0026#34;): linear_velocity.z = 3 一般来说我们在函数_physics_process中控制物体的物理运动。\n我们可以使用方法Input.is_action_pressed来获取键盘方向键输入，ui_left, ui_right, ui_up, ui_down分别对应键盘方向键左，右，上，下。\nlinear_velocity用于设置刚体的运动速度，我们这里只处理x和z方向。\n例如，当键盘方向键左被按住时触发:\nif Input.is_action_pressed(\u0026#34;ui_left\u0026#34;): linear_velocity.x = -3 我们将x方向的速度设置为-3。\n保存后，再次运行场景，我们就可以使用键盘方向键来操作我们的物体进行运动了:\n"
            }
    
        ,
            {
                "id": 12,
                "href": "https://bxtkezhan.github.io/godot%E5%BC%80%E5%8F%91%E8%8A%82%E7%82%B9%E4%B8%8E%E5%9C%BA%E6%99%AF/",
                "title": "Godot开发・节点与场景",
                "section": "posts",
                "date" : "2023.04.04",
                "body": "在使用Godot开发项目时，我们会用到节点「Node」来构建和处理我们需要的场景、角色、灯光、相机、播放器等物件。另外，我们可以在不同场景「Scene」中布置不同的节点结构来实现不同的游戏场景。\n创建第一个场景 打开Godot，进入新创建的项目时，会看到侧栏场景面板中提示创建一个根节点「Root Node」，这时我们可以选择其中一个节点类型并创建一个根节点，然后我们将得到一个新的场景，而该场景的根节点为我们选择节点。\n这里我们从其它节点「Other Node」中搜索“Node”，并选择它进行创建。这样我将的到一个元节点为根节点的场景，之后我们可以在它底下创建其它类型的节点，例如：3D类型的节点，2D类型的节点或是处理UI的节点……\n接下来，我们鼠标双击该节点进行重命名。我们将其命名为“Main”，然后使用快捷键Ctrl+S保存场景:\n之后我们就可以在该场景的基础上添加、制作我们需要的物件节点。\n"
            }
    
        ,
            {
                "id": 13,
                "href": "https://bxtkezhan.github.io/godot%E5%BC%80%E5%8F%91%E5%AE%89%E8%A3%85godot4/",
                "title": "Godot开发・安装Godot4",
                "section": "posts",
                "date" : "2023.03.29",
                "body": "前不久我在浏览几个游戏开发引擎的时候发现了这些支持3D游戏开发的引擎除了有提供游戏开发功能外还专门标识了可以用于工业仿真，例如：机械臂、车间流水线。正好我其实也对这些东西比较感兴趣，所以我决定尝试使用Godot游戏引擎来实现一个机械仿真工具，便于我之后研究自己的3D打印机、CNC、机械臂。\n其实我在比较早的时候就接触了Godot游戏引擎，当时是使用的2.5版本，最近发现Godot4.0已经释出了，我决定重新开始学习使用它。另外，我会把我的学习和使用的过程记录到我的博客中，一方面是为了记录；一方面是为了分享。\n说完了写作的目的，我们来看看怎么安装Godot4。\n下载并安装Godot4 我们可以去到网址：https://godotengine.org/download/ 下载适合自己版本的Godot4。\n目前Godot4支持多个平台的开发环境部署，值得注意的是它不但支持Linux、Mac OS、Windows这三个主要的操作系统，还有推出Web DEV环境的部署和Android环境的部署，也就是我们还可以使用网页端或Android端进行开发。\n另外，关于下载安装包，我这边还有一点需要说明，就是Godot除了标准版本的开发环境安装包，还有针对C#的开发环境安装包「其实也有Python、C++……」，我这边只会使用Godot的标准开发环境安装包，在该安装包中我将比较多的使用Godot自己的开发语言GDScript。\n创建新项目并安装导出模板 在安装完Godot后，我们运行打开它，并新建一个项目：\n点击菜单栏编辑器选项「Editor」，点击子选项管理导出模板「Manage Export Templates」打开导出模板管理器，点击下载并安装：\n安装导出模板可以让我们把开发好的工程导出成测试版本「Debug」或者发行版本「Release」给其它没有部署开发环境的机器运行。\nPS: 如果觉得Godot的下载速度太慢，你可以自己去到官方下载地址先下载导出模板文件，然后在模板管理器中使用从文件安装「Install from File」找到下载好的文件并进行安装。\n"
            }
    
        ,
            {
                "id": 14,
                "href": "https://bxtkezhan.github.io/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A0%81%E5%99%A8/",
                "title": "图像生成模型基础・自动编码器",
                "section": "posts",
                "date" : "2023.03.06",
                "body": "今天我们使用Python编程语言和PyTorch深度学习库实现一个用于图像有损压缩的自动编码器模型，针对MNIST数据集进行讲解。\n什么是自动编码器？ 自动编码器是一种无监督学习算法，它可以用来学习输入数据的低维表示。自动编码器包含一个编码器和一个解码器，编码器将输入数据映射到低维空间，解码器将低维表示映射回原始空间。自动编码器的目标是通过最小化重构误差来学习这些映射，使得解码器能够生成与原始输入相似的输出。\nMNIST数据集 MNIST数据集是一个手写数字数据集，包含60,000个训练样本和10,000个测试样本。每个样本是一个28x28像素的灰度图像，标签是0到9之间的数字。我们将使用MNIST数据集来训练自动编码器，以学习输入数据的低维表示。\n自动编码器的实现 我们将使用PyTorch来实现自动编码器。以下是自动编码器的实现步骤：\n1 .导入必要的库和数据集。\nimport torch import torch.nn as nn import torch.optim as optim from torchvision import datasets, transforms # 加载MNIST数据集 train_dataset = datasets.MNIST( root=\u0026#34;.\u0026#34;, train=True, download=True, transform=transforms.ToTensor(), ) test_dataset = datasets.MNIST( root=\u0026#34;.\u0026#34;, train=False, download=True, transform=transforms.ToTensor(), ) # 创建数据加载器 train_loader = torch.utils.data.DataLoader( train_dataset, batch_size=128, shuffle=True ) test_loader = torch.utils.data.DataLoader( test_dataset, batch_size=128, shuffle=True ) 2 .定义自动编码器的结构。\nclass Autoencoder(nn.Module): def __init__(self): super(Autoencoder, self).__init__() self.encoder = nn.Sequential( nn.Linear(784, 128), nn.ReLU(), nn.Linear(128, 64), nn.ReLU(), nn.Linear(64, 16), ) self.decoder = nn.Sequential( nn.Linear(16, 64), nn.ReLU(), nn.Linear(64, 128), nn.ReLU(), nn.Linear(128, 784), nn.Sigmoid(), ) def forward(self, x): x = x.flatten(1) x = self.encoder(x) x = self.decoder(x) return x 这个自动编码器有三个隐藏层，分别是128、64和16个神经元。编码器和解码器都使用ReLU激活函数，输出层使用Sigmoid激活函数。\n3 .训练自动编码器。\ndevice = torch.device(\u0026#34;cuda\u0026#34; if torch.cuda.is_available() else \u0026#34;cpu\u0026#34;) model = Autoencoder().to(device) criterion = nn.BCELoss() optimizer = optim.Adam(model.parameters(), lr=1e-3) num_epochs = 10 for epoch in range(num_epochs): train_loss = 0 for data in train_loader: img, _ = data img = img.to(device) optimizer.zero_grad() recon = model(img) loss = criterion(recon, img.flatten(1)) loss.backward() optimizer.step() train_loss += loss.item() print(\u0026#34;Epoch [{}/{}], Loss: {:.4f}\u0026#34;.format(epoch + 1, num_epochs, train_loss / len(train_loader))) torch.save(model.state_dict(), \u0026#34;autoencoder.pt\u0026#34;) 我们使用BCE损失函数和Adam优化器来训练自动编码器。在每个训练周期中，我们遍历整个训练数据集，并更新模型参数。最后，我们保存训练好的自动编码器模型。\n4 .测试自动编码器。\nmodel.load_state_dict(torch.load(\u0026#34;autoencoder.pt\u0026#34;)) test_loss = 0 with torch.no_grad(): for data in test_loader: img, _ = data img = img.to(device) recon = model(img) loss = criterion(recon, img) test_loss += loss.item() print(\u0026#34;Test Loss: {:.4f}\u0026#34;.format(test_loss / len(test_loader))) 在测试集上，我们计算自动编码器的重构误差。如果我们的自动编码器学习了数据的有效低维表示，那么重构误差应该比较小。\n5 .使用自动编码器进行图像重构。\nimport matplotlib.pyplot as plt n_images = 10 image_size = 28 fig, axes = plt.subplots(nrows=2, ncols=n_images, sharex=True, sharey=True, figsize=(20, 4)) for i in range(n_images): test_image, _ = test_dataset[i] test_image = test_image.to(device) # 原始图像 axes[0][i].imshow(test_image.cpu().numpy().reshape(image_size, image_size), cmap=\u0026#34;gray\u0026#34;) axes[0][i].get_xaxis().set_visible(False) axes[0][i].get_yaxis().set_visible(False) # 重构图像 with torch.no_grad(): outputs = model(test_image.unsqueeze(0)) reconstructed_image = outputs.cpu().numpy().reshape(image_size, image_size) axes[1][i].imshow(reconstructed_image, cmap=\u0026#34;gray\u0026#34;) axes[1][i].get_xaxis().set_visible(False) axes[1][i].get_yaxis().set_visible(False) plt.show() 我们可以使用训练好的自动编码器对图像进行重构。上面的代码将显示原始图像和重构图像。如果我们的自动编码器学习了数据的有效低维表示，那么重构图像应该与原始图像相似。\n以下为重构效果演示，第一行为原始图像，第二行为对应的重构图像:\n结论 在本教程中，我们使用Python和PyTorch实现了一个自动编码器，并使用MNIST数据集进行训练和测试。我们还展示了如何使用训练好的自动编码器进行图像重构。自动编码器是深度学习中的一个重要概念，\n"
            }
    
        ,
            {
                "id": 15,
                "href": "https://bxtkezhan.github.io/%E5%88%9B%E5%AE%A2%E4%B8%80%E7%82%B9%E7%81%B5%E7%BB%98%E5%88%B6%E5%AE%8C%E6%95%B4%E6%8C%82%E9%92%A9/",
                "title": "创客一点灵・绘制完整挂钩",
                "section": "posts",
                "date" : "2023.01.11",
                "body": "我们已经学习过了挂钩主体的3D绘制，今天我们就来完成一个完整的挂钩绘制。\n绘制平板 我们的挂钩与墙体粘贴的部分是一个有着些许厚度的平板，我们先来绘制一下这个平板。\n我们在X-Y平面绘制一个长、宽都是60mm的正方形，并让其居中:\n当其成为完全图后，我们点击按钮Close，退回物件设计工作台模式，然后使用Pad工具生成厚度为2.5mm的平板:\n绘制钩子 有了平板后，我们就可以开始绘制钩子，但是再次之前我们需要检查一下FreeCAD的布尔运算配置。\n我们在Edit菜单栏中的Preferences设置中的Part Design选项里勾选下列内容并点击Apply按钮，然后点击OK按钮保存并退出:\n在完成上述配置后，我们建模时相接的部分才会自动变为一个整体。\n完成准备工作后我们在X-Z平面绘制一个钩子，钩子的绘制方法可以参考上一节的内容，这里不做过多赘述:\n需要注意的是: 我们的平板厚度为2.5mm因此为了确保钩子与平板接合，钩子离水平轴的距离应该小于2.5mm，我这里设置为2.4mm。\n接下来我们点击Close按钮退回到物件设计工作台模式，使用Pad工具将钩子的厚度做出来，厚度我这边设置为10mm。此外，我们还需要勾选平面对齐的选项来确保钩子的位置正确:\n确认无误后点击OK按钮完成编辑。\n绘制凹陷平面 为了方便打胶，我们可以在挂钩平板的背后制作一个凹陷的平面。\n我们使用鼠标中键可以旋转物件，我们先将其旋转到背面，然后用鼠标左键点选背面，这时再按Create sketch按钮则可以在该平面绘制草图:\n我们绘制一个对齐居中的长、宽都是56mm的正方形作为完全图并点击Close按钮退回:\n我们使用Pocket工具在这个地方挖一个1mm深度的平面:\n需要注意的是由于默认Pocket挖取的深度超过了平板的厚度，可能会导致在点击Pocket工具的使用出现图形显示问题，这时只需要设置好正确的深度数值就可以正常显示图像了。\n在确定无误后我们点击OK按钮完成绘制，这时我们就得到了一个完整的挂钩:\n"
            }
    
        ,
            {
                "id": 16,
                "href": "https://bxtkezhan.github.io/%E5%88%9B%E5%AE%A2%E4%B8%80%E7%82%B9%E7%81%B5%E7%BB%98%E5%88%B6%E9%92%A9%E5%AD%90/",
                "title": "创客一点灵・绘制钩子",
                "section": "posts",
                "date" : "2022.12.09",
                "body": "今天我们来完成挂钩中钩子部分的绘制，并且今天的操作需要基于上一节中学习到的基础知识，建议没有看过上一节内容的朋友先去到上一节进行了解，然后再来学习今天的操作。\n准备工作 我们先进入部件设计工作台「Part Design」，然后点击按钮「Create sketch」创建一张草图，我们选择x-z平面进行绘制:\nPolyline工具 在创建草图后，FreeCAD会自动为我们打开草图工作台「Sketcher」，我们点击按钮「Create polyline」启用Polyline绘制工具:\n启用Polyline工具后，我们可以通过在绘图区域按鼠标左键点击不同的位置来绘制复杂的图形，并且我们可以使用键盘字母键“M”来切换线条模式，在绘制完毕后可以按键盘Esc键退出Polyline工具。\n我们要绘制的钩子的形态大致如下:\n我再绘制该图形的各点的位置顺序，从1到7「其中第1点与第7点重合」，显示如下:\n该图形绘制过程中需在第2、4、6点处按键盘字母键“M”来切换线条模式，大家可以逐个尝试判断出适合的线条模式。\n调整图形 我们需要将第1、2点之间的线与第3、4点之间的线设置为水平，我们可以点击其中一条，然后按键盘字母键“H”将其设置为水平:\n点4点5之间的圆弧与点6点7之间的圆弧，它们的圆形要重合，我们可以框选它们然后按键盘字母键“C”将它们合并:\n将点5点6之间的直线设置为竖直，点选该直线，然后按键盘字母键“V“将其设置竖直:\n将点4与点1设置为竖直对齐，点选点4与点1并按键盘字母键“V”将其设置竖直对齐:\n确定图形位置 我们将图形的点1与座标轴原点设置重合，点选点1与座标原点并按键盘字母键“C”将其设置重合:\n确定图形尺寸 我们大致只需确定点1与点2的水平距离，点5与点6的竖直距离，点5与点4的竖直距离就可以了。两点间确定竖直距离，我们可以点选这两点，然后按键盘字母键“I”进行设置；两点间确定水平距离，我们可以点选这两点，然后按键盘字母键“L”进行设置，完成设置后我们的效果大致一个如下:\n生成立体图形 我们在绘制完平面图形后，点击按钮Close结束绘制并回到部件设计工作台，然后点击按钮「Pad」生成一个有厚度的三维图形:\n我们启用选项「Symmetric to plane」将三维图形设置为关于平面对称的样式，最后点击按钮OK结束绘制:\n至此，我们完成了挂钩钩子部分的三维图形绘制。\n"
            }
    
        ,
            {
                "id": 17,
                "href": "https://bxtkezhan.github.io/%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8B%E5%B0%8F%E5%BC%9F%E7%94%A8%E5%BE%97%E6%AF%94%E8%BE%83%E5%A4%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/",
                "title": "盘点一下小弟用得比较多的编程语言",
                "section": "posts",
                "date" : "2022.11.29",
                "body": "Python AFour = \u0026#39;\u0026#39; print(AFour) python是我目前最长用的程序语言，由于我目前主要的工作涉及到深度学习，图像、文字处理，因此python是我的首选。\nJavascript var AFour = \u0026#39;\u0026#39;; console.log(AFour); javascript是我在做一些涉及web端的项目时，由于甲方的需求，我需要制作相关的api或sdk，这时我就会使用javascript来完成。\nGolang AFour := \u0026#34;\u0026#34; fmt.Println(AFour) 我开发的某些项目被要求可以跨平台运行而且无需安装虚拟机、解释器这类运行环境，这个时候我会首先考虑用Go来开发并编译多个系统版本。\nC/C++ char AFour[] = \u0026#34;\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, AFour); std::cout \u0026lt;\u0026lt; AFour \u0026lt;\u0026lt; std::endl; 个别任务很追求运行效率，又或者需要触及操作系统、硬件底层，这时我就会使用C/C++或者类似的程序语言，然而这部分任务通常只是我个人的兴趣使然。\n"
            }
    
        ,
            {
                "id": 18,
                "href": "https://bxtkezhan.github.io/%E5%88%9B%E5%AE%A2%E4%B8%80%E7%82%B9%E7%81%B5%E8%8D%89%E5%9B%BE/",
                "title": "创客一点灵・草图",
                "section": "posts",
                "date" : "2022.11.26",
                "body": "我们使用FreeCAD设计模型时会用到FreeCAD中的草图（sketch），一般来说，我们要设计某个三维模型部件会需要先绘制该部件的二维平面草图，然后按照需求将草图转换为三维空间中的物体，接下来再在这个三维物体的基础上绘制二维平面的草图然后对这个三维物体进行修改，重复这个步骤直到模型设计完毕。具体的操作细节我们会在之后的章节中学习，现在我们来学习一下绘制草图并生成三维物体的这个最基础的操作。\n为模型部件创建草图 如果我们要在FreeCAD中设计某个三维模型部件，我们的常用操作流程是:\n打开FreeCAD，然后点击菜单栏的File，然后点击选项New「这个操作可以使用快捷方式Ctr+N完成」; 接下来我们切换工作台从Start到Part Design; 然后点击按钮Create sketch创建草图； 接下来我们需要为该草图选择平面「下图示范中使用X-Y平面」，然后点击按钮OK； 完成上述操作后，我们将进入草图编辑器工作台Sketcher:\n绘制草图 我们选择矩形工具，然后在场景中进行绘制，绘制的方法是先点击场景中的某个位置，然后移动鼠标到另一个位置再次点击:\n我们需要为这个矩形设置具体的大小和座标，拥有确定座标和大小的图形才可以用于后续的工程开发，这种精确没有歧义的图形可以被叫做“完全图”。\n首先，我们来确定一下矩形的高度大小，我们点击矩形中的一条侧边「左右都行」，然后按键盘字母键“i”则会弹出对话框，我们设置尺寸为50mm并点击按钮OK:\n然后，我们确定一下矩形的宽度大小，我们点击矩形中的一条水平边「上下都行」，然后按键盘字母键“l“则会弹出对话框，我们设置尺寸为60mm并点击按钮OK:\n接下来，我们确定一下矩形的位置，我们点击矩形的左下角的顶尖，然后点击十字座标的中心原点，当这两个点都高亮激活后，我们按键盘字母键“c”，这样它们就会进行对齐，此时我们就得到了一个位置的大小、形状都确定的“完全图”:\n点击按钮Close退出草图编辑器:\n生成三维图形 在退出草图编辑工作台后，会自动来到部件设计工作台，这时我们点击按钮Pad，将我们刚刚绘制的草图转换为三维模型:\n我们把厚度设置为15mm，然后点击按钮OK完成三维模型的生成:\n至此我们的草图绘制并生成三维图像的基础操作就完毕了，我们可以按快捷键Ctrl+S将其进行保存到本地文件。\n"
            }
    
        ,
            {
                "id": 19,
                "href": "https://bxtkezhan.github.io/%E5%88%9B%E5%AE%A2%E4%B8%80%E7%82%B9%E7%81%B5%E5%AE%89%E8%A3%85freecad/",
                "title": "创客一点灵・安装FreeCAD",
                "section": "posts",
                "date" : "2022.11.09",
                "body": "“FreeCAD 是一款通用参数化三维计算机辅助设计建模器和支持有限元方法的建筑信息建模软件应用程序。”我们将使用它来进行三维模型的绘制。\n首先我们去到FreeCAD的项目主页：https://www.freecadweb.org/\n通过浏览主页我们大致可以了解FreeCAD可以用来做机构模型设计，部件装配测试，建筑设计以及有限元分析。\n由于我们当前的教程仅对FreeCAD三维建模的部分做初步讲解，因此，如果有朋友想要对FreeCAD有更加深层次的了解，可以去到官方文档进行学习：https://wiki.freecadweb.org/\n下载与安装 我们可以进入官方下载页面，下载官方最新推荐的版本到本地进行安装：https://www.freecadweb.org/downloads.php\nNote! 请根据自己的操作系统版本进行下载：如果你是微软Windows系统用户请下载对应的Windows版本；如果你是苹果Mac OS系统用户请下载对应的Mac版本；如果你是Linux发行版用户请下载对应的Linux版本。\nMac版本与Linux版本下载后可以向打开普通的本地软件一样点击运行，Windows版本则可以双击进行安装，然后打开运行。\n基本设置 在这次的项目设计中我们会使用到FreeCAD的部件设计布尔运算功能，我们可以在部件设计工作台模型下设置并启用它。\n首先，我们启动FreeCAD，然后会默认进入开始工作台「Start」:\n我们点击按钮Start并切换到部件设计「Part Design」工作台模式：\n然后点击菜单栏的Edit，点击其子菜单Preferences，在弹出的设置框左侧选中Part Design，然后勾选建模设置「Model settings」下的三个选项:\n接下来点击设置框底部按钮应用「Apply」最后点击按钮OK完成并退出设置。\n按键风格 我们在FreeCAD的右下方可以找到设置按键风格的按钮，如果你这边不是使用Blender按键风格，建议你点击该按钮并将其设置成Blender按键风格:\n"
            }
    
        ,
            {
                "id": 20,
                "href": "https://bxtkezhan.github.io/%E5%88%9B%E5%AE%A2%E4%B8%80%E7%82%B9%E7%81%B5%E4%BB%8E%E6%8C%82%E9%92%A9%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/",
                "title": "创客一点灵・从挂钩开始的学习",
                "section": "posts",
                "date" : "2022.10.29",
                "body": "为了贯彻宅的信念，我们需要能够自己在家「生产」一些实用的工具。而要实现在家生产，我们就需要掌握一些相关领域的知识与技能。\n本套教学，将介绍与教导关于这些领域的基本知识与技术。为了便于屏幕前的观众理解这些知识与技术，我们设计了一个精简、实用的案例进行讲解。我们会从零开始设计并制造一个墙壁挂钩，从模型的设计到实物的生产我们都会完全亲历亲为，并且其中的每一步操作原则上都可以由一人独自在家完成。\n如果观众顺利完成了既定的目标，那么原则上也可以自己在家设计并生产其它的「产品」。感兴趣的朋友可以看看接下来关于挂钩的项目介绍以便了解整个项目与教学的大致内容。\n我们要制作的挂钩就长这样「如下所示」，基本上就是由一个带凹面的扁平方体，加一个J形的钩子组成。在使用的时候我们可以在方体的凹面粘上强力泡沫胶或涂抹热溶胶然后将其粘贴在瓷砖或木质的平面上。\n从下一节开始我们会学习使用FreeCAD绘制出这个挂钩的三维数字模型，然后学习如何使用3D打印机将设计的三维模型打印出来。\n"
            }
    
        ,
            {
                "id": 21,
                "href": "https://bxtkezhan.github.io/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%89%B9%E9%87%8F%E6%A0%87%E5%87%86%E5%8C%96/",
                "title": "人工神经网络・批量标准化",
                "section": "posts",
                "date" : "2022.10.03",
                "body": "返回教程主页\n上篇 人工神经网络・卷积神经网络\n在数据处理中常常使用标准化技术对数据进行处理，一般来说标准化处理有利于提升模型对数据的拟合效果。我们也可以使用标准化技术对神经网络模型进行升级。\n批量标准化 使用批量标准化BatchNormalization方法，我们可以对神经网络模型进行优化。批量标准化的数学公式如下:\n$$ y = \\frac{x - E[x]}{\\sqrt{Var(x) + \\epsilon}} \\ast \\gamma + \\beta $$\n公式当中的 $\\epsilon$ 通常会是一个非常小的正数，用于防止程序出现除0错误，故此公式可以看成:\n$$ y = \\frac{x - E[x]}{\\sqrt{Var(x)}} \\ast \\gamma + \\beta $$\n即: $x$ 减去 $x$ 的期望 $E[x]$ 然后除以方差 $Var(x)$ 的开根，再乘上参数 $\\gamma$ 最后加上参数 $\\beta$ 。其中参数 $\\gamma , \\beta$ 是需要训练更新的值，在PyTorch中，初始情况下 $\\gamma$ 的元素值被设置为1而 $\\beta$ 的元素值被设置为0。\n优化代码 我们对之前的卷积神经网络进行优化，先前的模型结构如下:\ncnn = nn.Sequential( nn.Conv2d(1, 10, 5), nn.ReLU(inplace=True), nn.MaxPool2d(2), nn.Conv2d(10, 20, 3), nn.ReLU(inplace=True), nn.MaxPool2d(2), nn.Flatten(), nn.Linear(20 * 5 * 5, 10), nn.Softmax(dim=1)) 经过优化后的结构如下:\ncnn = nn.Sequential( nn.Conv2d(1, 10, 5), nn.BatchNorm2d(10), nn.ReLU(inplace=True), nn.MaxPool2d(2), nn.Conv2d(10, 20, 3), nn.BatchNorm2d(20), nn.ReLU(inplace=True), nn.MaxPool2d(2), nn.Flatten(), nn.Linear(20 * 5 * 5, 10), nn.Softmax(dim=1)) 我们在卷积层nn.Conv2d后面插入批量标准化层nn.BatchNorm2d来实现数据标准化，需要注意的是批量标准化层的第一个参数应该被指定为卷积层输出的通道数量，例如: nn.Conv2d(1, 10, 5)对应nn.BatchNorm2d(10)；nn.Conv2d(10, 20, 3)对应nn.BatchNorm2d(20)。\n重新运行代码训练模型 接下来，我们在同之前一样的条件下重新训练这个卷积神经网络。\n通过10轮的训练，我们的新模型在测试集上的表现如下:\ntesting... loss=1.4737657746182213, accuracy=0.9891 其中损失率loss为1.4737657左右，准确率达到98.91%。\n这一次改善在非常大的程度上提高了拟合效率，在训练进行到第二轮的时候测试集准确率就超过了上一代网络的最终测试集准确率，并且在完成10轮训练后，测试集的准确率直逼99%，如果我们增加几轮训练，估计达到99%的测试集准确率不是问题。\n"
            }
    
        ,
            {
                "id": 22,
                "href": "https://bxtkezhan.github.io/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/",
                "title": "人工神经网络・卷积神经网络",
                "section": "posts",
                "date" : "2022.10.03",
                "body": "返回教程主页\n上篇 人工神经网络・ReLU激活函数\n我们之前构建的神经网络都是靠普通的线性网络层Linear进行拟合，然而在处理图像数据的时候我们其实可以用效果更好的卷积网络层。将卷积网络层加入到我们的神经网络就可以在一定程度上提升模型的准确率，而由于此种神经网络的结构中包含卷积网络层，因此，也常被叫做卷积神经网络。\n卷积 卷积是一种常被用在信号处理领域的计算方式，而在处理如图像这种类型的数据时常常会用到二维卷积，二维卷积的计算方式如下:\n动画演示左侧的矩阵为输入，右侧的矩阵为输出，中间的是卷积核，卷积核的概念类似线性计算中的权重Weight，我们可以将卷积操作写成如下公式:\n$$ Y = X \\ast k $$\n假设输入X是一个5x5的矩阵，而卷积核k是一个3x3的矩阵，那么输出的Y是一个$(5 - 3 + 1)$x$(5 - 3 + 1)$的矩阵及3x3的矩阵。计算方法是: 输出Y的维度 = 输入X的维度 - 卷积核k的维度 + 1。\n池化 池化操作常常与卷积操作一同使用，它可以让数据变得「精炼」:\n以上动画演示的是最大池化操作，它会输出数个相邻格子中最大的值。当它的检测窗口大小为2x2时「正如动画中所示」，它可以将原本输入的4x4的矩阵转变为2x2的矩阵输出。\n了解了卷积和池化操作，我们再来看看如何应用到神经网络。\n卷积神经网络 上一节中，我们的神经网络结构如下:\nmlp = nn.Sequential( nn.Flatten(), nn.Linear(28 * 28 * 1, 256), nn.ReLU(inplace=True), nn.Linear(256, 10), nn.Softmax(dim=1)) 我们将其进行修改:\ncnn = nn.Sequential( nn.Conv2d(1, 10, 5), nn.ReLU(inplace=True), nn.MaxPool2d(2), nn.Conv2d(10, 20, 3), nn.ReLU(inplace=True), nn.MaxPool2d(2), nn.Flatten(), nn.Linear(20 * 5 * 5, 10), nn.Softmax(dim=1)) 调用nn.Conv2d(1, 10, 5)构建一个卷积层，它的输入为1，对应图像的通道数，输出通道数为10，卷积核的大小为5x5；调用nn.MaxPool2d(2)构建一个最大池化层，它的检测窗口大小为2x2……\n我们输入数据的维度是: nx1x28x28「batch size x 图像通道数 x 图像像素高度 x 图像像素宽度； 经过神经网络第一层nn.Conv2d(1, 10, 5)输出: nx10x24x24； 经过神经网络第二层nn.ReLU(inplace=True)输出: 同上； 经过神经网络第三层nn.MaxPool2d(2)输出: nx10x12x12； 经过神经网络第四层nn.Conv2d(10, 20, 3)输出: nx20x10x10； 经过神经网络第五层nn.ReLU(inplace=True)输出: 同上； 经过神经网络第六层nn.MaxPool2d(2)输出: nx20x5x5； …… 重新运行代码训练模型 我们在同之前一样的条件下训练这个卷积神经网络。\n通过10轮的训练，我们的新模型在测试集上的表现如下:\ntesting... loss=1.4784890896157374, accuracy=0.9838 其中损失率loss为1.478489左右，准确率达到98.38%。\n这一次修改使得模型无论在拟合效果还是最终测试准确率上都有显著提升。\n完整代码 import torch torch.manual_seed(3) import torch.nn as nn import torch.nn.functional as F from torchvision.datasets import MNIST from torchvision.transforms import ToTensor from torch.utils.data import DataLoader train_set = MNIST(\u0026#39;.\u0026#39;, train=True, download=False, transform=ToTensor()) test_set = MNIST(\u0026#39;.\u0026#39;, train=False, download=False, transform=ToTensor()) train_loader = DataLoader(train_set, batch_size=128, shuffle=True) test_loader = DataLoader(test_set, batch_size=128, shuffle=False) cnn = nn.Sequential( nn.Conv2d(1, 10, 5), nn.ReLU(inplace=True), nn.MaxPool2d(2), nn.Conv2d(10, 20, 3), nn.ReLU(inplace=True), nn.MaxPool2d(2), nn.Flatten(), nn.Linear(20 * 5 * 5, 10), nn.Softmax(dim=1)) optimizer = torch.optim.Adam(cnn.parameters(), lr=0.001) for epoch in range(10): print(\u0026#39;training...\u0026#39;) cnn = cnn.train() for step, (inputs, targets) in enumerate(train_loader): outputs = cnn(inputs) loss = F.cross_entropy(outputs, targets) optimizer.zero_grad() loss.backward() optimizer.step() if step % 100 == 0: with torch.no_grad(): compares = torch.argmax(outputs, dim=1) == targets accuracy = torch.mean(compares.type(torch.float32)).item() print(f\u0026#39;{epoch}:{step}, loss={loss.item()}, accuracy={accuracy}\u0026#39;) print(\u0026#39;testing...\u0026#39;) cnn = cnn.eval() losses = [] count = 0 with torch.no_grad(): for step, (inputs, targets) in enumerate(test_loader): outputs = cnn(inputs) loss = F.cross_entropy(outputs, targets) losses.append(loss.item()) compares = torch.argmax(outputs, dim=1) == targets count += torch.sum(compares.type(torch.long)).item() loss = sum(losses) / len(losses) accuracy = count / len(test_set) print(f\u0026#39;loss={loss}, accuracy={accuracy}\u0026#39;) torch.save(cnn, \u0026#39;cnn.pt\u0026#39;) cnn = torch.load(\u0026#39;cnn.pt\u0026#39;) print(cnn) 下篇 人工神经网络・批量标准化\n"
            }
    
        ,
            {
                "id": 23,
                "href": "https://bxtkezhan.github.io/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Crelu%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/",
                "title": "人工神经网络・ReLU激活函数",
                "section": "posts",
                "date" : "2022.10.03",
                "body": "返回教程主页\n上篇 人工神经网络・多层感知器\n上一节中我们实现了一个多层感知器神经网络用来处理图像分类问题。然而那个神经网络模型还是比较「稚嫩」，我们可以对其稍加修改，实现一定程度上的提升。\n原本的神经网络结构如下:\nmlp = nn.Sequential( nn.Flatten(), nn.Linear(28 * 28 * 1, 256), nn.Sigmoid(), nn.Linear(256, 10), nn.Softmax(dim=1)) 我们看到该神经网络中间有一个Sigmoid层，该层网络作为线性层Linear的激活函数，用在多层感知器内时会出现一个问题: 由于sigmoid函数会让输出数值落在0到1之间，因此其后的计算免不了乘上一个小于1的正数，这不利于数值在神经网络中进行传递。\n为了处理sigmoid激活函数带来的问题，我们将引入一个新的激活函数relu。\nReLU激活函数 relu激活函数的数学公式如下:\n$$ y = \\begin{cases} x, \u0026amp; \\text{if}\\quad x \u0026gt; 0 \\\\ 0, \u0026amp; \\text{if}\\quad x \\leq 0 \\end{cases} $$\n当输入数值大于0时relu输出数值本身，当输入数值不大于0时relu输出数值0。\n修改神经网络 我们将原本的神经网络模型修改成如下结构:\nmlp = nn.Sequential( nn.Flatten(), nn.Linear(28 * 28 * 1, 256), nn.ReLU(inplace=True), nn.Linear(256, 10), nn.Softmax(dim=1)) 使用nn.ReLU(inplace=True)替代先前的nn.Sigmoid()，参数设置inplace=True会复用上一层网络的输出，通常来说有利于节省存储空间。\n重新运行代码训练模型 我们在同之前一样的条件下重新训练这个新的多层感知器。\n通过10轮的训练，我们的新模型在测试集上的表现如下:\ntesting... loss=1.4900871847249284, accuracy=0.9725 其中损失率loss为1.490087左右，准确率达到97.25%。\n在训练过程中可以发现神经网络的拟合能力有了很大的改善，当模型训练到一半的时候就能达到先前的最终效果，而训练完毕后的模型在测试集上的准确率也有了明显提高。\n下篇 人工神经网络・卷积神经网络\n"
            }
    
        ,
            {
                "id": 24,
                "href": "https://bxtkezhan.github.io/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8/",
                "title": "人工神经网络・多层感知器",
                "section": "posts",
                "date" : "2022.10.02",
                "body": "返回教程主页\n上篇 人工神经网络・Softmax多分类\n之前我们都是采用手工构造的数据来进行学习，这一次我们将处理一个真实场景的问题——手写数字识别。\n具体问题是这样的: 我们需要构造一个神经网络模型来学习如何识别0-9这10个阿拉伯数字「包括0和9」。\n我们会用到机器学习数据集中著名的MNIST数据集，该数据集收集了70000个手写阿拉伯数字图像，其中训练集有60000个，测试集有10000个，每个数字图像的大小为高28像素宽28像素。\n以下为部分数据的内容:\n这个问题要求我们的模型能够接收一个图像作为输入然后输出该图像是0-9中的哪一个数字，显然这是一个多分类问题，我们可以使用softmax。\n引入所需的库 import torch torch.manual_seed(3) import torch.nn as nn import torch.nn.functional as F from torchvision.datasets import MNIST from torchvision.transforms import ToTensor from torch.utils.data import DataLoader torch.nn包含大量PyTorch中神经网络相关的类； MNIST是torchvision提供的MNIST数据工具，可以帮助我们下载管理MNIST数据； ToTensor是torchvision提供的数据转换器，可以将图像转换为PyTorch的张量对象； DataLoader是PyTorch的数据加载器，可以帮助我们处理数据加载任务； 载入数据集 我们需要创建训练集与数据集:\ntrain_set = MNIST(\u0026#39;.\u0026#39;, train=True, download=False, transform=ToTensor()) test_set = MNIST(\u0026#39;.\u0026#39;, train=False, download=False, transform=ToTensor()) MNIST的第一个参数是数据集下载后存放的路径；参数train为真则载入训练集，若为假则载入测试集；参数download为真则会从网络进行下载，反之则不下载；参数transform可以指定一个数据转换器应，我们设置为ToTensor()，这可以为我们将图像转换为张量对象。\n可以使用索引的方法取出数据集中的数据，例如:\ndata, label = train_set[0] tain_set[0]取出第0份数据集中的数据，包括一张图像的张量data，以及该图像的标识label。其中张量data的元素值在0到1之间，label为一个标量数字「对应图像所显示的数字」。\n构造数据加载器 我们需要对训练集与测试集分别构造数据加载器:\ntrain_loader = DataLoader(train_set, batch_size=128, shuffle=True) test_loader = DataLoader(test_set, batch_size=128, shuffle=False) DataLoader的第一个参数指向我们的数据集；参数设置batch_size=128表示每次对Dataloader进行迭代它会取128份数据；参数shuffle设置为真则会对数据集顺序进行打乱，反之则不会打乱顺序。\n我们可以在for循环中用数据加载器迭代取出数据集中的数据:\nfor inputs, targets in train_loader: ... 上述代码中inputs为128张图像的张量所组成的张量对象，我们将其作为模型的输入；targets为128个数字标量所组成的张量对象，我们将其作为损失函数的一个参数。\n构建多层感知器模型 我们使用torch.nn提供的神经网络工具进行模型的构建，这样可以极大的方便模型构建的工作:\nmlp = nn.Sequential( nn.Flatten(), nn.Linear(28 * 28 * 1, 256), nn.Sigmoid(), nn.Linear(256, 10), nn.Softmax(dim=1)) nn.Sequential可以产生一个序列结构的模型，我们将其命名为mlp——多层感知器。在mlp中有如下被叫做神经网络层的元素:\nnn.Flatten(), nn.Linear(784, 256), nn.Sigmoid(), nn.Linear(256, 10), nn.Softmax(dim=1) 数据在进入mlp模型后会按顺序经过这些层的处理并最后进行输出。\n数据首先经过的是nn.Flatten()层，最后经过nn.Softmax(dim=1)层进行输出。\nnn.Flatten()将图像张量进行拉平操作，使得模型的输入编程一个nx784的张量，n为图像数量，784为每一个图像的像素数量； nn.Linear(784, 256)实现之前的矩阵线性变换 $y = XW + b$，第一个参数为输入维度，第二个参数为输出维度； nn.Sigmoid()使用sigmoid函数作为激活函数； nn.Linear(256, 10)实现之前的矩阵线性变换 $y = XW + b$，第一个参数为输入维度，第二个参数为输出维度； nn.Softmax(dim=1)使用softmax函数作为激活函数； 由于存在一个以上的nn.Linear与激活函数的组合，因此该结构可以被叫做多层感知器。\n该序列模型接收参数并输出的方式很简单:\noutputs = mlp(inputs) 设定优化器 由于我们并没有像之前那样显式的定义线性变换层的权重W以及偏置b，因此，为了方便，我们直接使用PyTorch提供的优化器组建来处理权重与偏置的更新任务:\noptimizer = torch.optim.Adam(mlp.parameters(), lr=0.001) torch.optim.Adam是一种常见的优化器。该优化器的第一个参数指向模型所有需要更新优化的权重与偏置，我们使用mlp.parameters()获取它们；参数lr为学习率，这里我们设置为0.001。\n训练并测试模型 我们需要在for循环中进行模型的训练与测试:\nfor epoch in range(10): print(\u0026#39;training...\u0026#39;) mlp = mlp.train() for step, (inputs, targets) in enumerate(train_loader): outputs = mlp(inputs) loss = F.cross_entropy(outputs, targets) optimizer.zero_grad() loss.backward() optimizer.step() if step % 100 == 0: with torch.no_grad(): compares = torch.argmax(outputs, dim=1) == targets accuracy = torch.mean(compares.type(torch.float32)).item() print(f\u0026#39;{epoch}:{step}, loss={loss.item()}, accuracy={accuracy}\u0026#39;) print(\u0026#39;testing...\u0026#39;) mlp = mlp.eval() losses = [] count = 0 with torch.no_grad(): for step, (inputs, targets) in enumerate(test_loader): outputs = mlp(inputs) loss = F.cross_entropy(outputs, targets) losses.append(loss.item()) compares = torch.argmax(outputs, dim=1) == targets count += torch.sum(compares.type(torch.long)).item() loss = sum(losses) / len(losses) accuracy = count / len(test_set) print(f\u0026#39;loss={loss}, accuracy={accuracy}\u0026#39;) 首先我们看到训练部分:\nprint(\u0026#39;training...\u0026#39;) mlp = mlp.train() for step, (inputs, targets) in enumerate(train_loader): outputs = mlp(inputs) loss = F.cross_entropy(outputs, targets) optimizer.zero_grad() loss.backward() optimizer.step() if step % 100 == 0: with torch.no_grad(): compares = torch.argmax(outputs, dim=1) == targets accuracy = torch.mean(compares.type(torch.float32)).item() print(f\u0026#39;{epoch}:{step}, loss={loss.item()}, accuracy={accuracy}\u0026#39;) 我们在每一轮训练开始前将模型设置为训练模式: mlp = mlp.train()； 运行代码outputs = mlp(inputs)进行正向传播； 使用交叉熵损失评估函数F.cross_entropy计算损失率； 在进行反向传播loss.backward()前，我们需要调用优化器清除原宥的梯度optimizer.zero_grad()。在执行反向传播后我们调用optimizer.step()进行参数更新； 我们每隔100步打印输出一下损失率loss以及准确率accuracy。 接下来我们看到测试部分:\nprint(\u0026#39;testing...\u0026#39;) mlp = mlp.eval() losses = [] count = 0 with torch.no_grad(): for step, (inputs, targets) in enumerate(test_loader): outputs = mlp(inputs) loss = F.cross_entropy(outputs, targets) losses.append(loss.item()) compares = torch.argmax(outputs, dim=1) == targets count += torch.sum(compares.type(torch.long)).item() loss = sum(losses) / len(losses) accuracy = count / len(test_set) print(f\u0026#39;loss={loss}, accuracy={accuracy}\u0026#39;) 我们先将模型转变为推理模式: mlp = mlp.eval()； 由于整个测试过程我们都不进行梯度计算，所以整个测试过程都可以放在with torch.no_grad():语句结构内进行； 我们将每一次迭代中模型计算的损失率以及预测正确的图像数量分别存储到losses与count； 在for循环结束后，我们计算一下平均的损失率以及准确率然后打印输出。 我们一共完成了10轮训练，其中每一轮训练都会完整的使用所有训练集训练模型一次，并使用完整的测试集测试模型一次。\n通过10轮的训练，我们的模型在测试集上的表现如下:\ntesting... loss=1.4986492108695115, accuracy=0.9661 其中损失率loss为1.49865左右，准确率达到96.61%。\n保存训练后的模型 在完成所有的训练与测试任务后，我们就可以将模型保存到磁盘，以便在未来直接使用:\ntorch.save(mlp, \u0026#39;mlp.pt\u0026#39;) mlp = torch.load(\u0026#39;mlp.pt\u0026#39;) print(mlp) 使用函数torch.save保存模型为本地文件；使用函数torch.load加载本地磁盘中的模型文件。\n完整代码 import torch torch.manual_seed(3) import torch.nn as nn import torch.nn.functional as F from torchvision.datasets import MNIST from torchvision.transforms import ToTensor from torch.utils.data import DataLoader train_set = MNIST(\u0026#39;.\u0026#39;, train=True, download=False, transform=ToTensor()) test_set = MNIST(\u0026#39;.\u0026#39;, train=False, download=False, transform=ToTensor()) train_loader = DataLoader(train_set, batch_size=128, shuffle=True) test_loader = DataLoader(test_set, batch_size=128, shuffle=False) mlp = nn.Sequential( nn.Flatten(), nn.Linear(28 * 28 * 1, 256), nn.Sigmoid(), nn.Linear(256, 10), nn.Softmax(dim=1)) optimizer = torch.optim.Adam(mlp.parameters(), lr=0.001) for epoch in range(0): print(\u0026#39;training...\u0026#39;) mlp = mlp.train() for step, (inputs, targets) in enumerate(train_loader): outputs = mlp(inputs) loss = F.cross_entropy(outputs, targets) optimizer.zero_grad() loss.backward() optimizer.step() if step % 100 == 0: with torch.no_grad(): compares = torch.argmax(outputs, dim=1) == targets accuracy = torch.mean(compares.type(torch.float32)).item() print(f\u0026#39;{epoch}:{step}, loss={loss.item()}, accuracy={accuracy}\u0026#39;) print(\u0026#39;testing...\u0026#39;) mlp = mlp.eval() losses = [] count = 0 with torch.no_grad(): for step, (inputs, targets) in enumerate(test_loader): outputs = mlp(inputs) loss = F.cross_entropy(outputs, targets) losses.append(loss.item()) compares = torch.argmax(outputs, dim=1) == targets count += torch.sum(compares.type(torch.long)).item() loss = sum(losses) / len(losses) accuracy = count / len(test_set) print(f\u0026#39;loss={loss}, accuracy={accuracy}\u0026#39;) torch.save(mlp, \u0026#39;mlp.pt\u0026#39;) mlp = torch.load(\u0026#39;mlp.pt\u0026#39;) print(mlp) 下篇 人工神经网络・ReLU激活函数\n"
            }
    
        ,
            {
                "id": 25,
                "href": "https://bxtkezhan.github.io/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Csoftmax%E5%A4%9A%E5%88%86%E7%B1%BB/",
                "title": "人工神经网络・Softmax多分类",
                "section": "posts",
                "date" : "2022.09.29",
                "body": "返回教程主页\n上篇 人工神经网络・逻辑回归\n逻辑回归常用于处理二分类问题的，虽然也可以通过〚联合〛的方式处理多分类问题「有超过两个以上的类别」但这样比较麻烦。在处理多分类问题的时候我们可以使用softmax替代逻辑回归里的sigmoid激活函数，这样可以实现多分类操作。\nSoftmax函数 我们简单介绍一下Softmax函数，它的数学公式如下:\n$$ \\begin{align} y_i = \\frac{e^{x_i}}{\\sum_{j=1}^{n}e^{x_j}} \\end{align} $$\n当我们有一个数据 $x = \\begin{bmatrix}x_1 \u0026amp; x_2 \u0026amp; x_3\\end{bmatrix}$ 输入到softmax，它会输出的 $y$ 值将如下:\n$$ y = \\begin{bmatrix}y_1 \u0026amp; y_2 \u0026amp; y_3\\end{bmatrix} \\ \\Leftrightarrow\\ \\left\\{ \\begin{align} y_1 = \\frac{e^{x_1}}{\\sum_{j=1}^{n}e^{x_j}} \\\\ y_2 = \\frac{e^{x_2}}{\\sum_{j=1}^{n}e^{x_j}} \\\\ y_3 = \\frac{e^{x_3}}{\\sum_{j=1}^{n}e^{x_j}} \\\\ \\end{align} \\right. $$\n我们用一个具体的数值来演示一下，假设输入数据如下:\n$$ x = \\begin{bmatrix}0 \u0026amp; 1 \u0026amp; 2\\end{bmatrix} $$\n于是计算过程如下:\n$$ \\begin{align} \\sum_{j=1}^{3}e^{x_j} \u0026amp;= e^0 + e^1 + e^2 \\\\ \u0026amp;= 1 + 2.71828183 + 7.3890561 \\\\ \u0026amp;= 11.107337927389695 \\\\ y_1 \u0026amp;= \\frac{e^{x_1}}{\\sum_{j=1}^{3}e^{x_j}} = 0.09003057 \\\\ y_2 \u0026amp;= \\frac{e^{x_2}}{\\sum_{j=1}^{3}e^{x_j}} = 0.24472847 \\\\ y_3 \u0026amp;= \\frac{e^{x_3}}{\\sum_{j=1}^{3}e^{x_j}} = 0.66524096 \\\\ \\end{align} $$\n最终输出y为:\n$$ y = \\begin{bmatrix}0.09003057 \u0026amp; 0.24472847 \u0026amp; 0.66524096\\end{bmatrix} $$\ny的每一个元素的值会落在0到1之间，并且将y的每一个元素值相加会得到数值1，因此softmax的输出常常用于代表各个类别的概率，例如当第一个元素的值为0.09003057时代表有9.003057%的可能性为第一个类别；第二个元素的值为0.24472847代表有24.472847%的可能性为第二个类别……以此类推。\n引入所需的模块 import matplotlib.pyplot as plt import torch torch.manual_seed(7) import torch.nn.functional as F torch.manual_seed(7)将pytorch的随机生成器的种子固定在7，这样可以让每一次运行的结果相同。\n由于我们需要绘制图像，所以除了引入pytorch我们还引入了matplotlib；torch.nn.functional包含pytorch中大量的神经网络相关的函数，我们将用到它。\n构建输入输出 我们随机产生一个10x5的矩阵X作为输入，它的每一行为一个数据点，共计10个数据点。\n除此之外，我们还创建了一个索引index，它的生成方法是: 将矩阵X与另一个5x3的随机矩阵相乘得到一个10x3的新矩阵，然后取这个新矩阵中每一行的最大值元素的下标。\nX = torch.randn((10, 5), dtype=torch.float32) index = torch.argmax(X @ torch.randn((5, 3), dtype=torch.float32), dim=1) print(\u0026#39;index:\u0026#39;) print(index) 我们还需要使用one-hot函数将索引index进行转换，让它变成一个元素值为0或1的10x3矩阵，该矩阵的每一行只有一个1，并且第n行中值为1的元素的下标等于索引index第n行的元素值，即有: T[n, index[n]]的值为1:\nT = F.one_hot(index, 3).type(torch.float32) print(\u0026#39;one hot:\u0026#39;) print(T) 设置需要拟合的参数 由于我们的输出是个nx3的矩阵所以权重W的维度是5x3，偏置b的维度是3:\nW = torch.ones((5, 3), dtype=torch.float32, requires_grad=True) b = torch.zeros((3, ), dtype=torch.float32, requires_grad=True) 正向传播 在一个for循环中执行正向传播代码:\nsteps = 100 losses = [] print(\u0026#39;training...\u0026#39;) for step in range(steps): A = X @ W + b P = torch.softmax(A, dim=1) loss = F.cross_entropy(P, T) losses.append(loss.item()) i = step + 1 if i % 10 == 0: print(f\u0026#39;step: {i}/{steps}, loss={losses[-1]}\u0026#39;) torch.softmax(A, dim=1)调用softmax激活函数需要指定维度dim=1这是因为矩阵A的每一行对应一个数据点，我们需要单独给每一行进行softmax。由于使用的是softmax激活函数，因此我们的损失函数需要采用交叉熵损失函数即F.cross_entropy，该函数的第一个参数为softmax的输出，第二个参数为正确的分类标识。\n我们使用列表losses存储每一轮的损失值loss.item()，并每10个循环打印输出一次。\n反向传播 调用loss.backward()进行反向传播用以求解W与b的梯度，然后在不计算梯度的模式下进行更新:\nloss.backward() lr = 0.1 with torch.no_grad(): W -= lr * W.grad b -= lr * b.grad W.grad.data.zero_() b.grad.data.zero_() 查看拟合效果 打印输出矩阵P，矩阵P的每一行的数值处于0到1之间，代表改行所对应的数据点在某个类别上的概率。例如: P的第0行的0个元素为0.2115则表示第0个数据点属于第0个类别的概率为21.15%，我们可以调用torch.argmax(P, dim=1)将矩阵P转换成类似index的索引向量:\nprint(\u0026#39;probabilities:\u0026#39;) print(P.detach()) print(\u0026#39;true:\u0026#39;, index) with torch.no_grad(): print(\u0026#39;pred:\u0026#39;, torch.argmax(P, dim=1)) 运行后输出:\nprobabilities: tensor([[0.2115, 0.7491, 0.0394], [0.1779, 0.0743, 0.7478], [0.2192, 0.4239, 0.3569], [0.0591, 0.0165, 0.9244], [0.0901, 0.7963, 0.1136], [0.9610, 0.0273, 0.0117], [0.7126, 0.1436, 0.1438], [0.9565, 0.0049, 0.0386], [0.9441, 0.0457, 0.0102], [0.1677, 0.4086, 0.4237]]) true: tensor([1, 2, 1, 2, 1, 0, 0, 0, 0, 2]) pred: tensor([1, 2, 1, 2, 1, 0, 0, 0, 0, 2]) 绘制拟合过程中的损失率 最后我们还可以可视化一下拟合过程中损失率的变化:\nplt.xlabel(\u0026#39;Step\u0026#39;) plt.ylabel(\u0026#39;CrossEntropyLoss\u0026#39;) plt.plot(range(len(losses)), losses, \u0026#39;-\u0026#39;) plt.show() 完整代码 import matplotlib.pyplot as plt import torch torch.manual_seed(7) import torch.nn.functional as F X = torch.randn((10, 5), dtype=torch.float32) index = torch.argmax(X @ torch.randn((5, 3), dtype=torch.float32), dim=1) print(\u0026#39;index:\u0026#39;) print(index) T = F.one_hot(index, 3).type(torch.float32) print(\u0026#39;one hot:\u0026#39;) print(T) W = torch.ones((5, 3), dtype=torch.float32, requires_grad=True) b = torch.zeros((3, ), dtype=torch.float32, requires_grad=True) steps = 100 losses = [] print(\u0026#39;training...\u0026#39;) for step in range(steps): A = X @ W + b P = torch.softmax(A, dim=1) loss = F.cross_entropy(P, T) losses.append(loss.item()) i = step + 1 if i % 10 == 0: print(f\u0026#39;step: {i}/{steps}, loss={losses[-1]}\u0026#39;) loss.backward() lr = 0.1 with torch.no_grad(): W -= lr * W.grad b -= lr * b.grad W.grad.data.zero_() b.grad.data.zero_() print(\u0026#39;probabilities:\u0026#39;) print(P.detach()) print(\u0026#39;true:\u0026#39;, index) with torch.no_grad(): print(\u0026#39;pred:\u0026#39;, torch.argmax(P, dim=1)) plt.xlabel(\u0026#39;Step\u0026#39;) plt.ylabel(\u0026#39;CrossEntropyLoss\u0026#39;) plt.plot(range(len(losses)), losses, \u0026#39;-\u0026#39;) plt.show() 下篇 人工神经网络・多层感知器\n"
            }
    
        ,
            {
                "id": 26,
                "href": "https://bxtkezhan.github.io/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/",
                "title": "人工神经网络・逻辑回归",
                "section": "posts",
                "date" : "2022.09.26",
                "body": "返回教程主页\n上篇 人工神经网络・操作环境准备\n先前我们在最小二乘拟合那一节中了解到如何使用最小二乘的方法拟合多项式方程，那么今天我们再来学习一种「拟合」方程的方法——逻辑回归。\n我们要处理的问题是这样的:\n需要一个方程能够检测两位的二进制数字「包括 00 01 10 11」是否为奇数，当输入为奇数时方程输出1，输入为偶数时方程输出0。\n上述方程接收输入并输出类似逻辑电路中高低电平信号的0，1值，很容易让人联想到使用逻辑回归方法去求解。因此，接下来我们就尝试使用逻辑回归进行求解。\n定义函数 我们的方程表达式如下:\n$$ y = \\sigma(XW + b) $$\n其中X为方程输入，y为方程输出。W与b为方程的参数，具体数值需要经过拟合求得。\n方程的输入X为二进制数转换成的矩阵，二进制数与矩阵的对应关系如下:\n$$ \\begin{align} 00 \\rightarrow \\begin{bmatrix} 0 \u0026amp; 0 \\end{bmatrix} \\\\ 01 \\rightarrow \\begin{bmatrix} 0 \u0026amp; 1 \\end{bmatrix} \\\\ 10 \\rightarrow \\begin{bmatrix} 1 \u0026amp; 0 \\end{bmatrix} \\\\ 11 \\rightarrow \\begin{bmatrix} 1 \u0026amp; 1 \\end{bmatrix} \\\\ \\end{align} $$\n参数W是个2x1的矩阵: $W = \\begin{bmatrix}w_1 \\\\ w_2 \\end{bmatrix}$；参数b则为一个标量。\n函数$\\sigma(x)$为著名的sigmoid函数:\n$$\\sigma(x) = \\frac{1}{1 + e^{-x}}$$\n从函数图可以看出该函数的输出会落在0与1之间，并且在输入大于0的时候函数输出会快速趋近1，输入小于0的时候函数输出则会快速趋近0。\n优化学习 为了求解具体的参数数值，我们可以先预设参数，然后对参数进行优化更新，使其变成符合我们期望的参数。\n在对参数进行优化前，我们还得设计一个方案去评估参数的效果，如果不知道当前参数的效果我们是无法顺利地对参数进行优化的。\n一般来说逻辑回归可以使用 梯度下降算法 进行参数优化，而该算法应用在逻辑回归时也有常用的参数评估函数「或称 损失函数」:\n$$ loss = \\sum_{i=1}^n\\frac{1}{2}(t_i - p_i)^2 $$\n在上述方程中$t_i$为第i个真实输出「或者说是预期中的函数输出」，而$p_i$则是与之对应的当前函数给出的输出。\n假设X为输入，期望中的函数为$f_t$，当前函数为$f_p$，那么t与p的对应关系大致如下:\n$$ \\begin{pmatrix} t_1 \\leftrightarrow p_1 \\\\ t_2 \\leftrightarrow p_2 \\\\ t_3 \\leftrightarrow p_3 \\\\ t_4 \\leftrightarrow p_4 \\\\ \\end{pmatrix} \\left\\{ \\begin{align} \\begin{bmatrix} t_1 \\\\ t_2 \\\\ t_3 \\\\ t_4 \\end{bmatrix} = T \u0026amp; = f_t(X) \\\\ \\begin{bmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{bmatrix} = P \u0026amp; = f_p(X) \\\\ \\end{align} \\right. \\quad , \\quad X = \\begin{bmatrix} 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\\\ 1 \u0026amp; 1 \\end{bmatrix} $$\n在计算完损失函数值后，我们就对损失函数求参数$\\{W,b\\}$的梯度$\\{\\Delta W,\\Delta b\\}$，然后用当前的参数分别减去各自的梯度用以得到更新后的参数:\n$$ W_t = W_{t-1} - \\lambda \\Delta W \\ ; \\ b_t = b_{t-1} - \\lambda \\Delta b $$\n通常在使用梯度进行参数更新的时候我们不希望使用全部的梯度，这样会使得数值跨度太大，因此我们通常会将梯度乘上一个小于1的正数$\\lambda$，很多地方称$\\lambda$为学习率「learning rate」。\n了解了这些后我们开始编写代码。\n准备输入输出 在确保安装了pytorch后我们在代码中引入它:\nimport torch torch.tensor类似numpy中的numpy.array，我们可以使用它创建张量「包括标量，向量，矩阵……」。在这里，我们使用张量存储方程的输入X与输出T。X为4x2的矩阵而T为4x1的矩阵，它们的每一行按顺序互相对应:\nX = torch.tensor([ [0, 0], [0, 1], [1, 0], [1, 1] ], dtype=torch.float32) T = torch.tensor([ [0], [1], [0], [1] ], dtype=torch.float32) 这里需要注意的是我们大多数情况会使用32位的浮点数值torch.float32，这样做既能满足精度的需要又避免过多的运算。\n准备需要拟合的参数 公式 $y = \\sigma(XW + b)$ 中的W「常常称作权重Weights」与b「常常称作偏置bias」是我们需要拟合的参数:\nW = torch.ones((2, 1), dtype=torch.float32, requires_grad=True) b = torch.zeros((1, ), dtype=torch.float32, requires_grad=True) 我们将权重初始化为元素都是1的矩阵，而偏置则初始化为0。另外，由于我们需要求解权重和偏置的梯度，所以我们需要设置参数requires_grad=True。\n正向传播 我们在一个for循环中编写正向传播的代码:\nfor step in range(100): # forward A = X @ W H = A + b P = torch.sigmoid(H) 代码是根据公式 $y = \\sigma(XW + b)$ 编写的，经由sigmoid函数处理后的输出P就对应公式中的输出y。\n计算损失函数 我们根据如下公式编写损失函数:\n$$ loss = \\sum_{i=1}^n\\frac{1}{2}(t_i - p_i)^2 $$\nloss = torch.sum(0.5 * (T - P)**2) print(\u0026#39;step:\u0026#39;, step, \u0026#39;loss =\u0026#39;, loss.item()) 反向传播 调用loss.backward方法，对支持梯度求解的张量对象loss进行梯度求解:\n# backward loss.backward() 在执行完反向传播操作后，我们可以得到权重的梯度W.grad以及偏置的梯度b.grad。\n更新梯度 由于我们使用的是梯度下降优化方案所以在更新权重和偏置的时候需要减去梯度。但是如果直接减去梯度则可能步长过大，所以通常会将梯度乘上一个小于1大于0的值lr，然后用当前权重减去它，正如下方那样:\nlr = 0.1 with torch.no_grad(): W -= W.grad * lr b -= b.grad * lr W.grad.data.zero_() b.grad.data.zero_() 在pytorch中，更新带有梯度的参数时，我们需要在不计算梯度的模式下with torch.no_grad():进行；而在更新梯度后，我们需要使用tensor.grad.data.zero_()方法清零当前的梯度。\n查看拟合后的参数 完成100轮上述的权重与偏置的更新后我们打印输出一下权重和偏置:\nprint(\u0026#39;params weight:\u0026#39;) print(W.detach()) print(\u0026#39;params bias:\u0026#39;) print(b.detach()) tensor.detach()方法用于将普通tensor从带梯度的tensor中分离，此处使用仅为了打印输出的美观。\n测试拟合效果 我们在不计算梯度的模式下测试一下拟合后的方程。在这里我们使用pytorch张量对象的列表索引X[[0, 2, 1, 3]]改变了一下矩阵X的行顺序，那么对应的输出P则应该趋近于$\\begin{bmatrix}0 \\\\ 0 \\\\ 1 \\\\ 1\\end{bmatrix}$:\nwith torch.no_grad(): A = X[[0, 2, 1, 3]] @ W H = A + b P = torch.sigmoid(H) print(\u0026#39;predict:\u0026#39;) print(P) 运行后输出:\npredict: tensor([[0.2789], [0.3257], [0.7348], [0.7759]]) 我们发现输出的头两行元素小于0.5趋近0，后两行元素大于0.5趋近1，基本符合我们的预期，这时我们可以使用torch.round进行四舍五入将其严格转换为$\\begin{bmatrix}0 \\\\ 0 \\\\ 1 \\\\ 1\\end{bmatrix}$的结构:\nprint(torch.round(P)) 运行后输出:\ntensor([[0.], [0.], [1.], [1.]]) 完整代码 import torch X = torch.tensor([ [0, 0], [0, 1], [1, 0], [1, 1] ], dtype=torch.float32) T = torch.tensor([ [0], [1], [0], [1] ], dtype=torch.float32) W = torch.ones((2, 1), dtype=torch.float32, requires_grad=True) b = torch.zeros((1, ), dtype=torch.float32, requires_grad=True) for step in range(100): # forward A = X @ W H = A + b P = torch.sigmoid(H) loss = torch.sum(0.5 * (T - P)**2) print(\u0026#39;step:\u0026#39;, step, \u0026#39;loss =\u0026#39;, loss.item()) # backward loss.backward() lr = 0.1 with torch.no_grad(): W -= W.grad * lr b -= b.grad * lr W.grad.data.zero_() b.grad.data.zero_() print(\u0026#39;params weight:\u0026#39;) print(W.detach()) print(\u0026#39;params bias:\u0026#39;) print(b.detach()) with torch.no_grad(): A = X[[0, 2, 1, 3]] @ W H = A + b P = torch.sigmoid(H) print(\u0026#39;predict:\u0026#39;) print(P) print(torch.round(P)) 下篇 人工神经网络・Softmax多分类\n"
            }
    
        ,
            {
                "id": 27,
                "href": "https://bxtkezhan.github.io/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/",
                "title": "人工神经网络・操作环境准备",
                "section": "posts",
                "date" : "2022.09.23",
                "body": "返回教程主页\n上篇 数据分析・聚类分析\n本章介绍一些人工神经网络开发的技术，下面列出本章节会使用的一些依赖库。\nnumpy numpy是著名的Python数值计算库，许多的数据计算操作都依赖它实现。使用pip就能完成下载安装，命令如下:\npip install numpy matplotlib 常用的Python绘图工具，方便进行数据可视化工作。pip的安装指令如下:\npip install matplotlib Pillow Pillow是Python编程语言中免费、开源的第三方图像处理库，支持对许多不同图像文件格式的打开、编辑和保存等操作。\nPillow的pip安装指令如下:\npip install Pillow PyTorch PyTorch是一个源自Torch库的开源机器学习框架，用于计算机视觉和自然语言处理等应用程序的开发。\nPyTorch在linux下的cpu版本安装方式:\npip3 install torch torchvision --extra-index-url https://download.pytorch.org/whl/cpu PyTorch在windows下的cpu版本安装方式:\npip3 install torch torchvision PyTorch在mac下的cpu版本安装方式:\npip3 install torch torchvision 如果你想安装其它版本的PytTorch可以参看官方网站给出的建议:\nhttps://pytorch.org/get-started/locally/\n下篇 人工神经网络・逻辑回归\n"
            }
    
        ,
            {
                "id": 28,
                "href": "https://bxtkezhan.github.io/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/",
                "title": "数据分析・聚类分析",
                "section": "posts",
                "date" : "2022.09.20",
                "body": "返回教程主页\n上篇 数据分析・最小二乘拟合\n上一节中介绍了最小二乘法，本节将介绍另一个数据分析方法——聚类分析。该方法常用于处理具备几何特征关系的数据点，我们以最基础的k均值聚类为例进行说明。\nk均值聚类「kmeans」 k均值聚类通俗来说就是将n个数据点按照一定规则分配到k个族群，要求每个数据点距离所在族群的均值点比较近而距离其它族群的均值点比较远。\n如上图，有两个颜色不同的族群，这两个族群的均值点都用红色的x进行了标记。可以看出各个族群的点都是距离自己族群的均值点比较近而距离其它族群的均值点比较远。\nk均值算法步骤 注意: 这里给出的是k均值聚类的一种实现方案，如果你在其它地方看到其它方法请不要觉得奇怪。\n从样本点中随机选出k个样本点作为k个均值点，而每个均值点拥有一个对应的族群； 将均值点以外的其它样本点与这k个均值点做距离评估，将样本点分配给距离较近的均值点所对应的族群； 为每个族群重新计算一个均值点； 重复「步骤2」到「步骤3」的过程，直到累计重复了某个次数或者各个均值点变更的幅度减小到了某个程度； 代码实现・数据准备 首先我们构造一下数据点:\nimport matplotlib.pyplot as plt import numpy as np pts = np.random.randn(20, 2) pts[:10] += [0.5, 1] pts[10:] += [5, 10] 我们随机初始了20个标准正态分布的二维座标点pts，然后将前10个点和后10个点的座标分别加上$(0.5, 1)$，$(5, 10)$使这两组数据点的均值分别趋近于$(0.5, 1)$，$(5, 10)$「当然，我们并不会把均值点调整的这个信息告诉后面的k均值算法」。\n我们用numpy.random.permutation生成一个随机索引序列用来打乱原本pts中的顺序，算是给实验增加一点点挑战:\nidx = np.random.permutation(len(pts)) pts = pts[idx] 代码实现・步骤一 def kmeans_step1(k=2): centroids = pts[np.random.choice(len(pts), k, replace=False)] return centroids 使用numpy.random.choice生成k个不重复的索引下标，参数设定replace=False确保不重复。\n代码实现・步骤二 def kmeans_step2(centroids): clusters = {i: [] for i in range(len(centroids))} for point in pts: c_id = np.argmin(np.sum((centroids - point)**2, axis=1)) clusters[c_id].append(point) return clusters 我们使用迭代的方法遍历每一个点，用各个点同均值点centroids做欧氏几何距离评估来判断当前点point属于哪一个族群cluster。\n欧氏几何距离计算的公式为 $d(p,q) = \\sqrt{\\sum_{i=1}^{n} (p_i - q_i)^2}$，由于我们只需要获取极小值所以不必计算最外层的开方，于是有 $\\hat{d}(p,q) = \\sum_{i=1}^{n} (p_i - q_i)^2$，代码的表现形式如下:\nc_id = np.argmin(np.sum((centroids - point)**2, axis=1)) 函数numpy.argmin取出数组最小值所在的下标。\n代码实现・步骤三 def kmeans_step3(clusters): centroids = np.zeros((len(clusters), 2)) for i, c_pts in clusters.items(): centroids[i] = sum(c_pts) / len(c_pts) return centroids 在步骤三的函数中我们将每一个族群的数据点相加然后除以族群中数据点的数目，这样得到的均值会作为新的均值点。\n代码实现・算法总成 最后，我们来看一下所有步骤的执行过程:\n# 步骤一 k = 2 centroids = kmeans_step1(k) print(centroids) # 重复3次「步骤二，步骤三」 for i in range(3): # 步骤二 clusters = kmeans_step2(centroids) # 步骤三 centroids = kmeans_step3(clusters) print(centroids) 如果愿意我们也可以绘制出最终的结果:\nplt.plot(pts[:, 0], pts[:, 1], \u0026#39;o\u0026#39;, centroids[:, 0], centroids[:, 1], \u0026#39;x\u0026#39;) plt.show() 下篇 人工神经网络・操作环境准备\n"
            }
    
        ,
            {
                "id": 29,
                "href": "https://bxtkezhan.github.io/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%8B%9F%E5%90%88/",
                "title": "数据分析・最小二乘拟合",
                "section": "posts",
                "date" : "2022.09.20",
                "body": "返回教程主页\n上篇 数据分析・矩阵操作\n下面我们使用最小二乘拟合的方法去拟合一系列的数据点，该操作常用于在一组数据点中窥见变化趋势。\n构造数据集 我们先在 $[-5, 5]$ 范围内容对函数 $y = x^2 + 2x$ 进行均匀随机采样，获得100个数据点:\nimport matplotlib.pyplot as plt import numpy as np x = 5 * (2 * np.random.random((100,)) - 1) print(x.max(), x.min()) x = np.sort(x) y = x**2 + 2 * x x为该组数据点的横座标值，y为对应的纵座标值。\n我们给该组数据添加一点随机扰动，让它至少不完全落在函数 $y = x^2 + 2x$ 上:\ny += 5 * (2 * np.random.random(y.shape) - 1) 可以使用matplotlib可视化一下:\nplt.plot(x, y) plt.show() 至此，我们得到了一系列数据点。当然，如果手头正好有适合的数据也可以考虑用它来替代刚刚生成的数据点。\n拟合多项式 现在我们构造数据集，然后用将这些点拟合成一个二次多项式: $y = ax^2 + bx$，我们需要求解系数a与b的值。\n$$ \\begin{align} y = ax^2 + bx \\tag 1 \\\\ 式(1)的矩阵形式 \\Rightarrow y = \\begin{bmatrix} x\u0026amp;x^2 \\end{bmatrix} \\begin{bmatrix} b \\\\ a \\end{bmatrix} \\tag 2 \\\\ 令A = \\begin{bmatrix} x\u0026amp;x^2 \\end{bmatrix} , \\hat{c} = \\begin{bmatrix} b \\\\ a \\end{bmatrix} \\Rightarrow y = A\\hat{c} \\tag 3 \\end{align} $$\n首先我们构造由$x^2$与$x$组成的矩阵$A$:\nA = np.concatenate([x, x**2]).reshape(2, -1).T 矩阵$A$的第0列为$x$，第1列为$x^2$。\n我们使用公式 $(A^TA)^{-1}A^Ty = \\hat{c}$ 求解系数 $\\hat{c} = \\begin{vmatrix} b \\\\ a \\end{vmatrix}$:\nb, a = np.linalg.inv(A.T @ A) @ A.T @ y print(a, b) Note: 此处的$(A^TA)^{-1}$指的是求$A^TA$的逆矩阵，可用numpy的linalg.inv函数计算；另外由于使用的是numpy数组对象所以需要使用运算符@执行矩阵乘法。\n现在我们可以使用系数a与b重新生成对应的纵座标_y，并进行可视化:\n_y = a * x**2 + b * x plt.plot(x, y, \u0026#39;o\u0026#39;, x, _y, \u0026#39;-\u0026#39;) plt.show() 下篇 数据分析・聚类分析\n"
            }
    
        ,
            {
                "id": 30,
                "href": "https://bxtkezhan.github.io/jitlightning-%E7%A4%BA%E4%BE%8Bprintf/",
                "title": "JIT・Lightning 示例「printf」",
                "section": "posts",
                "date" : "2022.09.12",
                "body": "在了解lightning的基本使用方式后，我们再来了解如何在lightning中调用c函数。\n我们以调用c程序中的printf函数为例，这里先列出完整代码:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;lightning.h\u0026gt; static jit_state_t *_jit; typedef void (*pvfi)(int); /* Pointer to Void Function of Int */ int main(int argc, char *argv[]) { pvfi myFunction; /* ptr to generated code */ jit_node_t *start, *end; /* a couple of labels */ jit_node_t *in; /* to get the argument */ init_jit(argv[0]); _jit = jit_new_state(); start = jit_note(__FILE__, __LINE__); jit_prolog(); in = jit_arg(); jit_getarg(JIT_R1, in); jit_prepare(); jit_pushargi((jit_word_t)\u0026#34;generated %d bytes\\n\u0026#34;); jit_ellipsis(); jit_pushargr(JIT_R1); jit_finishi(printf); jit_ret(); jit_epilog(); end = jit_note(__FILE__, __LINE__); myFunction = jit_emit(); /* call the generated code, passing its size as argument */ myFunction((char*)jit_address(end) - (char*)jit_address(start)); jit_clear_state(); jit_disassemble(); jit_destroy_state(); finish_jit(); return 0; } 标记注释 start = jit_note(__FILE__, __LINE__); /* ... ... */ end = jit_note(__FILE__, __LINE__); 这两条指令调用了jit_note宏，它在jit代码中创建了一个注释；jit_note的参数通常是文件名字符串和行号整数，但如果只需要在代码中创建一个简单的标记，则使用NULL作为字符串参数是完全有效的。\n处理可变参量 jit_ellipsis(); 由于函数printf是个可变参函数，所以需要调用jit_ellipsis()。\n字符串参数处理 jit_pushargi((jit_word_t)\u0026#34;generated %d bytes\\n\u0026#34;); 使用jit_word_t做字符串参数的类型转换。\n引入并调用c函数 jit_prepare(); /* ... ...*/ jit_finishi(printf); 在jit中调用printf函数，需要在装填参数前先执行jit_prepare()函数，在完成参数装填后需要执行jit_finishi(printf)。\n显式的写入结语 jit_epilog(); lightning可以自己处理代码段截止内容，但是有的时候为了能准确的标记代码段的地址需要我们调用jit_epilog()来显式的处理。\n通过调用函数执行jit代码 myFunction((char*)jit_address(end) - (char*)jit_address(start)); jit_clear_state(); 调用jit_address获取字节地址需要使用到jit state中的信息，因此应当放在jit_clear_state()前执行。\n标准输出 jit_disassemble(); disassemble会将生成的代码转储到标准输出，除非lightning是在禁用反汇编程序的情况下构建的，在这种情况下不会显示任何输出。\n"
            }
    
        ,
            {
                "id": 31,
                "href": "https://bxtkezhan.github.io/jitlightning-%E7%A4%BA%E4%BE%8Bincr/",
                "title": "JIT・Lightning 示例「incr」",
                "section": "posts",
                "date" : "2022.09.06",
                "body": "在上一篇文章中我们简单地介绍了一下GNU/Lightning，现在我们来讲解上一篇文章中测试用的示例。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;lightning.h\u0026gt; static jit_state_t *_jit; typedef int (*pifi)(int); /* Pointer to Int Function of Int */ int main(int argc, char *argv[]) { jit_node_t *in; pifi incr; init_jit(argv[0]); _jit = jit_new_state(); jit_prolog(); /* prolog */ in = jit_arg(); /* in = arg */ jit_getarg(JIT_R0, in); /* getarg R0 */ jit_addi(JIT_R0, JIT_R0, 1); /* addi R0, R0, 1 */ jit_retr(JIT_R0); /* retr R0 */ incr = jit_emit(); jit_clear_state(); /* call the generated code, passing 5 as an argument */ printf(\u0026#34;%d + 1 = %d\\n\u0026#34;, 5, incr(5)); jit_destroy_state(); finish_jit(); return 0; } 引入头文件 #include \u0026lt;lightning.h\u0026gt; 想要成功使用lightning中的一系列函数与变量，我们需要引入头文件lightning.h。\n声明jit_state_t结构指针 static jit_state_t *_jit; jit_state_t结构用于存储jit代码声明信息，_jit这个变量名在lightning中有特殊意义，所以通常情况下我们应该直接使用_jit，或者用#define _jit \u0026lt;其它名称\u0026gt;来定义。\n定义一个函数类型 typedef int (*pifi)(int); 为了方便我们后续使用jit生成的函数，我们定义一个函数类型与之对应。该类型的函数接收一个int整型返回一个int整型。\n声明一个变量用来获取函数参数 jit_node_t *in; 使用jit_node_t声明的指针in可以用于在jit代码中获取函数的变量。\n声明函数指针变量 pifi incr; 全局初始化jit init_jit(argv[0]); 必须在创建jit_state_t对象之前调用此函数。该函数会进行全局状态初始化，可能需要检测CPU或操作系统特性。如果在配置时启用了反汇编，它会接收一个字符串参数，该参数稍后用于使用GNU binutils从共享对象中读取符号。如果不执行反汇编，则可以使用NULL指针作为参数。\n创建state _jit = jit_new_state(); 准备书写jit代码 jit_prolog(); 在此函数调用后我们就可以开始书写jit代码了。\n获取函数输入 in = jit_arg(); jit_getarg(JIT_R0, in); 使用in = jit_arg()从函数中获取参数「这里说的函数当前还没有实现，等到相关的代码书写完后会将这个函数赋值给incr」；调用jit_getarg函数将得到的参数in的值传递给寄存器JIT_R0。\n实现加一操作 jit_addi(JIT_R0, JIT_R0, 1); jit_addi可实现寄存器整数相加赋值的操作，将第2、3个参数的寄存器值或数值相加并赋值给第1个参数的寄存器。\n返回寄存器的值 jit_retr(JIT_R0); 类似C程序中函数的返回语句return，此处使用jit_retr返回了寄存器JIT_R0的值。\n生成机器码 incr = jit_emit(); 该函数会将之前书写的jit代码转换为机器码，然后封装成一个函数指针，我们使用incr接收它。\n清除state jit_clear_state(); 得到incr函数后我们清理掉state中的一些不必要的内容。\n调用并观察incr printf(\u0026#34;%d + 1 = %d\\n\u0026#34;, 5, incr(5)); 释放内存中的state信息 jit_destroy_state(); 确定不会再使用jit生成的函数后，我们可以释放并销毁内存中的state信息。\n结束jit finish_jit(); 最后我们再清除全局的jit state信息。\n"
            }
    
        ,
            {
                "id": 32,
                "href": "https://bxtkezhan.github.io/jitgnu/lightning/",
                "title": "JIT・GNU/Lightning",
                "section": "posts",
                "date" : "2022.09.01",
                "body": "在之前的文章中我们了解了一点基础的汇编语法以及与C程序的混用技巧，现在我们进一步来学习使用及时编译技巧「JIT」。\n关于JIT的简介「来自 wiki」 在计算机技术中，即时编译（英语：just-in-time compilation，缩写为JIT；又译及时编译、实时编译），也称为动态翻译或运行时编译，是一种执行计算机代码的方法，这种方法涉及在程序执行过程中（在执行期）而不是在执行之前进行编译。通常，这包括源代码或更常见的字节码到机器码的转换，然后直接执行。实现JIT编译器的系统通常会不断地分析正在执行的代码，并确定代码的某些部分，在这些部分中，编译或重新编译所获得的加速将超过编译该代码的开销。\n简单来说就是在其它编程语言中动态生成并编译执行汇编语言。\nGNU/Lightning 我们将使用由GNU提供的工具Lightning实现及时编译，关于Lightning的简介如下:\nGNU Lightning是一个在运行时生成汇编语言代码的库；它非常快，非常适合即时 编译器，并且它在目标 CPU 上进行抽象，因为它向客户端公开了受 MIPS 和 SPARC 芯片启发的标准化 RISC 指令集。 GNU Lightning可用于复杂的代码生成任务。可用的后端涵盖 aarch64、alpha、arm、hppa、ia64、mips、powerpc、risc-v、s390、sparc 和 x86 架构。\n安装Lightning 首先需要下载Lightning，可以去到官方提供的地址http://ftp.gnu.org/gnu/lightning/，下载最新或较新的版本。\n下载之后进行解压，然后进入解压后的目录「例如: ~/Workspace/lightning-2.1.3」:\ncd ~/Workspace/lightning-2.1.3 根据官方文档的安装说明https://www.gnu\u0026hellip;\u0026hellip;#Installation，执行如下命令进行编译:\n# 1. ./configure # 2. make check # 3. make install # 可能需要使用sudo获取权限 安装之后，我们可以运行命令sudo ldconfig刷新一下连接库。\n编译测试官方示例 我们使用官方示例「incr」来测试一下lightning是否成功安装。\n打开编辑器，然后键入如下代码:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;lightning.h\u0026gt; static jit_state_t *_jit; typedef int (*pifi)(int); /* Pointer to Int Function of Int */ int main(int argc, char *argv[]) { jit_node_t *in; pifi incr; init_jit(argv[0]); _jit = jit_new_state(); jit_prolog(); /* prolog */ in = jit_arg(); /* in = arg */ jit_getarg(JIT_R0, in); /* getarg R0 */ jit_addi(JIT_R0, JIT_R0, 1); /* addi R0, R0, 1 */ jit_retr(JIT_R0); /* retr R0 */ incr = jit_emit(); jit_clear_state(); /* call the generated code, passing 5 as an argument */ printf(\u0026#34;%d + 1 = %d\\n\u0026#34;, 5, incr(5)); jit_destroy_state(); finish_jit(); return 0; } 保存代码并进行编译与执行:\ngcc test.c -llightning ./a.out 如果编译成功则执行后输出如下内容:\n5 + 1 = 6 该程序会在执行过程中动态编译一个「数值增一」的子汇编程序并在之后进行调用。关于上述代码的说明与讲解会写在下一篇文章中，感兴趣的朋友们，敬请期待！\n"
            }
    
        ,
            {
                "id": 33,
                "href": "https://bxtkezhan.github.io/arberia-features/",
                "title": "Arberia Features",
                "section": "posts",
                "date" : "2022.07.27",
                "body": "Intro We\u0026rsquo;ll be using toml format for all examples down below, I recommend using toml as it is easier to read.\nYou can find any YML to TOML converters if necessary.\nAssets (js/css) The following is enabled by default\nminification - makes the assets size smallest as possible. bundling - bundles all the styles in one single asset fingerprint/intergity check. Search Page PaperMod uses flexsearch.js for search functionality\nAdd the following to site config, config.toml\n[outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;JSON\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;AMP\u0026#34;] # is necessary page = [\u0026#34;HTML\u0026#34;] section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomyTerm = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] Create a page with search/_index.md in content directory with following content\n--- title: Search subtitle: Search index date: 2022-04-26T21:28:23+02:00 lastmod: 2022-04-27T21:28:23+02:00 draft: false weight: type: search #is necessary layout: \u0026#34;search\u0026#34; #is necessary categories: - search hiddenFromHomePage: true hiddenFromSearch: true resources: - name: featured-image src: \u0026#34;\u0026#34; - name: featured-image-preview src: \u0026#34;\u0026#34; featured: false sidebar: false toc: false math: enable: false lightgallery: false license: \u0026#34;\u0026#34; slug: search --- Draft Page indication adds [draft] mark to indicate draft pages.\nPost Cover Image In post\u0026rsquo;s page-variables add :\nresources: - name: \u0026#34;featured-image\u0026#34; src: \u0026#34;insert image path here\u0026#34; - name: \u0026#34;featured-image-preview\u0026#34; src: \u0026#34;insert image path here\u0026#34; When you include images in the Page Bundle, multiple sizes of the image will automatically be provided using the HTML5 srcset field.\nTo reduce generation time and size of the site, you can disable this feature using\n[params.resources] responsiveImages = false To enable hyperlinks to the full image size on post pages, use\n[params.resources] linkFullImages = true Share Buttons on post Displays Share Buttons at Bottom of each post\nto show share buttons add in config/params.toml\n[social.share] enable = true Show Table of Contents (Toc) on blog post Displays ToC on blog-pages\nTo show ToC add following to page-variables\ntoc: true # Works only with standard-view Comments Enhanced SEO Twitter Cards Support OpenGraph support --- ### Multilingual Support --- ### Misc "
            }
    
        ,
            {
                "id": 34,
                "href": "https://bxtkezhan.github.io/arberia-installation-update/",
                "title": "Arberia Installation | Update",
                "section": "posts",
                "date" : "2022.07.27",
                "body": "Intro We\u0026rsquo;ll be using yml/yaml format for all examples down below, I recommend using yml over toml as it is easier to read. You can find any YML to TOML converters if necessary. Guide Follow Quick Start guide to setup and create a new site.\nNote: Use -f to select yml format\nhugo new site \u0026lt;name of site\u0026gt; -f yml\nMake sure you install latest version of hugo(\u0026gt;=0.101.0).\nAfter you have created a new site, at Step 3 follow the steps:\nMethod 1 Inside the folder of your Hugo site, run:\ngit clone https://github.com/antedoro/Arberia.git themes/arberia --depth=1 Note: You may use --branch v5.0 to end of above command if you want to stick to specific release.\nUpdating theme :\ncd themes/Arberia git pull Method 2 you can use as submodule with\ngit submodule add --depth=1 https://github.com/antedoro/Arberia.git themes/arberia git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) Note: You may use --branch v5.0 to end of above command if you want to stick to specific release.\nUpdating theme :\ngit submodule update --remote --merge Method 3 Or you can Download as Zip from Github Page and extract in your themes directory\nDirect Links: Not defined\nFinally \u0026hellip; Add in config/config.toml:\ntheme: \u0026#34;arberia\u0026#34; Method 4 Install Go programming language in your operating system.\nIntialize your own hugo mod\nhugo mod init YOUR_OWN_GIT_REPOSITORY Add Arberia in your config/config.toml file module: imports: - path: github.com/adityatelange/Arberia Update theme hugo mod get -u Quick Links Papermod - Features Papermod - FAQs Papermod - Variables Papermod - Icons ChangeLog Sample config.toml Example Site Structure is present here: exampleSite\nUse appropriately\ntitle = \u0026#34;Arberia Theme\u0026#34; baseURL = \u0026#34;https://arberiatheme.netlify.app/\u0026#34; relativeURLs = \u0026#34;True\u0026#34; languageCode = \u0026#34;en-us\u0026#34; defaultContentLanguage = \u0026#39;en\u0026#39; theme = \u0026#34;arberia\u0026#34; # To list the most relevant pages on the front page or similar, # you should use the site.Params.mainSections list instead of comparing # section names to hard-coded values like \u0026#34;posts\u0026#34; or \u0026#34;post\u0026#34;. # [params] # mainSections = [\u0026#39;posts\u0026#39;,] [taxonomies] tag = \u0026#34;tags\u0026#34; category = \u0026#34;categories\u0026#34; [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;JSON\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;AMP\u0026#34;] page = [\u0026#34;HTML\u0026#34;] section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomyTerm = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] [markup] [markup.tableOfContents] startLevel = 2 endLevel = 5 ordered = false tocMinWordCount = 100 # Minimum word count to display the Table of Contents [markup.goldmark.renderer] # Controllare cosa faccia unsafe = true [permalinks] posts = \u0026#34;/:title/\u0026#34; [minify] minifyOutput = true enableRobotsTXT= true ############################# Plugins ############################## # CSS Plugins # [[params.plugins.css]] # link = \u0026#34;css/Custom.css\u0026#34; # [[params.plugins.css]] # link = \u0026#34;https://pro.fontawesome.com/releases/v5.10.0/css/all.css\u0026#34; # JS Plugins # [[params.plugins.js]] # link = \u0026#34;js/customJS.js\u0026#34; # Generate favicon with https://realfavicongenerator.net/ # and copy favicon folder (name it facicon) to static/ folder [assets] favicon = \u0026#34;favicon/favicon.ico\u0026#34; favicon16x16 = \u0026#34;favicon/favicon-16x16.png\u0026gt;\u0026#34; favicon32x32 = \u0026#34;favicon/favicon-32x32.png\u0026#34; apple_touch_icon = \u0026#34;favicon/apple-touch-icon.png\u0026#34; safari_pinned_tab = \u0026#34;favicon/safari-pinned-tab.svg\u0026#34; # safari_color = \u0026#34;18354c\u0026#34; # theme_color = \u0026#34;#18354c\u0026#34; # msapplication_TileColor = \u0026#34;#ffc40d\u0026#34; ###################################### # Menu # [[menu.main]] # identifier = \u0026#34;home\u0026#34; # pre = \u0026#34;\u0026#34; # post = \u0026#34;\u0026#34; # name = \u0026#34;Home\u0026#34; # url = \u0026#34;/\u0026#34; # title = \u0026#34;\u0026#34; # weight = 1 [[menu.main]] identifier = \u0026#34;portfolio\u0026#34; pre = \u0026#34;fa fa-drafting-compass\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Portfolio\u0026#34; url = \u0026#34;/portfolio\u0026#34; title = \u0026#34;\u0026#34; weight = 2 [[menu.main]] identifier = \u0026#34;tutorial\u0026#34; pre = \u0026#34;fa fa-graduation-cap\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Tutorial\u0026#34; url = \u0026#34;#\u0026#34; title = \u0026#34;\u0026#34; weight = 3 [[menu.main]] identifier = \u0026#34;list_view\u0026#34; pre = \u0026#34;fa fa-list\u0026#34; post = \u0026#34;Post list view of all posts\u0026#34; name = \u0026#34;List View →\u0026#34; url = \u0026#34;/posts/\u0026#34; title = \u0026#34;\u0026#34; weight = 4 parent = \u0026#34;tutorial\u0026#34; [menu.main.params] color = \u0026#34;#ff7e73\u0026#34; [[menu.main]] identifier = \u0026#34;grid_view\u0026#34; pre = \u0026#34;fa fa-th\u0026#34; post = \u0026#34;Post grid view of all posts\u0026#34; name = \u0026#34;Grid View →\u0026#34; url = \u0026#34;/portfolio/\u0026#34; title = \u0026#34;\u0026#34; weight = 5 parent = \u0026#34;tutorial\u0026#34; [menu.main.params] color = \u0026#34;#abe5b1\u0026#34; [[menu.main]] identifier = \u0026#34;post_view_sidebar\u0026#34; pre = \u0026#34;fa fa-file-text-o\u0026#34; post = \u0026#34;Single post view with sidebar\u0026#34; name = \u0026#34;Single Post View With Sidebar\u0026#34; url = \u0026#34;/post-with-sidebar/\u0026#34; title = \u0026#34;\u0026#34; weight = 6 parent = \u0026#34;tutorial\u0026#34; [menu.main.params] color = \u0026#34;#ffc873\u0026#34; [[menu.main]] identifier = \u0026#34;post_view_no_sidebar\u0026#34; pre = \u0026#34;fa fa-file-text-o\u0026#34; post = \u0026#34;Single post view without sidebar\u0026#34; name = \u0026#34;Single Post View Without Sidebar\u0026#34; url = \u0026#34;/post-without-sidebar/\u0026#34; title = \u0026#34;\u0026#34; weight = 7 parent = \u0026#34;tutorial\u0026#34; [menu.main.params] color = \u0026#34;#ffc873\u0026#34; [[menu.main]] identifier = \u0026#34;post_view_cover\u0026#34; pre = \u0026#34;fa fa-picture-o\u0026#34; post = \u0026#34;Single post view with cover image\u0026#34; name = \u0026#34;Single Post View with Cover\u0026#34; url = \u0026#34;/post-with-cover-image/\u0026#34; title = \u0026#34;\u0026#34; weight = 8 parent = \u0026#34;tutorial\u0026#34; [menu.main.params] color = \u0026#34;#abe0e5\u0026#34; [[menu.main]] identifier = \u0026#34;video_post\u0026#34; pre = \u0026#34;fa fa-film\u0026#34; post = \u0026#34;Single post view of video post\u0026#34; name = \u0026#34;Video Post\u0026#34; url = \u0026#34;/solidworks-2020-tutorials/\u0026#34; title = \u0026#34;\u0026#34; weight = 9 parent = \u0026#34;tutorial\u0026#34; [menu.main.params] color = \u0026#34;#abe0e5\u0026#34; [[menu.main]] identifier = \u0026#34;landinpage\u0026#34; pre = \u0026#34;fa fa-star text-warning\u0026#34; post = \u0026#34;Insert html on index.md file\u0026#34; name = \u0026#34;Landing Page\u0026#34; url = \u0026#34;/landingpage/\u0026#34; title = \u0026#34;\u0026#34; weight = 10 parent = \u0026#34;tutorial\u0026#34; [menu.main.params] color = \u0026#34;\u0026#34; bordertop = true [[menu.main]] identifier = \u0026#34;books\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Libri\u0026#34; url = \u0026#34;/libri\u0026#34; title = \u0026#34;\u0026#34; weight = 11 [[menu.main]] identifier = \u0026#34;contact\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Contatti\u0026#34; url = \u0026#34;/contatti/\u0026#34; title = \u0026#34;\u0026#34; weight = 12 [[menu.main]] identifier = \u0026#34;about\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;About \u0026#34; url = \u0026#34;/about/\u0026#34; title = \u0026#34;\u0026#34; weight = 13 # [[menu.main]] # identifier = \u0026#34;more\u0026#34; # pre = \u0026#34;\u0026#34; # post = \u0026#34;\u0026#34; # name = \u0026#34;More\u0026#34; # url = \u0026#34;/more/\u0026#34; # title = \u0026#34;\u0026#34; # weight = 10 # [[menu.main]] # identifier = \u0026#34;python_newsletter\u0026#34; # pre = \u0026#34;\u0026#34; # post = \u0026#34;\u0026#34; # name = \u0026#34;Python Newsletter\u0026#34; # url = \u0026#34;/more/\u0026#34; # title = \u0026#34;\u0026#34; # weight = 11 # parent = \u0026#34;more\u0026#34; # [[menu.main]] # identifier = \u0026#34;python_podcast\u0026#34; # pre = \u0026#34;\u0026#34; # post = \u0026#34;\u0026#34; # name = \u0026#34;Python Podcast\u0026#34; # url = \u0026#34;/more/\u0026#34; # title = \u0026#34;\u0026#34; # weight = 11 # parent = \u0026#34;more\u0026#34; # [[menu.main]] # identifier = \u0026#34;python_job_board\u0026#34; # pre = \u0026#34;\u0026#34; # post = \u0026#34;\u0026#34; # name = \u0026#34;Python Job Board →\u0026#34; # url = \u0026#34;/more/\u0026#34; # title = \u0026#34;\u0026#34; # weight = 12 # parent = \u0026#34;more\u0026#34; # Elenco colori da usare nel menu # \u0026#34;color: #ff7e73; # \u0026#34;color: #abe5b1; # \u0026#34;color: #abe0e5; # \u0026#34;color: #ffc873; # \u0026#34;color: #e5c6ab; # \u0026#34;color: #b8abe5; # Footer config [footer] enable = true title = \u0026#34;||||\u0026#34; greatings = \u0026#34;❤️ Happy Pythoning!\u0026#34; [[menu.footer]] name = \u0026#34;Newsletter\u0026#34; link = \u0026#34;newsletter/\u0026#34; weight = 1 [[menu.footer]] name = \u0026#34;Podcast\u0026#34; link = \u0026#34;podcast/\u0026#34; weight = 2 [[menu.footer]] name = \u0026#34;Youtube\u0026#34; link = \u0026#34;youtube/\u0026#34; weight = 3 [[menu.footer]] name = \u0026#34;Twitter\u0026#34; link = \u0026#34;twitter/\u0026#34; weight = 4 [[menu.footer]] name = \u0026#34;Facebook\u0026#34; link = \u0026#34;facebook/\u0026#34; weight = 5 [[menu.footer]] name = \u0026#34;Instagram\u0026#34; link = \u0026#34;Instagram/\u0026#34; weight = 6 [[menu.footer]] name = \u0026#34;Python Tutorials\u0026#34; link = \u0026#34;python-tutorials/\u0026#34; weight = 7 [[menu.footer]] name = \u0026#34;Search\u0026#34; link = \u0026#34;search/\u0026#34; weight = 8 [[menu.footer]] name = \u0026#34;Privacy Policy\u0026#34; link = \u0026#34;privacy-policy/\u0026#34; weight = 9 [[menu.footer]] name = \u0026#34;Energy Policy\u0026#34; link = \u0026#34;energy-policy/\u0026#34; weight = 10 [[menu.footer]] name = \u0026#34;Contact\u0026#34; link = \u0026#34;contact/\u0026#34; weight = 11 ############################# social site ######################## [[params.social]] title = \u0026#34;medium\u0026#34; icon = \u0026#34;fab fa-medium-m\u0026#34; # fontawesome icon : https://fontawesome.com/ link = \u0026#34;https://medium.com/@antedoro\u0026#34; [[params.social]] title = \u0026#34;facebook\u0026#34; icon = \u0026#34;fab fa-facebook-f\u0026#34; # fontawesome icon : https://fontawesome.com/ link = \u0026#34;https://www.facebook.com/antedoroguitars\u0026#34; [[params.social]] title = \u0026#34;twitter\u0026#34; icon = \u0026#34;fab fa-twitter\u0026#34; # fontawesome icon : https://fontawesome.com/ link = \u0026#34;https://twitter.com/AntedoroGuitars\u0026#34; [[params.social]] title = \u0026#34;instagram\u0026#34; icon = \u0026#34;fab fa-instagram\u0026#34; # fontawesome icon : https://fontawesome.com/ link = \u0026#34;https://www.instagram.com/antedoroguitars/\u0026#34; [[params.social]] title = \u0026#34;pinterest\u0026#34; icon = \u0026#34;fab fa-pinterest-p\u0026#34; # fontawesome icon : https://fontawesome.com/ link = \u0026#34;https://www.pinterest.it/antedoroguitars\u0026#34; [[params.social]] title = \u0026#34;telegram\u0026#34; icon = \u0026#34;fab fa-telegram-plane\u0026#34; # fontawesome icon : https://fontawesome.com/ link = \u0026#34;https://telegram.me/antedoroguitars\u0026#34; "
            }
    
        ,
            {
                "id": 35,
                "href": "https://bxtkezhan.github.io/build-in-shortcodes/",
                "title": "Build in Shortcodes",
                "section": "posts",
                "date" : "2022.07.22",
                "body": "Hugo provides multiple built-in shortcodes for author convenience and to keep your markdown content clean.\nHugo uses Markdown for its simple content format. However, there are a lot of things that Markdown doesn’t support well. You could use pure HTML to expand possibilities.\nBut this happens to be a bad idea. Everyone uses Markdown because it’s pure and simple to read even non-rendered. You should avoid HTML to keep it as simple as possible.\nTo avoid this limitations, Hugo created shortcodes. A shortcode is a simple snippet that can generate reasonable HTML code and conforms to Markdown\u0026rsquo;s design philosophy.\nHugo ships with a set of predefined shortcodes that represent very common usage. These shortcodes are provided for author convenience and to keep your markdown content clean.\n1 figure Documentation of figure\nExample figure input:\n{{\u0026lt; figure src=\u0026#34;lighthouse.jpg\u0026#34; title=\u0026#34;Lighthouse (figure)\u0026#34; width=\u0026#34;690px\u0026#34; \u0026gt;}} The rendered output looks like this:\nLighthouse (figure) The HTML looks like this:\n\u0026lt;figure\u0026gt; \u0026lt;img src=\u0026#34;/images/lighthouse.jpg\u0026#34;/\u0026gt; \u0026lt;figcaption\u0026gt; \u0026lt;h4\u0026gt;Lighthouse (figure)\u0026lt;/h4\u0026gt; \u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; 2 gist Documentation of gist\nExample gist input:\n{{\u0026lt; gist spf13 7896402 \u0026gt;}} The rendered output looks like this:\nThe HTML looks like this:\n\u0026lt;script type=\u0026#34;application/javascript\u0026#34; src=\u0026#34;https://gist.github.com/spf13/7896402.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3 highlight Documentation of highlight\nExample highlight input:\n{{\u0026lt; highlight html \u0026gt;}} \u0026lt;section id=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1 id=\u0026#34;title\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ range .Pages }} {{ .Render \u0026#34;summary\u0026#34;}} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; {{\u0026lt; /highlight \u0026gt;}} The rendered output looks like this:\n\u0026lt;section id=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1 id=\u0026#34;title\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ range .Pages }} {{ .Render \u0026#34;summary\u0026#34;}} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; 4 instagram Documentation of instagram\nInstagram’s API was deprecated since October 24th, 2020 The instagram-shortcode refers an endpoint of Instagram’s API, that’s deprecated since October 24th, 2020. Thus, no images can be fetched from this API endpoint, resulting in an error when the instagram-shortcode is used. For more information please have a look at GitHub issue #7879. 5 param Documentation of param\nExample param input:\n{{\u0026lt; param description \u0026gt;}} The rendered output looks like this:\nDescrizione da rivedere se è un doppione subtitle 6 ref and relref Documentation of ref and relref\n7 tweet Documentation of tweet\nExample tweet input:\n{{\u0026lt; tweet 917359331535966209 \u0026gt;}} The rendered output looks like this:\n8 vimeo Documentation of vimeo\nExample vimeo input:\n{{\u0026lt; vimeo 146022717 \u0026gt;}} The rendered output looks like this:\n9 youtube Documentation of youtube\nExample youtube input:\n{{\u0026lt; youtube w7Ft2ymGmfc \u0026gt;}} The rendered output looks like this:\n"
            }
    
        ,
            {
                "id": 36,
                "href": "https://bxtkezhan.github.io/post-with-cover-image/",
                "title": "Post with Cover Image",
                "section": "posts",
                "date" : "2022.07.06",
                "body": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus magna diam, interdum varius varius ac, vehicula et velit. Quisque ac nisi fringilla, fermentum sem in, dignissim lorem. Donec nibh velit, convallis at dolor non, laoreet accumsan lectus. Quisque eget efficitur nunc. Vivamus at lobortis felis. Nunc sed nunc non arcu laoreet ullamcorper sit amet eget ex. Quisque sit amet turpis at sem efficitur sodales sed id leo. Vivamus scelerisque cursus libero quis iaculis. Fusce eu eros porttitor, bibendum odio et, molestie nisl.\nFusce vestibulum lorem id justo euismod, quis porttitor odio porta. Aliquam auctor auctor nunc, in porta enim sagittis non. Quisque iaculis ligula eget ante placerat, sit amet aliquet turpis accumsan. Morbi in lorem nec orci cursus placerat. Nulla non urna tortor. Vivamus sollicitudin convallis dolor at tincidunt. Curabitur elementum, nibh eget suscipit aliquam, urna mi semper dolor, nec hendrerit nunc velit et est.\nCras mauris eros, ultricies id tincidunt eu, fermentum et lectus. Quisque consectetur massa ultrices dolor tincidunt, nec tincidunt risus porttitor. Aenean pharetra leo commodo ante aliquet congue sollicitudin id sem. Pellentesque egestas gravida neque, et semper arcu gravida at. In eros tortor, cursus at cursus hendrerit, congue vel neque. Sed in porttitor nunc. Etiam eget lacinia elit, vel venenatis ex. Ut tristique purus neque, eleifend feugiat ante viverra vel. Maecenas semper turpis ipsum. Donec sed commodo ex. Aliquam vitae consequat est. Duis facilisis nisi non neque molestie, sodales condimentum est gravida. Curabitur sed mi viverra, dictum justo sagittis, sagittis sem. Aenean velit nulla, ornare et commodo ac, bibendum ut urna. Phasellus id varius sem. In suscipit semper lorem, nec lacinia odio blandit et.\nOrci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur viverra fringilla lacus. Curabitur sit amet maximus odio, ullamcorper volutpat nunc. Nunc tincidunt massa et ipsum aliquet efficitur. Donec a vulputate dolor. Donec at ipsum accumsan, auctor mi eget, mollis sem. Aenean neque sem, ultricies sed sapien sed, hendrerit tristique diam. Fusce quis libero varius, placerat sem non, rhoncus metus. Morbi a viverra libero. Nulla facilisi. Ut tincidunt felis a sodales aliquam. In quis sem pellentesque, gravida mauris volutpat, luctus tellus. Donec at magna vel odio mattis varius et ac justo. Proin et turpis a lacus posuere tempus sit amet in mauris. Nunc id tincidunt sem.\nNam nisl ante, tempor at porttitor eu, dignissim eget nisi. Nullam cursus, nisi id imperdiet viverra, mi urna bibendum justo, eget viverra metus massa maximus nibh. Proin molestie lacinia lorem, ac dictum diam gravida in. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Integer sit amet sollicitudin lorem. Nulla suscipit feugiat nulla. Nunc consectetur elit eu ante imperdiet, non lacinia sapien bibendum. Donec nunc velit, semper non tempus sed, consectetur at arcu. Nulla arcu turpis, congue a vestibulum nec, convallis sed nulla. Suspendisse ultricies dictum libero. Morbi lectus lacus, aliquet eget auctor at, congue eget arcu. Phasellus scelerisque tristique dapibus. Quisque et neque velit. Integer nunc nulla, rutrum id libero non, accumsan rhoncus nulla. Donec gravida tortor ac metus tristique sollicitudin.\n"
            }
    
        ,
            {
                "id": 37,
                "href": "https://bxtkezhan.github.io/code-sample/",
                "title": "Code Sample",
                "section": "posts",
                "date" : "2022.06.24",
                "body": "The following are two code samples using syntax highlighting.\nThe following is a code sample using triple backticks ( ``` ) code fencing provided in Hugo. This is client side highlighting and does not require any special installation.\nvar num1, num2, sum num1 = prompt(\u0026#34;Enter first number\u0026#34;) num2 = prompt(\u0026#34;Enter second number\u0026#34;) sum = parseInt(num1) + parseInt(num2) // \u0026#34;+\u0026#34; means \u0026#34;add\u0026#34; alert(\u0026#34;Sum = \u0026#34; + sum) // \u0026#34;+\u0026#34; means combine into a string The following is a code sample using the \u0026ldquo;highlight\u0026rdquo; shortcode provided in Hugo. This is server side highlighting and requires Python and Pygments to be installed.\nvar num1, num2, sum num1 = prompt(\u0026#34;Enter first number\u0026#34;) num2 = prompt(\u0026#34;Enter second number\u0026#34;) sum = parseInt(num1) + parseInt(num2) // \u0026#34;+\u0026#34; means \u0026#34;add\u0026#34; alert(\u0026#34;Sum = \u0026#34; + sum) // \u0026#34;+\u0026#34; means combine into a string And here is the same code with line numbers:\n1 var num1, num2, sum 2 num1 = prompt(\u0026#34;Enter first number\u0026#34;) 3 num2 = prompt(\u0026#34;Enter second number\u0026#34;) 4 sum = parseInt(num1) + parseInt(num2) // \u0026#34;+\u0026#34; means \u0026#34;add\u0026#34; 5 alert(\u0026#34;Sum = \u0026#34; + sum) // \u0026#34;+\u0026#34; means combine into a string "
            }
    
        ,
            {
                "id": 38,
                "href": "https://bxtkezhan.github.io/landingpage/",
                "title": "Landingpage",
                "section": "",
                "date" : "2022.05.20",
                "body": "La Divina Commedia incipit by Dante Alighieri Nel mezzo del cammin di nostra vita mi ritrovai per una selva oscura, ché la diritta via era smarrita.\nAhi quanto a dir qual era è cosa dura esta selva selvaggia e aspra e forte che nel pensier rinova la paura!\nTant’è amara che poco è più morte; ma per trattar del ben ch’i’ vi trovai, dirò de l’altre cose ch’i’ v’ ho scorte.\nIo non so ben ridir com’i’ v’intrai, tant’era pien di sonno a quel punto che la verace via abbandonai.\nMa poi ch’i’ fui al piè d’un colle giunto, là dove terminava quella valle che m’avea di paura il cor compunto,\nguardai in alto e vidi le sue spalle vestite già de’ raggi del pianeta che mena dritto altrui per ogne calle.\nAllor fu la paura un poco queta, che nel lago del cor m’era durata la notte ch’i’ passai con tanta pieta.\n"
            }
    
        ,
            {
                "id": 39,
                "href": "https://bxtkezhan.github.io/policy-privacy/",
                "title": "Policy \u0026 Privacy",
                "section": "",
                "date" : "2022.05.19",
                "body": "Privacy Policy Example Arberia Theme for Hugo (“us”, “we”, or “our”) operates the https://arberiatheme.netlify.app/ website (the “Service”).\nThis page informs you of our policies regarding the collection, use, and disclosure of personal data when you use our Service and the choices you have associated with that data.\nWe use your data to provide and improve the Service. By using the Service, you agree to the collection and use of information in accordance with this policy.\nTable of Contents Definitions\nInformation Collection And Use Types of Data Collected Use of Data Legal Basis for Processing Personal Data Under General Data Protection Regulation (GDPR) Retention of Data Transfer Of Data Disclosure Of Data Business Transaction Disclosure for Law Enforcement Legal Requirements Security Of Data Your Data Protection Rights Under General Data Protection Regulation (GDPR) Service Providers Analytics Payments Links To Other Sites Children’s Privacy Changes To This Privacy Policy Contact Us\nDefinitions Service\nService is the https://arberiatheme.netlify.app/ website operated by Arberia Theme for Hugo\nPersonal Data\nPersonal Data means data about a living individual who can be identified from those data (or from those and other information either in our possession or likely to come into our possession).\nUsage Data\nUsage Data is data collected automatically either generated by the use of the Service or from the Service infrastructure itself (for example, the duration of a page visit).\nCookies\nCookies are small pieces of data stored on your device (computer or mobile device).\nData Controller\nData Controller means the natural or legal person who (either alone or jointly or in common with other persons) determines the purposes for which and the manner in which any personal information are, or are to be, processed.\nFor the purpose of this Privacy Policy, we are a Data Controller of your Personal Data.\nData Processors (or Service Providers)\nData Processor (or Service Provider) means any natural or legal person who processes the data on behalf of the Data Controller.\nWe may use the services of various Service Providers in order to process your data more effectively.\nData Subject (or User)\nData Subject is any living individual who is using our Service and is the subject of Personal Data.\nInformation Collection And Use We collect several different types of information for various purposes to provide and improve our Service to you.\nTypes of Data Collected Personal Data While using our Service, we may ask you to provide us with certain personally identifiable information that can be used to contact or identify you (“Personal Data”). Personally identifiable information may include, but is not limited to:\nEmail address First name and last name Address, State, Province, ZIP/Postal code, City Cookies and Usage Data We may use your Personal Data to contact you with newsletters, marketing or promotional materials and other information that may be of interest to you. You may opt out of receiving any, or all, of these communications from us by following the unsubscribe link or instructions provided in any email we send or by contacting us.\nUsage Data We may also collect information how the Service is accessed and used (“Usage Data”). This Usage Data may include information such as your computer’s Internet Protocol address (e.g. IP address), browser type, browser version, the pages of our Service that you visit, the time and date of your visit, the time spent on those pages, unique device identifiers and other diagnostic data.\nTracking Cookies Data We use cookies and similar tracking technologies to track the activity on our Service and hold certain information.\nCookies are files with small amount of data which may include an anonymous unique identifier. Cookies are sent to your browser from a website and stored on your device. Tracking technologies also used are beacons, tags, and scripts to collect and track information and to improve and analyze our Service.\nYou can instruct your browser to refuse all cookies or to indicate when a cookie is being sent. However, if you do not accept cookies, you may not be able to use some portions of our Service.\nExamples of Cookies we use:\nSession Cookies. We use Session Cookies to operate our Service. Preference Cookies. We use Preference Cookies to remember your preferences and various settings. Security Cookies. We use Security Cookies for security purposes. Use of Data DevCademy Media Inc. uses the collected data for various purposes:\nTo provide and maintain our Service To notify you about changes to our Service To allow you to participate in interactive features of our Service when you choose to do so To provide customer support To gather analysis or valuable information so that we can improve our Service To monitor the usage of our Service To detect, prevent and address technical issues To provide you with news, special offers and general information about other goods, services and events which we offer that are similar to those that you have already purchased or enquired about unless you have opted not to receive such information Legal Basis for Processing Personal Data Under General Data Protection Regulation (GDPR) If you are from the European Economic Area (EEA), DevCademy Media Inc.’s legal basis for collecting and using the personal information described in this Privacy Policy depends on the Personal Data we collect and the specific context in which we collect it.\nDevCademy Media Inc. may process your Personal Data because:\nWe need to perform a contract with you You have given us permission to do so The processing is in our legitimate interests and it’s not overridden by your rights For payment processing purposes To comply with the law Retention of Data Arberia Theme for Hugo will retain your Personal Data only for as long as is necessary for the purposes set out in this Privacy Policy. We will retain and use your Personal Data to the extent necessary to comply with our legal obligations (for example, if we are required to retain your data to comply with applicable laws), resolve disputes, and enforce our legal agreements and policies.\nArberia Theme for Hugo will also retain Usage Data for internal analysis purposes. Usage Data is generally retained for a shorter period of time, except when this data is used to strengthen the security or to improve the functionality of our Service, or we are legally obligated to retain this data for longer time periods.\nTransfer Of Data Your information, including Personal Data, may be transferred to — and maintained on — computers located outside of your state, province, country or other governmental jurisdiction where the data protection laws may differ than those from your jurisdiction.\nIf you are located outside Canada and choose to provide information to us, please note that we transfer the data, including Personal Data, to Canada and process it there.\nYour consent to this Privacy Policy followed by your submission of such information represents your agreement to that transfer.\nArberia Theme for Hugo will take all steps reasonably necessary to ensure that your data is treated securely and in accordance with this Privacy Policy and no transfer of your Personal Data will take place to an organization or a country unless there are adequate controls in place including the security of your data and other personal information.\nDisclosure Of Data Business Transaction If Arberia Theme for Hugo is involved in a merger, acquisition or asset sale, your Personal Data may be transferred. We will provide notice before your Personal Data is transferred and becomes subject to a different Privacy Policy.\nDisclosure for Law Enforcement Under certain circumstances, Arberia Theme for Hugo may be required to disclose your Personal Data if required to do so by law or in response to valid requests by public authorities (e.g. a court or a government agency).\nLegal Requirements Arberia Theme for Hugo may disclose your Personal Data in the good faith belief that such action is necessary to:\nTo comply with a legal obligation To protect and defend the rights or property of DevCademy Media Inc To prevent or investigate possible wrongdoing in connection with the Service To protect the personal safety of users of the Service or the public To protect against legal liability Security Of Data The security of your data is important to us, but remember that no method of transmission over the Internet, or method of electronic storage is 100% secure. While we strive to use commercially acceptable means to protect your Personal Data, we cannot guarantee its absolute security.\nYour Data Protection Rights Under General Data Protection Regulation (GDPR) If you are a resident of the European Economic Area (EEA), you have certain data protection rights. DevCademy Media Inc. aims to take reasonable steps to allow you to correct, amend, delete, or limit the use of your Personal Data.\nIf you wish to be informed what Personal Data we hold about you and if you want it to be removed from our systems, please contact us.\nIn certain circumstances, you have the following data protection rights:\nThe right to access, update or to delete the information we have on you. Whenever made possible, you can access, update or request deletion of your Personal Data directly within your account settings section. If you are unable to perform these actions yourself, please contact us to assist you.\nThe right of rectification. You have the right to have your information rectified if that information is inaccurate or incomplete.\nThe right to object. You have the right to object to our processing of your Personal Data.\nThe right of restriction. You have the right to request that we restrict the processing of your personal information.\nThe right to data portability. You have the right to be provided with a copy of the information we have on you in a structured, machine-readable and commonly used format.\nThe right to withdraw consent. You also have the right to withdraw your consent at any time where DevCademy Media Inc. relied on your consent to process your personal information.\nPlease note that we may ask you to verify your identity before responding to such requests.\nYou have the right to complain to a Data Protection Authority about our collection and use of your Personal Data. For more information, please contact your local data protection authority in the European Economic Area (EEA).\nService Providers We may employ third party companies and individuals to facilitate our Service (“Service Providers”), to provide the Service on our behalf, to perform Service-related services or to assist us in analyzing how our Service is used.\nThese third parties have access to your Personal Data only to perform these tasks on our behalf and are obligated not to disclose or use it for any other purpose.\nAnalytics We may use third-party Service Providers to monitor and analyze the use of our Service.\nGoogle Analytics\nGoogle Analytics is a web analytics service offered by Google that tracks and reports website traffic. Google uses the data collected to track and monitor the use of our Service. This data is shared with other Google services. Google may use the collected data to contextualize and personalize the ads of its own advertising network.\nYou can opt-out of having made your activity on the Service available to Google Analytics by installing the Google Analytics opt-out browser add-on. The add-on prevents the Google Analytics JavaScript (ga.js, analytics.js, and dc.js) from sharing information with Google Analytics about visits activity.\nFor more information on the privacy practices of Google, please visit the Google Privacy Terms web page: http://www.google.com/intl/en/policies/privacy/\nLinks To Other Sites Our Service may contain links to other sites that are not operated by us. If you click on a third party link, you will be directed to that third party’s site. We strongly advise you to review the Privacy Policy of every site you visit.\nWe have no control over and assume no responsibility for the content, privacy policies or practices of any third party sites or services.\nChildren’s Privacy Our Service does not address anyone under the age of 18 (“Children”).\nWe do not knowingly collect personally identifiable information from anyone under the age of 18. If you are a parent or guardian and you are aware that your Children has provided us with Personal Data, please contact us. If we become aware that we have collected Personal Data from children without verification of parental consent, we take steps to remove that information from our servers.\nChanges To This Privacy Policy We may update our Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page.\nWe will let you know via email and/or a prominent notice on our Service, prior to the change becoming effective and update the “effective date” at the top of this Privacy Policy.\nYou are advised to review this Privacy Policy periodically for any changes. Changes to this Privacy Policy are effective when they are posted on this page.\nContact Us If you have any questions about this Privacy Policy, the practices of this site, or your dealings with this site, please contact us:\nArberia Theme for Hugo via Vattelapesca 1 City of Dev WORLD\nThis document was last updated on February 27, 2023.\n"
            }
    
        ,
            {
                "id": 40,
                "href": "https://bxtkezhan.github.io/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/",
                "title": "数据分析・矩阵操作",
                "section": "posts",
                "date" : "2022.05.19",
                "body": "返回教程主页\n上篇 数据分析・资料的载入与导出\n由于本章的后部分内容需要使用到一点关于矩阵运算的基础操作，所以我们在这里先了解一下。\n创建矩阵 import numpy as np m = np.matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9], ]) print(m) 使用np.matrix函数可以创建一个numpy矩阵，该函数可以像np.array一样接收python的列表对象来设置矩阵的值。\n除了从python列表创建矩阵，还可以从python数组以及矩阵中创建矩阵，正如下面这样:\nm2 = np.matrix(np.array([ [1, 2, 3], [4, 5, 6], [7, 8, 9], ])) print(m2) m3 = np.matrix(np.matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9], ])) print(m3) 另外，np.matrix还具有一种参数形式:\nm4 = np.matrix(\u0026#39;1 2 3; 4 5 6; 7 8 9\u0026#39;) print(m4) 用一个字符串初始矩阵的元素值，每一行元素之间用;进行分隔，每行的各个元素用空格进行分隔，类似matlab或octave的矩阵创建形式。\n矩阵转置 可以使用矩阵转置的方法将矩阵的行和列的关系对调，在numpy当中可以通过矩阵的属性Matrix.T实现:\nm = np.matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9], ]) print(m) mT = m.T print(mT) 运行后输出结果:\n[[1 2 3] [4 5 6] [7 8 9]] [[1 4 7] [2 5 8] [3 6 9]] 加法减法除法运算 直接使用运算符+、-、/进行的运算都是对应元素间两两运算后的结果:\nm = np.matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9], ]) print(m) print(m + m) print(m - m) print(m / m) 运行后输出结果:\n[[1 2 3] [4 5 6] [7 8 9]] [[ 2 4 6] [ 8 10 12] [14 16 18]] [[0 0 0] [0 0 0] [0 0 0]] [[1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] 矩阵乘法与对应元素的乘法 直接使用运算符*会对matrix对象调用numpy的矩阵乘法，矩阵乘法的规则如下图所示:\n如果想要计算对应元素相乘后的结果可以调用函数np.multiply进行计算:\nm = np.matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9], ]) print(m) print(m * m) print(np.multiply(m, m)) 运行后输出结果:\n[[1 2 3] [4 5 6] [7 8 9]] [[ 30 36 42] [ 66 81 96] [102 126 150]] [[ 1 4 9] [16 25 36] [49 64 81]] 矩阵的索引 numpy的矩阵对象和数组对象一样可以进行索引。\n获取矩阵的某行或某几行:\nprint(m[0]) print(m[1:3]) 获取矩阵的某列或某几列:\nprint(m[:, 0]) print(m[:, 1:3]) 其它复杂的索引可以参考对numpy数组对象的索引方式。\n下篇 数据分析・最小二乘拟合\n"
            }
    
        ,
            {
                "id": 41,
                "href": "https://bxtkezhan.github.io/extended-shortcode/",
                "title": "Extended Shortcode",
                "section": "posts",
                "date" : "2022.05.01",
                "body": "Arberia Theme provides multiple built-in shortcodes for author convenience and to keep your markdown content clean. To expand your possibility this is an example list of all provided shortcodes.\nAlert Shortcode to inset varius alert on markdown post use this code:\n{{\u0026lt; alert-info \u0026#34;[**Click here to get an example of info alert**](https://antedoro.it/) followed in this tutorial.\u0026#34;\u0026gt;}} {{\u0026lt; alert-success \u0026#34;[**Click here to get an example of info alert**](https://antedoro.it/) followed in this tutorial.\u0026#34;\u0026gt;}} {{\u0026lt; alert-warning \u0026#34;[**Click here to get an example of info alert**](https://antedoro.it/) followed in this tutorial.\u0026#34;\u0026gt;}} {{\u0026lt; alert-danger \u0026#34;[**Click here to get an example of info alert**](https://antedoro.it/) followed in this tutorial.\u0026#34;\u0026gt;}} {{\u0026lt; alert-dark \u0026#34;[**Click here to get an example of info alert**](https://antedoro.it/) followed in this tutorial.\u0026#34;\u0026gt;}} Click here to get an example of info alert followed in this tutorial.\nClick here to get an example of success alert followed in this tutorial.\nClick here to get an example of warning alert followed in this tutorial.\nClick here to get an example of danger alert followed in this tutorial.\nClick here to get an example of dark alert followed in this tutorial.\nList Element Topic\nWho I am? My name is Vincenzo Antedoro. I was born and grew up in south of Italy. In my challenge of creativity, I was ispired from near ancient greek culture and mediterranean in general.\nGallery Image Caption Playlist of videos Tutorial Solidworks 9 Lessons 9:38\n1. Solidworks: Modelliamo un supporto 7:34 2. Solidworks: Modelliamo un supporto a guscio 2:04 3. Solidworks: Come creare una assieme 2:04 4. Solidworks: Messa in tavola guscio inferiore 7:34 5. Solidworks: Messa in tavola del supporto superiore 2:04 6. Solidworks: Modelliamo una Biella 2:04 7. SOLIDWORKS BONUS TUTORIAL: Modelliamo il Cappello di Biella 7:34 8. Solidworks: Modelliamo un Pistone 2:04 9. Solidworks: Progettazione un albero motore in Solidworks 2:04 Collapsable FAQ Menu What time is it?Show/Hide\nOffice Hours is a weekly Zoom-based online hangout with experts from the Real Python Team, where you can get help and discuss your Python questions with us and other community members. If you want to join, you can register at the link above to get a Zoom link. Hoew do I join?Show/Hide\nOffice Hours are available to all Real Python Members. Just click the button above under Upcoming Events where you can sign up for the next event. How often I can partecipate?Show/Hide\nAs often as you want! We have several regulars that come every week! Do I have to say everithing??Show/Hide\nNo, you’re more than welcome to join even if you just want to listen and leave your camera and microphone turned off. If you have a question you can ask it via Zoom’s text-based chat or post it in the #office-hours channel in the RP Community Slack. Downlodable File Link Download\nFile (.pdf)\n1.3 MB\n"
            }
    
        ,
            {
                "id": 42,
                "href": "https://bxtkezhan.github.io/contact/",
                "title": "Contact",
                "section": "",
                "date" : "2022.04.26",
                "body": "Thank you for your interest! If you’ve read this far, thank you very much: it means that you care what I do on a professional level! Why you do not write me now for more information, or simply to get in touch with me?\n"
            }
    
        ,
            {
                "id": 43,
                "href": "https://bxtkezhan.github.io/%E9%A1%B9%E7%9B%AEsmartfile/",
                "title": "项目・Smartfile",
                "section": "posts",
                "date" : "2022.02.13",
                "body": "这是一个命名为smartfile.sm的文件，当我们双击它，就会进入smartfile的介绍页面。\nsmartfile文件会将自己的文件名当作参数来设定自己的打开方式，例如接下来我们将它的名称改为firefox.sm，然后双击就会发现firefox浏览器被我们打开了。\n除了firefox，我们还可以使用它开启文本编辑器来编辑文本文件和代码，就像这样。\n我们还可以把文件名称改为http开头的网址来开启网络资源。这里需要注意的是，由于操作系统命名规范的问题我们需要将斜杠符号替换成反斜杠符号，就像这样，下面我们再尝试打开它。\nsmartfile文件可以帮助我们将网络上的资源转换成桌面快捷方式，类似于创建了网络版本的应用程序；还能将一些日常操作整理成快捷方式，提升用户使用电脑的效率。\n当前版本的smartfile使用go语言开发，源代码共计不到50行。smartfile项目的源代码可以通过github查找并获取。\n通过查看源代码，我们可以知道，smartfile将网络资源作为Web App打开的功能是基于一个叫做Lorca的go语言的ui库开发的。这个ui库的特点是，它会调用用户本机安装的chrome内核的浏览器去将网络资源以App的模式打开。\n以上呢就是今天关于smartfile项目的介绍。下一期我们再看另一个http相关的工具，该工具的功能是将网络上的资源通过fuse文件系统技术投射到本机，感兴趣的朋友欢迎继续关注，我们下次再见。\n"
            }
    
        ,
            {
                "id": 44,
                "href": "https://bxtkezhan.github.io/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%B5%84%E6%96%99%E7%9A%84%E8%BD%BD%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/",
                "title": "数据分析・资料的载入与导出",
                "section": "posts",
                "date" : "2022.01.18",
                "body": "返回教程主页\n上篇 数据分析・数据可视化\n现在我们来了解如何在Python中进行数据的载入和导出操作，我们以Json和CSV这两个常见的文本数据类型进行讲解。\nJSON数据的载入与导出 python的json模块提供了一种很简单的方式来编码和解码JSON数据。 其中两个主要的函数是json.dumps()和json.loads()，下面演示如何将一个Python数据结构转换为JSON：\nimport json data = {\u0026#39;author\u0026#39;: \u0026#39;kk\u0026#39;, \u0026#39;level\u0026#39;: 10, \u0026#39;is old man\u0026#39;: True} jsonStr = json.dumps(data) print(type(jsonStr), jsonStr) data = json.loads(jsonStr) print(type(data), data) 运行后输出:\n\u0026lt;class \u0026#39;str\u0026#39;\u0026gt; {\u0026#34;author\u0026#34;: \u0026#34;kk\u0026#34;, \u0026#34;level\u0026#34;: 10, \u0026#34;is old man\u0026#34;: true} \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;author\u0026#39;: \u0026#39;kk\u0026#39;, \u0026#39;level\u0026#39;: 10, \u0026#39;is old man\u0026#39;: True} json.dumps用于将python对象「通常为字典，列表」转换为json格式的字符串；json.loads将json格式的字符串解析成python对象。\n几个常见的python类型与json类型的互换对照:\npython json None null True true False false int numbers float numbers str string list array dict object 如果想要从磁盘文件载入json数据，或者将数据导出为json格式的磁盘文件可以使用json.dump()与json.load():\nimport json data = {\u0026#39;author\u0026#39;: \u0026#39;kk\u0026#39;, \u0026#39;level\u0026#39;: 10, \u0026#39;is old man\u0026#39;: True} print(data) with open(\u0026#39;myjson.json\u0026#39;, \u0026#39;w\u0026#39;) as f: json.dump(data, f) with open(\u0026#39;myjson.json\u0026#39;, \u0026#39;r\u0026#39;) as f: data = json.load(f) print(data) CSV数据的读取 对于大多数的CSV格式的数据读写问题，都可以使用python的csv库。例如：假设你在一个名叫stocks.csv文件中有一些股票市场数据，就像这样：\nSymbol,Price,Date,Time,Change,Volume \u0026#34;AA\u0026#34;,39.48,\u0026#34;6/11/2007\u0026#34;,\u0026#34;9:36am\u0026#34;,-0.18,181800 \u0026#34;AIG\u0026#34;,71.38,\u0026#34;6/11/2007\u0026#34;,\u0026#34;9:36am\u0026#34;,-0.15,195500 \u0026#34;AXP\u0026#34;,62.58,\u0026#34;6/11/2007\u0026#34;,\u0026#34;9:36am\u0026#34;,-0.46,935000 \u0026#34;BA\u0026#34;,98.31,\u0026#34;6/11/2007\u0026#34;,\u0026#34;9:36am\u0026#34;,+0.12,104800 \u0026#34;C\u0026#34;,53.08,\u0026#34;6/11/2007\u0026#34;,\u0026#34;9:36am\u0026#34;,-0.25,360900 \u0026#34;CAT\u0026#34;,78.29,\u0026#34;6/11/2007\u0026#34;,\u0026#34;9:36am\u0026#34;,-0.23,225400 import csv with open(\u0026#39;./stocks.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: c = csv.reader(f, delimiter=\u0026#39;,\u0026#39;) header = next(c) print(header) for row in c: print(row) 函数csv.reader可以接收文件句柄并进行读取，通过delimiter参数设定分隔符，该函数返回一个可迭代的对象，一般先使用next函数抽取表头信息，然后在一个for语句中遍历每一行数据，每一行的数据将以列表的进行展现，就像下面这样:\n[\u0026#39;Symbol\u0026#39;, \u0026#39;Price\u0026#39;, \u0026#39;Date\u0026#39;, \u0026#39;Time\u0026#39;, \u0026#39;Change\u0026#39;, \u0026#39;Volume\u0026#39;] [\u0026#39;AA\u0026#39;, \u0026#39;39.48\u0026#39;, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, \u0026#39;-0.18\u0026#39;, \u0026#39;181800\u0026#39;] [\u0026#39;AIG\u0026#39;, \u0026#39;71.38\u0026#39;, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, \u0026#39;-0.15\u0026#39;, \u0026#39;195500\u0026#39;] [\u0026#39;AXP\u0026#39;, \u0026#39;62.58\u0026#39;, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, \u0026#39;-0.46\u0026#39;, \u0026#39;935000\u0026#39;] [\u0026#39;BA\u0026#39;, \u0026#39;98.31\u0026#39;, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, \u0026#39;+0.12\u0026#39;, \u0026#39;104800\u0026#39;] [\u0026#39;C\u0026#39;, \u0026#39;53.08\u0026#39;, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, \u0026#39;-0.25\u0026#39;, \u0026#39;360900\u0026#39;] [\u0026#39;CAT\u0026#39;, \u0026#39;78.29\u0026#39;, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, \u0026#39;-0.23\u0026#39;, \u0026#39;225400\u0026#39;] 通过观察可以发现解析后的数据统一为字符串类型，这并不符合原本数据中的描述，可以额外再做数据转换处理:\nimport csv types = (str, float, str, str, float, int) with open(\u0026#39;./stocks.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: c = csv.reader(f, delimiter=\u0026#39;,\u0026#39;) header = next(c) print(header) for row in c: row = [types[i](v) for i, v in enumerate(row)] print(row) 运行后输出:\n[\u0026#39;Symbol\u0026#39;, \u0026#39;Price\u0026#39;, \u0026#39;Date\u0026#39;, \u0026#39;Time\u0026#39;, \u0026#39;Change\u0026#39;, \u0026#39;Volume\u0026#39;] [\u0026#39;AA\u0026#39;, 39.48, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, -0.18, 181800] [\u0026#39;AIG\u0026#39;, 71.38, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, -0.15, 195500] [\u0026#39;AXP\u0026#39;, 62.58, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, -0.46, 935000] [\u0026#39;BA\u0026#39;, 98.31, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, 0.12, 104800] [\u0026#39;C\u0026#39;, 53.08, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, -0.25, 360900] [\u0026#39;CAT\u0026#39;, 78.29, \u0026#39;6/11/2007\u0026#39;, \u0026#39;9:36am\u0026#39;, -0.23, 225400] 继续学习 实际上python内置的json与csv模块还有很多细节操作值得去学习，感兴趣的朋友可以去到python官方文档页面进行详细的了解。\n下篇 数据分析・矩阵计算\n"
            }
    
        ,
            {
                "id": 45,
                "href": "https://bxtkezhan.github.io/the-beginningpython-calculator/",
                "title": "The Beginning・Python Calculator",
                "section": "posts",
                "date" : "2022.01.15",
                "body": "We can use python to do some calc operations like a calculator. It will be power than many calculators if you know enough python. And some calculators have embedded python. Casio FX 9860 GIII is an example.\nThe Number In WIDLE(WIDLE is a python ide run in a web browser), you can input expressions and click the run button to get answers. Use the print function to show the answers. The grammar of these expressions is so direct. Some symbols like +, -, *, / just like in calculator. And by the brackets like () can deal with the priority. An example:\nprint(1 + 2) print(3 - 4) print(5 * 6) print(7 / 8) print(1 + (2 - 3) * 4 / 5) The operation result:\n3 -1 30 0.875 0.19999999999999996 Integer like these 2, 4, 20 is int type, float like these 5.0, 1.6 is float type.\nDo divide using the symbol / will return a float value, but // will return an integer value. Use % to do modulo operation.\nprint(10 / 3) print(10 // 3) print(10 % 3) The operation result:\n3.3333333333333335 3 1 The equal symbol = is used to assign the variable. The python variable is like the variable in math, and we can use a python variable to refer to a value. A = B is assigned a value B to a variable A.\nwidth = 10 height = 10 area = width * height print(area) The operation result:\n100 The variable in the python program is case-sensitive. Some recommend formats of the variable are below.\nPut letters or underscore to first; Characters of the variable only letters, underline, and numbers(A-z, 0-9, and _); The String In addition to the number, there is the string in python. The string format of python is multiple, for example, single quotation marks '...' and double quotation marks \u0026quot;...\u0026quot;.\nprint(\u0026#39;Hi! kk.\u0026#39;) print(\u0026#34;Hi! jojo.\u0026#34;) The operation result:\nHi! kk. Hi! jojo. Convert some characters to special characters by a backslash symbol \\:\nprint(\u0026#39;0\\t1\\t2\\t3\u0026#39;) print(\u0026#39;0\\n1\\n2\\n3\u0026#39;) The operation result:\n0\t1\t2\t3 0 1 2 3 We can new lines in a string when using triple quotation marks. If you want it not to be a new line, add a backslash symbol \\ at the end of the previous line. Below is an example:\nprint(\u0026#34;\u0026#34;\u0026#34;\\ Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to \u0026#34;\u0026#34;\u0026#34;) The operation result:\nUsage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to Concatenation strings using +, using * to repeat it:\nprint(\u0026#39;123\u0026#39; + \u0026#39;456\u0026#39;) print(\u0026#39;abc\u0026#39; * 3) The operation result:\n123456 abcabcabc We can use the len function to calculate string length\nnumbers = \u0026#39;1234567890\u0026#39; print(len(numbers)) The operation result:\n10 The Types Use type function to print type name of objects:\na = 123 print(type(a)) b = 123.321 print(type(b)) c = \u0026#34;123.321\u0026#34; print(type(c)) The operation result:\n\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; We can use int, float, str functions to do type converting:\na = 123 print(a, type(a)) b = float(a) print(b, type(b)) c = str(b) print(c, type(c)) e = float(c) print(e, type(e)) f = int(e) print(f, type(f)) The operation result:\n123 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 123.0 \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; 123.0 \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 123.0 \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; 123 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; "
            }
    
        ,
            {
                "id": 46,
                "href": "https://bxtkezhan.github.io/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/",
                "title": "数据分析・数据可视化",
                "section": "posts",
                "date" : "2021.12.08",
                "body": "返回教程主页\n上篇 数据分析・多维数组的数值操作\nMatplotlib是一个非常有用的Python数据绘图库，借助Matplotlib可以很方便的将数据可视化。\n简单示范 我们通过绘制一个简单的函数 $y=x^2$ 来了解matplotlib的基本使用方式。\n(1) 引入matplotlib以及numpy库:\nimport matplotlib.pyplot as plt import numpy as np (2) 使用numpy生成均匀分布在-5到5之间的100个数作为横座标集x:\nx = np.linspace(-5, 5, 100) (3) 通过函数 $y=x^2$ 计算纵座标集y:\ny = x**2 (4) 调用plot函数进行绘制:\nplt.plot(x, y) (5) 设置x与y座标的标签:\nplt.xlabel(\u0026#39;x\u0026#39;) plt.ylabel(\u0026#39;y\u0026#39;) (6) 调用show函数显示绘制结果:\nplt.show() 子图显示 我们可以使用subplot方法在一个窗口中显示多个子图:\nplt.subplot(3, 1, 1) plt.title(\u0026#39;part1\u0026#39;) plt.plot(x[:50], y[:50]) plt.subplot(3, 1, 2) plt.title(\u0026#39;part2\u0026#39;) plt.plot(x[50:], y[50:]) plt.subplot(3, 1, 3) plt.title(\u0026#39;full\u0026#39;) plt.plot(x, y) plt.show() subplot(3, 1, 1)表示将窗口分割为3行1列，选中当前顺序「上小于下，左小于右，从1开始」中的第一个子图。\n直方图绘制 接下来我们以直方图的显示展示y集:\nbins = np.linspace(0, 30, 7) plt.hist(y, bins, rwidth=0.9) plt.show() 使用np.linspace产生7个均匀分布在0到30的点作为区间分割点，调用hist函数将其以直方图的形式绘制出来，参数rwidth表示条形所占区间的比例。\n散点图 现在使用散点图展示 $y=x^2$:\nplt.scatter(x, y, s=y * 2, c=y / 25, alpha=0.5) plt.show() 调用scatter函数以散点图的形式展示函数图像。参数s用于控制对应点的大小；参数c可以用于设定对应点的颜色；alpha用于设定透明度。\n继续学习 Matplotlib的绘图功能十分丰富，也支持动画，3D数据绘制，感兴趣的朋友可以去往其官方文档自主学习:\nhttps://matplotlib.org/\u0026hellip;\n下篇 数据分析・资料的载入与导出\n"
            }
    
        ,
            {
                "id": 47,
                "href": "https://bxtkezhan.github.io/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C/",
                "title": "数据分析・多维数组的数值操作",
                "section": "posts",
                "date" : "2021.11.17",
                "body": "返回教程主页\n上篇 数据分析・操作环境准备\n数组结构可以快速有序的处理一系列的数据。因此，在处理数据的时候常常要用到数组或多维数组，一个常用的例子就是在处理Excel表格数据的时候将其表示为二维数组。\n构建numpy数组 假设我们有如下表格数据:\n序号 表列A 表列B 表列C 1 1.1 2.1 3.1 2 1.2 2.2 3.2 3 1.3 2.3 3.3 4 1.4 2.4 3.4 我们关心的是数值区域的内容:\n1.1 2.1 3.1 1.2 2.2 3.2 1.3 2.3 3.3 1.4 2.4 3.4 使用numpy数组来存储它:\nimport numpy as np data = [ [1.1, 2.1, 3.1], [1.2, 2.2, 3.2], [1.3, 2.3, 3.3], [1.4, 2.4, 3.4], ] array2d = np.array(data) print(array2d.shape, array2d.dtype) print(array2d) 运行后输出:\n(4, 3) float64 [[1.1 2.1 3.1] [1.2 2.2 3.2] [1.3 2.3 3.3] [1.4 2.4 3.4]] 在上述代码中我们将一个“二维”的序列结构「例如: list, tuple」转换成了numpy的二维数组。\n使用numpy数组的.shape属性可以查看数组的维度信息，从运行输出可以看出这是一个4行3列的numpy数组；使用numpy数组的.dtype属性可以查看数组的类型信息，从运行结果可以看出numpy数组的元素数值类型为64位浮点型。\n用类似的方法我们也可以创建其它维度的numpy数组，例如:\ndim1 = np.array([1, 2, 3]) print(dim1.shape) dim3 = np.array([[[1] * 3] * 3] * 3) print(dim3.shape) 除了将list，tuple这类序列结构转换为numpy数组的创建方法，我们还可以直接初始化一个numpy数组。\n初始化一个3行4列的numpy数组，其中的每一个元素的值都为0，且值的类型为float:\nzeros = np.zeros((3, 4), dtype=float) 初始化一个3行4列的numpy数组，其中的每一个元素的值都为1，且值的类型为int:\nones = np.ones((3, 4), dtype=int) numpy数组的索引 numpy数组可以直接在多个维度上进行索引操作，例如arr[0, 1, 2]表示先取出arr的第0个子数组A「假定为A」，然后取A的第1个子数组B「假定为B」，最后取出B的第2个子数组。\n为了方便理解，我们举个例子。现在假设二维数组就是表格，那么三维数组则代表一组表格。现在我们有一组表格G，G[0]表示该组的第0张表格；G[0, 1]表示第0张表格的第1行；G[0, 1, 2]表示第0张表格的第1行的第2列。\nG = np.array([[ [1.1, 2.1, 3.1], [1.2, 2.2, 3.2], [1.3, 2.3, 3.3], [1.4, 2.4, 3.4], ]] * 5) print(G.shape) print(G[0, 1, 2]) 运行后输出:\n(5, 4, 3) 3.2 通过索引我们可以对数组进行批量计算和赋值:\nG = np.array([[ [1.1, 2.1, 3.1], [1.2, 2.2, 3.2], [1.3, 2.3, 3.3], [1.4, 2.4, 3.4], ]] * 5) G[1] += 1 G[2] += 2 print(G[0, 1, 2]) print(G[1, 1, 2]) print(G[2, 1, 2]) 运行后输出:\n3.2 4.2 5.2 冒号:作为索引号表示某维度的全体成员，例如G[0, 1, 2]表示0号表格第1行第2列而G[0, :, 2]表示0号表格每一行的第2列。\n求和、求平均 下面介绍一下如何在numpy数组中求和、求平均。\n我们使用如下二维数组来做示范:\ntable = np.array([ [1.1, 2.1, 3.1], [1.2, 2.2, 3.2], [1.3, 2.3, 3.3], [1.4, 2.4, 3.4], ]) 求和:\n_sum = table.sum() print(_sum) 运行后输出:\n26.999999999999996 先索引，然后求和，如:\nprint(table[0].sum()) print(table[:, 0].sum()) 运行后输出:\n6.300000000000001 5.0 求平均:\nmean = table.mean() print(mean) 运行后输出:\n2.2499999999999996 先索引，然后求平均，如:\nprint(table[0].mean()) print(table[:, 0].mean()) 运行后输出:\n2.1 1.25 下篇 数据分析・数据可视化\n"
            }
    
        ,
            {
                "id": 48,
                "href": "https://bxtkezhan.github.io/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/",
                "title": "数据分析・操作环境准备",
                "section": "posts",
                "date" : "2021.11.15",
                "body": "返回教程主页\n上篇 影像处理・视频编辑\n本章介绍一些Python数据分析的入门知识，下面列出本章节会使用的一些依赖库。\nnumpy numpy是著名的Python数值计算库，许多的数据计算操作都依赖它实现。使用pip就能完成下载安装，命令如下:\npip install numpy matplotlib 常用的Python绘图工具，方便进行数据可视化工作。pip的安装指令如下:\npip install matplotlib SciPy SciPy是一个开源的Python算法库和数学工具包。SciPy包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。\nSciPy的pip安装指令如下:\npip install scipy 下篇 数据分析・多维数组的数值操作\n"
            }
    
        ,
            {
                "id": 49,
                "href": "https://bxtkezhan.github.io/%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91/",
                "title": "影像处理・视频编辑",
                "section": "posts",
                "date" : "2021.11.05",
                "body": "返回教程主页\n上篇 影像处理・人脸识别\n关于影像处理除了进行类似计算机视觉与数字图像处理的操作，我们还可以像一些非线性编辑软件一样对视频材料进行剪辑处理，以及添加专场、字幕等操作。通常此类操作都会使用到ffmpeg这款开源的数字媒体处理工具，而它有一个叫做moviepy的接口，可以让我们轻松上手。\n安装moviepy 使用pip就能完成下载安装，命令如下:\npip install moviepy 如果安装过程出现问题可以去到项目网页(https://github.com/Zulko/moviepy)查看原因，或者搜索相关信息。\n载入视频 首先我们可以载入一段视频，然后获取相关信息，如：帧率、时长、分辨率……:\nimport moviepy.editor as mpy video = mpy.VideoFileClip(\u0026#39;我的视频.mp4\u0026#39;) print(video.fps, video.duration, video.size) 运行后输出:\n15.0 39.93 [1368, 768] mpy.VideoFileClip接收一个字符串类型的视频地址用于载入该视频并实例化一个VideoClip对象。.fps为帧率；.duration为时长；.size为分辨率大小。\n截取视频 使用.subclip方法可以截取视频:\nsub1 = video.subclip(0, 5) print(sub1.duration) sub2 = video.subclip(-5) print(sub2.duration) .subclip用于截取视频并返回对应的VideoClip对象，通过.subclip的参数可以决定我们截取视频的位置。第一个参数表示开始时间；第二个参数表示终止时间，默认为原视频的终止时间。\n导出视频 使用.write_videofile方法可以将视频对象导出成视频文件:\nsub1.write_videofile(\u0026#39;sub1.mp4\u0026#39;) .write_videofile就收一个字符串类型的参数用于指定视频保存的文件名。\n添加淡入淡出 sub1_faded = sub1.fadein(0.5).fadeout(0.5) sub1_faded.write_videofile(\u0026#39;sub1_faded.mp4\u0026#39;) 淡入为.fadein，会返回对应的VideoClip对象，可以传入一个浮点型参数用于设定时长；淡出为.fadeout，同样会返回对应的VideoClip对象，也可以传入浮点型参数设定时长。\n拼接视频 final = mpy.concatenate([ sub1.fadein(0.5).fadeout(0.5), sub2.fadein(0.5).fadeout(0.5), ]) final.write_videofile(\u0026#39;final.mp4\u0026#39;) 使用mpy.concatenate函数可以拼接视频并返回对应的VideoClip对象。它就收一个列表作为输入参数，该列表的每一项都是VideoClip对象。\n继续学习 更多操作可以去到官方文档(https://zulko.github.io/moviepy/)学习。\n下篇 数据分析・操作环境准备\n"
            }
    
        ,
            {
                "id": 50,
                "href": "https://bxtkezhan.github.io/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80linux/x86-64%E8%B0%83%E7%94%A8c%E7%A8%8B%E5%BA%8F/",
                "title": "汇编语言「Linux/x86-64」・调用C程序",
                "section": "posts",
                "date" : "2021.10.17",
                "body": "在有操作系统的情况下使用纯汇编开发程序的情况非常少，即便是不得不用汇编的场景也常常是使用汇编结合高级编程语言的方式进行开发。下面我们来了解一下如何在汇编之中调用C程序以及在C程序中调用汇编。\n在汇编中调用C 我们借助gcc也可以替代ld完成连接。除此之外，我们还可以在汇编代码中调用C标准函数:\n; filename: callc.asm global main extern puts section .text main: mov rdi, message call puts ret message: db \u0026#34;Hello, World\u0026#34;, 0 这是由之前的示例代码修改而成的调用C标准函数puts打印输出的代码，它的编译连接方法如下:\nnasm -felf64 callc.asm # 首先生成目标文件 gcc -no-pie callc.o # 对目标文件进行连接操作 当我们在64位的Linux操作系统下编写这类调用C标准库的汇编程序时应该注意到一些函数调用的规范。关于详细的信息可以从维基百科中获得。这里主要列出最重要的几点:\n传递参数时，按照从左到右的顺序，将尽可能多的参数依次保存在寄存器中。存放位置的寄存器顺序是确定的： 对于整数和指针，rdi，rsi，rdx，rcx，r8，r9。 对于浮点数（float和double类型），xmm0，xmm1，xmm2，xmm3，xmm4，xmm5，xmm6，xmm7。 剩下的参数将按照从右到左的顺序压入栈中，并在调用之后由调用函数推出栈。 等所有的参数传入后，会生成调用指令。所以当被调用函数得到控制权后，返回地址会被保存在[rsp]中，第一个局部变量会被保存在[rsp+8]中，以此类推。 栈指针rsp在调用前必须进行16字节对齐处理。当然，调用的过程中只会把一个8bytes的返回地址推入栈中，所以当函数得到控制权时，rsp并没有对齐。你需要向栈中压入数据或者从rsp减去8来使之对齐。 被调用函数需要保存如下的寄存器：rbp，rbx，r12，r13，r14，r15。其他的寄存器可以自由使用。 被调用函数也需要保存XMCSR的控制位和x87指令集的控制字，但是x87指令在64位系统上十分少见所以你不必担心这点。 整数返回值存放在rax或者rdx:rax中，浮点数返回值存放在xmm0或者xmm1:xmm0中。 下列代码是上述规范的示例:\nglobal main extern printf section .text main: push rax ; 压入rax的值到栈 mov rdi, format ; 从左到右第一个参数 format mov rsi, 10 ; 从左到右第二个参数 数字10 mov rdx, 20 ; 从左到右第三个参数 数字20 mov rcx, rsi add rcx, rdx ; 从左到右第四个参数 10 + 20 ; 我们压入了一个rax加上返回地址就对齐了16bytes call printf pop rax ; 从栈中弹出原本rax的值到rax ret format: db \u0026#34;%ld + %ld = %ld\u0026#34;, 10, 0 在C语言中调用汇编程序 我们先来用汇编写一个int64类型max函数，用于返回两个int64类型的参数中最大的数值:\nglobal maxi64 section .text maxi64: ; 根据规则，rax存储返回值，先将第一个参数rdi的值给到它 mov rax, rdi ; 对比第一个参数和第二个参数大小 cmp rax, rsi ; cmovl表示根据上一个cmp的比较结果来决定是否进行mov操作 ; 如果是rax \u0026lt; rsi则mov rax, rsi cmovl rax, rsi ret 接下来我们编写C语言程序调用它:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;inttypes.h\u0026gt; int64_t maxi64(int64_t, int64_t); int main() { printf(\u0026#34;%ld\\n\u0026#34;, maxi64(1, 7)); printf(\u0026#34;%ld\\n\u0026#34;, maxi64(3, 5)); printf(\u0026#34;%ld\\n\u0026#34;, maxi64(5, 3)); printf(\u0026#34;%ld\\n\u0026#34;, maxi64(7, 1)); return 0; } 假定汇编文件名为maxi64.asm；C程序文件名为test_maxi64.c。我们使用如下命令进行编译与运行:\nnasm -felf64 maxi64.asm gcc test_maxi64.c maxi64.o ./a.out "
            }
    
        ,
            {
                "id": 51,
                "href": "https://bxtkezhan.github.io/%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/",
                "title": "影像处理・人脸识别",
                "section": "posts",
                "date" : "2021.10.04",
                "body": "返回教程主页\n上篇 影像处理・目标检测\n想要使用Python实现人脸识别也不是一件难事，使用face_recognition人脸识别开发库可以快速上手。\n我们仍旧使用pip工具进行安装:\npip install face_recognition 载入已知人脸 首先我们需要载入已知人脸的图像「该图像中确定存在某人的脸」:\nimport face_recognition picture_of_me = face_recognition.load_image_file(\u0026#39;me.jpg\u0026#39;) my_face_encoding = face_recognition.face_encodings(picture_of_me)[0] 首先我们需要引入开发库import face_recognition；然后我们载入图像picture_of_me = face_recognition.load_image_file('me.jpg')，图像将被转换成numpy.ndarray类型的数据；接下来对图像中的人脸数据进行编码face_recognition.face_encodings(picture_of_me)，该函数将以列表类型返回一串编码信息，如果图像中只有一张人脸，我们只需要取第0个编码。\n载入未知人脸 接下来我们载入另一张含有人脸的图像:\nunknown_picture = face_recognition.load_image_file(\u0026#39;unknown.jpg\u0026#39;) unknown_face_encoding = face_recognition.face_encodings(unknown_picture)[0] 对比识别 将二者进行比对，完成人脸识别操作:\nresults = face_recognition.compare_faces([my_face_encoding], unknown_face_encoding) if results[0] == True: print(\u0026#34;It\u0026#39;s a picture of me!\u0026#34;) else: print(\u0026#34;It\u0026#39;s not a picture of me!\u0026#34;) 函数face_recognition.compare_faces第一个参数为列表类型，接收一串已知的人脸编码；第二个参数为待检测的人脸编码；返回值是一个列表类型的识别结果，列表中的每一项对应第一个参数已知人脸编码的每一项，例如: [True, False]表示待测的人脸被检测为已知列表中第0项编码所对应的人脸。\n下篇 影像处理・视频编辑\n"
            }
    
        ,
            {
                "id": 52,
                "href": "https://bxtkezhan.github.io/%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/",
                "title": "影像处理・目标检测",
                "section": "posts",
                "date" : "2021.10.03",
                "body": "返回教程主页\n上篇 影像处理・网络摄像头\n在成功调用摄像头并获取视频内容后，我们可以对视频内容进行目标检测，为了方便上手，这里采用OpenCV人脸检测作为作为实例学习。\n我们需要下载OpenCV官方已经训练好的人脸检测器数据文件:\nhttps://raw.githubusercontent.com/opencv/opencv/master/data/haarcascades/haarcascade_frontalface_alt.xml 创建检测器 创建一个检测器并载入下载的检测器数据:\nface_cascade_data = \u0026#39;haarcascade_frontalface_alt.xml\u0026#39; face_cascade = cv.CascadeClassifier() face_cascade.load(cv.samples.findFile(face_cascade_data)) 传入函数cv.samples.findFile的参数是我们下载好的检测器数据文件的路径。\n检测与标记 我们创建一个函数用于处理目标检测，并将检测结果标记描绘到图像上:\ndef face_detect(frame): gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) gray = cv.equalizeHist(gray) faces = face_cascade.detectMultiScale(gray) for x, y, w, h in faces: cv.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 3) 在将图像放入检测器前，我们可以将图像转换成灰度图cv.cvtColor(frame, cv.COLOR_BGR2GRAY)；有时为了提升效果可以对图像进行色彩均衡化操作cv.equalizeHist(gray)；使用face_cascade.detectMultiScale方法进行检测，可以使用for in循环遍历取出每一个检测到的人脸位置信息。\n结合摄像头调用 我们可以在之前的摄像头调用实例代码中应用人脸检测:\nimport cv2 as cv def face_detect(frame): gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) gray = cv.equalizeHist(gray) faces = face_cascade.detectMultiScale(gray) for x, y, w, h in faces: cv.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 3) face_cascade_data = \u0026#39;haarcascade_frontalface_alt.xml\u0026#39; face_cascade = cv.CascadeClassifier() face_cascade.load(cv.samples.findFile(face_cascade_data)) video = cv.VideoCapture(0) while video.isOpened(): ret, frame = video.read() if ret == True: face_detect(frame) cv.imshow(\u0026#39;My Video\u0026#39;, frame[:, ::-1]) if cv.waitKey(20) \u0026amp; 0xFF == ord(\u0026#39;q\u0026#39;): break else: break video.release() cv.destroyAllWindows() 下篇 影像处理・人脸识别\n"
            }
    
        ,
            {
                "id": 53,
                "href": "https://bxtkezhan.github.io/%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E5%A4%B4/",
                "title": "影像处理・网络摄像头",
                "section": "posts",
                "date" : "2021.09.26",
                "body": "返回教程主页\n上篇 影像处理・调用摄像头\n了解到如何使用OpenCV调用摄像头并显示视频内容后，我们可以尝试实现支持远程客户端的网络摄像头。我们将使用到OpenCV以及WebSockets。\nWebSockets的安装方法记载如下:\npip install websockets 服务器程序 我们在服务器上打开摄像头，然后分享给“遥远”的客户端:\nimport asyncio import websockets import cv2 as cv async def capture(websocket, path): while video.isOpened(): ret, frame = video.read() if not ret: continue _, buf = cv.imencode(\u0026#39;.jpeg\u0026#39;, frame) await websocket.send(buf.tobytes()) await asyncio.sleep(0.05) async def main(): async with websockets.serve(capture, \u0026#34;0.0.0.0\u0026#34;, 5678): await asyncio.Future() video = cv.VideoCapture(0) try: asyncio.run(main()) except KeyboardInterrupt: if video.isOpened(): video.release() 有几个地方需要说明：\nimport asyncio 我们需要引入这个异步模块来帮助处理异步问题 import websockets 需要的WebSocket模块 def capture 定义用于处理视频发送的函数，当有客户端连接时会触发「需要使用async做异步声明」 cv.imencode 将numpy数组转换成字节数据，便于被浏览器使用 websocket.send 发送视频数据，需要使用await做等待声明 asyncio.sleep 控制摄像头读取频率 websockets.serve 启动一个服务，传入参数capture，主机地址，端口号 asyncio.run 运行主程序 有关WebSockets的更多内容可以去往项目文档网站进行了解: https://websockets.readthedocs.io/en/stable/index.html\n客户端HTML 可以创建一个名为index.html的文本文件「注意.html是扩展名」，复制粘贴以下代码并保存:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;OpenCV\u0026amp;WebSocket\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;img\u0026#34;/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;script\u0026gt; var ws = new WebSocket(`ws://${location.hostname}:5678/`); var image = document.querySelector(\u0026#39;#img\u0026#39;); ws.onmessage = function (event) { image.src = URL.createObjectURL(event.data); }; \u0026lt;/script\u0026gt; 运行测试 首先，我们运行服务端程序，这与之前的代码的运行没有不同，因此不做具体说明。\n然后，我们在HTML文件所在的目录下开启一个静态文件服务器，例如:\npython3 -m http.server 这时用浏览器访问http://\u0026lt;你的局域网IP地址\u0026gt;:8000，如果不出意外，你将看到浏览器中正在显示你电脑摄像头所拍摄的影像。如果你的手机与你的电脑在同一个局域网下「例如都连接家里的路由器」，那么你可以尝试用手机浏览器进行访问。\n下篇 影像处理・目标检测\n"
            }
    
        ,
            {
                "id": 54,
                "href": "https://bxtkezhan.github.io/%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/",
                "title": "影像处理・调用摄像头",
                "section": "posts",
                "date" : "2021.09.16",
                "body": "返回教程主页\n上篇 影像处理・OpenCV简介\n影像处理免不了读取视频和调用摄像头，在OpenCV中可以使用VideoCapture工具快速完成视频读取以及摄像头调用。\n读取并播放视频 调用VideoCapture的时候如果传入一个视频文件的路径作为参数则可以读取该视频文件:\nimport cv2 as cv video = cv.VideoCapture(\u0026#39;/home/kk/影片/mytest.mp4\u0026#39;) while video.isOpened(): ret, frame = video.read() if ret == True: cv.imshow(\u0026#39;My Video\u0026#39;, frame) if cv.waitKey(100) \u0026amp; 0xFF == ord(\u0026#39;q\u0026#39;): break else: break video.release() cv.destroyAllWindows() 以字符串的形式传入一个文件路径，调用VideoCapture读取视频； 使用video.isOpened判断是否正确打开，如果是则开始循环读取； 使用video.read读取每一帧视频影像，返回的ret用于判断是否成功读取，frame为影像的numpy数组； 仍旧使用cv.imshow显示，并用cv.waitKey等待100毫秒「不一定非得用100」来控制播放速度，当接受到键盘输入q时退出； 在结束循环读写后需要记得释放视频资源video.release，以及销毁窗口cv.destroyAllWindows； 打开并读取摄像头 调用VideoCapture的时候如果传入一个整数0则可以读取电脑默认摄像头:\nimport cv2 as cv video = cv.VideoCapture(0) while video.isOpened(): ret, frame = video.read() if ret == True: cv.imshow(\u0026#39;My Video\u0026#39;, frame) if cv.waitKey(100) \u0026amp; 0xFF == ord(\u0026#39;q\u0026#39;): break else: break video.release() cv.destroyAllWindows() 传入到cv.VideoCapture的整数0可以理解为摄像头的索引编号，如果你有多个摄像头比如两个，则可以尝试使用编号：0或1；有三个摄像头，则可以尝试使用编号：0、1或2。\n下篇 影像处理・网络摄像头\n"
            }
    
        ,
            {
                "id": 55,
                "href": "https://bxtkezhan.github.io/%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86opencv%E7%AE%80%E4%BB%8B/",
                "title": "影像处理・OpenCV简介",
                "section": "posts",
                "date" : "2021.08.31",
                "body": "返回教程主页\n上篇 影像处理・操作环境准备\n下面，我们初步认识一下OpenCV这款计算机视觉处理程序开发库。在这之前需要确保成功安装它的Python版本，可以用上篇提到的pip install opencv-python命令进行安装，考虑到部分用户的网络问题，可以使用pip install opencv-python -i https://pypi.douban.com/simple切换成豆瓣源进行加速。\n图像的载入，显示以及写入 最首先的自然是图像的载入，我们引入OpenCVimport cv2 as cv，然后使用imread载入图像:\nimport cv2 as cv img = cv.imread(\u0026#39;./python.jpg\u0026#39;) print(type(img)) 给cv.imread函数传入一个图像文件路径的字符串作为参数，如果成功cv.imread将返回返回图片像素信息的numpy数组，如果失败则返回None。\n成功载入图像后我们可以使用imshow去显示它:\nif img is not None: cv.imshow(\u0026#39;hello opencv\u0026#39;, img) cv.waitKey(0) # 按键盘任意键退出 cv.imshow会打开一个窗口用于显示图像，该函数的第一个参数是窗口标题的字符串；第二个是图像的numpy数组。此外，我们还需要调用cv.waitKey(0)去阻塞程序，该函数会阻塞程序直到接收到一个键盘输入。\n使用imwrite可以将图像的numpy数组写入到图像文件:\ncv.imwrite(\u0026#39;./python2.jpg\u0026#39;, 255 - img) cv.imwrite一般接收两个参数，第一个为保存的文件路径；第二个是图像的numpy数组，我们用255减去原来的图像数组得到一个新的图像数组并保存「利于区分」。\n图像缩放 对图像进行缩放可以使用cv.resize函数:\nimg = cv.resize(img, (100, 100)) 这里我们为cv.resize传入了两个参数，第一个是原始图像的numpy数组；第二个是缩放后的宽与高，是个元祖。该函数将返回缩放后的图像数组。\n其它操作 除此之外，OpenCV还有许多功能，例如：图像裁剪，几何变换，颜色空间，阈值处理，形态学操作，角点检测，轮廓检测，目标检测…… 感兴趣的朋友可以自己上网搜索相关专题。\n下篇 影像处理・调用摄像头\n"
            }
    
        ,
            {
                "id": 56,
                "href": "https://bxtkezhan.github.io/%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/",
                "title": "影像处理・操作环境准备",
                "section": "posts",
                "date" : "2021.08.14",
                "body": "返回教程主页\n上篇 隐写术・将游戏存入图像\n本章会使用Python进行一些影像处理操作。除了需要Python3.6+外，我们还需要安装一些扩展库。\nOpenCV OpenCV是非常受欢迎的计算机视觉处理库，对Python有较好的支持，我们可以在命令行运行如下代码安装它:\npip install opencv-python numpy numpy是个高效率的数组计算工具，我们需要利用它，在命令行运行如下代码可以安装:\npip install numpy websockets 如果要将视频数据通过网络进行传输，并支持浏览器打开，那么websockets是个不错的选择，我们可以使用与之同名的库来实现:\npip install websockets Flask 为了能够使用浏览器操作websockets，我们需要构建一个简单的Web App，使用Flask可以快速完成它:\npip install Flask 下篇 影像处理・OpenCV简介\n"
            }
    
        ,
            {
                "id": 57,
                "href": "https://bxtkezhan.github.io/%E9%9A%90%E5%86%99%E6%9C%AF%E5%B0%86%E6%B8%B8%E6%88%8F%E5%AD%98%E5%85%A5%E5%9B%BE%E5%83%8F/",
                "title": "隐写术・将游戏存入图像",
                "section": "posts",
                "date" : "2021.06.12",
                "body": "返回教程主页\n上篇 隐写术・图文隐写术\n我们已经可以将文本资料通过编码成qrcode然后隐藏到载体图像。事实上Python代码也是文本资料，因此我们实际上也可以将Python代码作为文本资料隐藏到载体图像。\n考虑到具体的Python图形化界面游戏开发我们这里还没有讲到，而且较长的代码存储需要的空间也比较大可能会导致二维码识别效果降低，所以目前建议大家先尝试将简单的猜字游戏「或者类似的程序」隐写到图像中。\n由于需要的技术知识并没有增加，所以这节的操作主要交给大家自行实践。\n下篇 影像处理・操作环境准备\n"
            }
    
        ,
            {
                "id": 58,
                "href": "https://bxtkezhan.github.io/%E9%9A%90%E5%86%99%E6%9C%AF%E5%9B%BE%E6%96%87%E9%9A%90%E5%86%99%E6%9C%AF/",
                "title": "隐写术・图文隐写术",
                "section": "posts",
                "date" : "2021.06.12",
                "body": "返回教程主页\n上篇 隐写术・QRCode\n把图像隐写术与二维码技术结合就能实现将文本内容转换成二维码，然后隐藏到载体图像的图文隐写术。\n载入图像并生成二维码 首先，我们需要加载载体图像，并根据指定的文本内容生成二维码:\ndef gen_qrcode(text:str, side:int): image = qrcode.make(text) image = image.resize((side, side)) return image bg = Image.open(\u0026#39;container.jpg\u0026#39;) fg = gen_qrcode(\u0026#39;Hello Python!\u0026#39;, min(bg.size)) 为了确保我们的二维码可以完整的存入载体图像，我们需要缩放二维码使之边长不超过载体图像的最小边城。\n将二维码存入载体图像 将二维码存入载体图像的操作和之前的「隐写术・图像隐写术」操作一致。\n解析二维码 我们仍旧可以使用之前的「隐写术・图像隐写术」说道操作将二维码取出。在解析二维码时，我们可以使用pyzbar「中文编码可能会有问题」也可以直接用手机扫描。\n代码清单 from PIL import Image import numpy as np import qrcode def gen_qrcode(text:str, side:int): image = qrcode.make(text) image = image.resize((side, side)) return image def preprocess(frame:Image.Image): image = frame.convert(\u0026#39;RGB\u0026#39;) array = np.array(image) array -= array % 2 return array def to_binary(frame:Image.Image, threshold:int=127): gray = frame.convert(\u0026#39;L\u0026#39;) array = np.array(gray) binary = (array \u0026gt; threshold).astype(np.uint8) return binary def merge_image(container:np.ndarray, binary:np.ndarray): r1, c1 = container.shape[0], container.shape[1] r2, c2 = binary.shape[0], binary.shape[1] r, c = min(r1, r2), min(c1, c2) final = np.copy(container) final[:r, :c, :] += binary[:r, :c, None] return final def get_binary(frame:Image.Image): array = np.array(frame) array %= 2 array *= 255 image = Image.fromarray(array) return image bg = Image.open(\u0026#39;container.jpg\u0026#39;) fg = gen_qrcode(\u0026#39;Hello Python!\u0026#39;, min(bg.size)) container = preprocess(bg) binary = to_binary(fg) final = merge_image(container, binary) final_img = Image.fromarray(final) final_img.save(\u0026#39;merged.png\u0026#39;) merged = Image.open(\u0026#39;merged.png\u0026#39;) _binary = get_binary(merged) _binary.show() from pyzbar.pyzbar import decode for code in decode(_binary): print(code.data.decode()) 下篇 隐写术・将游戏存入图像\n"
            }
    
        ,
            {
                "id": 59,
                "href": "https://bxtkezhan.github.io/%E9%9A%90%E5%86%99%E6%9C%AFqrcode/",
                "title": "隐写术・QRCode",
                "section": "posts",
                "date" : "2021.06.12",
                "body": "返回教程主页\n上篇 隐写术・图像隐写术\n上一节我们完成了将二值化图像存储在载体图像中的操作，为了方便存储更加丰富的讯息我们可以将二维码图像作为二值化的内容图像。\n二维码的生成 使用Python的第三方二维码生成库qrcode就可以非常方便快速的生成二维码:\nimport qrcode data = \u0026#39;Hello, QRCode\u0026#39; img = qrcode.make(data) img.show() 通过qrcode.make方法可以将指定的文本内容编码成一张二维码图像，而返回的值是Pillow中的Image对象，可以很方便的使用Pillow提供的方法去编辑它。\n二维码的识别 Python当中存在一些第三方的二维码识别工具但是对Windows平台支持不好，如果你和我一样是Linux/Ubuntu用户「可以是别的Linux」，或者你使用Mac OS，那么可以尝试一款叫做pyzbar的二维码识别库。\n使用如下命令安装pyzbar:\npip install pyzbar 可以使用pyzbar提供的decode方法对一张二维码「Pillow.Image对象」进行解码:\nfrom PIL import Image from pyzbar.pyzbar import decode img = Image.open(\u0026#39;我的二维码.png\u0026#39;) print(decode(img.convert(\u0026#39;L\u0026#39;))) 在使用pyzbar.decode方法解码前最好对输入的Pillow图像进行转换得到灰度图像img.convert('L')。\n下篇 隐写术・图文隐写术\n"
            }
    
        ,
            {
                "id": 60,
                "href": "https://bxtkezhan.github.io/%E9%9A%90%E5%86%99%E6%9C%AF%E5%9B%BE%E5%83%8F%E9%9A%90%E5%86%99%E6%9C%AF/",
                "title": "隐写术・图像隐写术",
                "section": "posts",
                "date" : "2021.06.12",
                "body": "返回教程主页\n上篇 隐写术・图像处理\n在了解了一些基本的图像处理操作后，我们开始着手实现图像隐写术。\n载入准备的图像 类似信号传输中的调制操作，我们可以把像素值简单的图像作为需要隐藏的图像，而像素值丰富的图像作为载体。\n准备一张用于载体的图像「色彩内容可以相对丰富」:\n准备一张用需要被隐藏的图像「使用黑白色的文字内容」:\n在Python中载入它们:\nbg = Image.open(\u0026#39;container.jpg\u0026#39;) fg = Image.open(\u0026#39;python.jpg\u0026#39;) 对载体图像进行预处理 我们需要预处理载体图像为即将被隐藏的内容图像腾出一点点空间。在这里我们将载体图像中的每一个不为偶数的像素值减去一:\ndef preprocess(frame:Image.Image): image = frame.convert(\u0026#39;RGB\u0026#39;) array = np.array(image) array -= array % 2 return array container = preprocess(bg) frame.convert('RGB')用于确保输入图像的色彩模式为RGB通道模式。\n对内容图像进行二值化 我们将色彩简单的内容图像进行二值化，使之成为像素值仅为0与1的图像:\ndef to_binary(frame:Image.Image, threshold:int=127): gray = frame.convert(\u0026#39;L\u0026#39;) array = np.array(gray) binary = (array \u0026gt; threshold).astype(np.uint8) return binary binary = to_binary(fg) frame.convert('L')用于将输入图像转换为灰度图像。\n将二值化后的内容载入到载体图像中 在得到处理过的载体图像以及二值化的内容图像后，我们可以将其相加得到最终图像并保存到本地:\ndef merge_image(container:np.ndarray, binary:np.ndarray): r1, c1 = container.shape[0], container.shape[1] r2, c2 = binary.shape[0], binary.shape[1] r, c = min(r1, r2), min(c1, c2) final = np.copy(container) final[:r, :c, :] += binary[:r, :c, None] return final final = merge_image(container, binary) final_img = Image.fromarray(final) final_img.save(\u0026#39;merged.png\u0026#39;) 使用png格式存储图像，能够确保图像在被压缩时，隐藏的内容信息不会被抹除，且最终得到的图像文件也不会太大。\n尝试从融合后的图像中解析出内容 在完成融合操作后，我们还得通过解析内容来确认操作是否成功:\ndef get_binary(frame:Image.Image): array = np.array(frame) array %= 2 array *= 255 image = Image.fromarray(array) return image merged = Image.open(\u0026#39;merged.png\u0026#39;) _binary = get_binary(merged) _binary.show() 代码清单 from PIL import Image import numpy as np def preprocess(frame:Image.Image): image = frame.convert(\u0026#39;RGB\u0026#39;) array = np.array(image) array -= array % 2 return array def to_binary(frame:Image.Image, threshold:int=127): gray = frame.convert(\u0026#39;L\u0026#39;) array = np.array(gray) binary = (array \u0026gt; threshold).astype(np.uint8) return binary def merge_image(container:np.ndarray, binary:np.ndarray): r1, c1 = container.shape[0], container.shape[1] r2, c2 = binary.shape[0], binary.shape[1] r, c = min(r1, r2), min(c1, c2) final = np.copy(container) final[:r, :c, :] += binary[:r, :c, None] return final def get_binary(frame:Image.Image): array = np.array(frame) array %= 2 array *= 255 image = Image.fromarray(array) return image bg = Image.open(\u0026#39;container.jpg\u0026#39;) fg = Image.open(\u0026#39;python.jpg\u0026#39;) container = preprocess(bg) binary = to_binary(fg) final = merge_image(container, binary) final_img = Image.fromarray(final) final_img.save(\u0026#39;merged.png\u0026#39;) merged = Image.open(\u0026#39;merged.png\u0026#39;) _binary = get_binary(merged) _binary.show() 下篇 隐写术・QRCode\n"
            }
    
        ,
            {
                "id": 61,
                "href": "https://bxtkezhan.github.io/%E9%9A%90%E5%86%99%E6%9C%AF%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/",
                "title": "隐写术・图像处理",
                "section": "posts",
                "date" : "2021.06.12",
                "body": "返回教程主页\n上篇 隐写术・文件隐写术\n将机要讯息藏匿于没有关联的图像资料是隐写术的常见操作，为了学习这种方法，我们有必要先了解一些基本的图像处理操作。\n图像的载入与保存 Python可以通过第三方的库去实现图像的载入与保存，Pillow就是一款不错的图像处理工具库，我们可以使用它快速实现图像的载入、保存:\nfrom PIL import Image image = Image.open(\u0026#39;我的图像.png\u0026#39;) image.save(\u0026#39;我保存的图像.jpg\u0026#39;) 在使用Image.open方法打开图像后还可以使用image.show()方法去显示这张图像；在使用image.save方法的使用可以通过保存路径中指定的扩展名决定保存的图像格式。\n缩放与裁剪 有些时候原始图像的尺寸不符合要求时我们就需要主动调整图像的大小使之符合要求:\nimage1 = image.resize((100, 100)) print(image1.size) image2 = image.crop((0, 0, 100, 100)) print(image2.size) image.resize用于图像缩放，可以接收一个元祖(x, y)作为参数，元祖中元素x, y分别代表宽与高；image.crop用于裁剪图像，可以接收一个元祖(left, upper, right, lower)，元祖中的元素分别为左、上、右、下的像素位置；可以使用Image.size方法去获得调整后的图像大小。\n像素操作 虽然Pillow也支持一定程度的像素操作，但目前来看Pillow针对像素值处理的效率还是太低了。所以，为了更快更方便的处理像素值相关的数据我们将使用一款叫numpy的Python数值计算库:\nfrom PIL import Image import numpy as np image = Image.open(\u0026#39;我的图像.png\u0026#39;) array = np.array(image) print(array.shape, array.dtype) 使用np.array可以将Pillow中的Image对象转换为numpy中的多维数组类型np.ndarray，该类型的属性.shape描述其维度信息，属性.dtype描述其元素数值类型。\n下篇 隐写术・图像隐写术\n"
            }
    
        ,
            {
                "id": 62,
                "href": "https://bxtkezhan.github.io/%E9%9A%90%E5%86%99%E6%9C%AF%E6%96%87%E4%BB%B6%E9%9A%90%E5%86%99%E6%9C%AF/",
                "title": "隐写术・文件隐写术",
                "section": "posts",
                "date" : "2021.06.06",
                "body": "返回教程主页\n上篇 隐写术・操作环境准备\n维基百科: 隐写术是一门关于信息隐藏的技巧与科学，所谓信息隐藏指的是不让除预期的接收者之外的任何人知晓信息的传递事件或者信息的内容。隐写术的英文叫做Steganography，来源于特里特米乌斯的一本讲述密码学与隐写术的著作Steganographia，该书书名源于希腊语，意为「隐秘书写」。\n简易的文件隐写 我们可以使用Python的文件读写功能去实现最简单的文件隐写操作:\ndef concat(file1, file2, output): with open(output, \u0026#39;wb\u0026#39;) as of: with open(file1, \u0026#39;rb\u0026#39;) as rf: of.write(rf.read()) with open(file2, \u0026#39;rb\u0026#39;) as rf: of.write(rf.read()) if __name__ == \u0026#34;__main__\u0026#34;: import sys file1 = sys.argv[1] file2 = sys.argv[2] output = sys.argv[3] concat(file1, file2, output) print(f\u0026#39;{file1} + {file2} -\u0026gt; {output}\u0026#39;) 可以将上述代码保存到本地，这里假设保存为文件concat.py。\n下面我们准备一张图片run.jpg和一个文本文件text.txt来进行实验:\n为了把text.txt隐藏到run.jpg中，我们需要对text.txt进行打包，这里使用ZIP工具进行压缩打包得到text.zip:\n然后我们在命令行中运行如下代码实现隐写操作:\npython3 concat.py run.jpg text.zip out.jpg 如图，我们得到了一个名为out.jpg的图像文件，我们可以正常打开它；但是如果我们将其扩展名修改为.zip时会发现我们可以将其作为压缩包打开:\n下篇 隐写术・图像处理\n"
            }
    
        ,
            {
                "id": 63,
                "href": "https://bxtkezhan.github.io/%E9%9A%90%E5%86%99%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/",
                "title": "隐写术・操作环境准备",
                "section": "posts",
                "date" : "2021.06.06",
                "body": "返回教程主页\n上篇 网络篇・并发端口扫描\n本章会使用Python进行一些图像处理操作。除了需要Python3.6+外，我们还需要安装一些扩展库。\nPillow Pillow是Python当中非常受欢迎的图像处理库，我们可以在命令行运行如下代码安装它:\npip install Pillow numpy numpy常常用于多维数组的数值计算，我们在处理像素数值的时候会用到它，在命令行运行如下代码可以安装:\npip install numpy python-qrcode python-qrcode用于生成二维码图像，使用如下命令行指令进行安装:\npip install qrcode 下篇 隐写术・文件隐写术\n"
            }
    
        ,
            {
                "id": 64,
                "href": "https://bxtkezhan.github.io/%E7%BD%91%E7%BB%9C%E7%AF%87%E5%B9%B6%E5%8F%91%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/",
                "title": "网络篇・并发端口扫描",
                "section": "posts",
                "date" : "2021.05.22",
                "body": "返回教程主页\n上篇 网络篇・端口扫描\n上一节我们实现了一个简单的端口扫描工具，接下来我们把它升级成为多线程版本。\n批量扫描 虽然端口扫描属于IO密集型操作，但是由于我们的测试目标是本机，所以有必要对线程切换导致的效率损失问题进行处理。在这里我们使用批量分配任务到每一个线程的方法来进行处理。\n我们首先定义一个批量处理函数:\nfrom socket import socket, AF_INET, SOCK_STREAM from threading import Thread def batch_test(host:str, ports:range): for port in ports: s = socket(AF_INET, SOCK_STREAM) s.settimeout(10) if not s.connect_ex((host, port)): print(f\u0026#39;Opened Port: {port}\u0026#39;) 分批并发配 将任务进行等分「近似」并分发给每一个线程:\ndef test_ports(host:str, ports:range, thread_num:int): count = ports.stop - ports.start batchsize = count // thread_num works = [] for thread_id in range(thread_num): start = ports.start + thread_id * batchsize stop = start + batchsize if thread_id == thread_num - 1: stop = ports.stop t = Thread(target=batch_test, args=(host, range(start, stop))) t.start() works.append(t) for work in works: work.join() 程序入口 根据用户输入设置函数参数并运行程序:\nif __name__ == \u0026#34;__main__\u0026#34;: import sys host = sys.argv[1] start = int(sys.argv[2]) stop = int(sys.argv[3]) thread_num = int(sys.argv[4]) test_ports(host, range(start, stop), thread_num) 下篇 隐写术・操作环境准备\n"
            }
    
        ,
            {
                "id": 65,
                "href": "https://bxtkezhan.github.io/%E7%BD%91%E7%BB%9C%E7%AF%87%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/",
                "title": "网络篇・端口扫描",
                "section": "posts",
                "date" : "2021.05.22",
                "body": "返回教程主页\n上篇 网络篇・UDP通信\n维基百科: 端口扫描工具（Port Scanner）指用于探测服务器或主机开放端口情况的工具。常被计算机管理员用于确认安全策略，同时被攻击者用于识别目标主机上的可运作的网络服务。端口扫描定义是客户端向一定范围的服务器端口发送对应请求，以此确认可使用的端口。虽然其本身并不是恶意的网络活动，但也是网络攻击者探测目标主机服务，以利用该服务的已知漏洞的重要手段。端口扫描的主要用途仍然只是确认远程机器某个服务的可用性。\nTCP连接测试 在实现TCP通讯的时候，我们知道可以在客户端socket中输入主机名和端口号码来连接服务器。同样的，我们也可以使用这种方法来尝试连接一定范围的服务器端口:\nfrom socket import socket, AF_INET, SOCK_STREAM ports = range(10, 10000) for port in ports: s = socket(AF_INET, SOCK_STREAM) s.settimeout(10) if not s.connect_ex((\u0026#39;localhost\u0026#39;, port)): print(f\u0026#39;Opened Port: {port}\u0026#39;) 我们扫描10到10000「不包含10000」的端口，使用s.connect_ex进行连接，如果连接成功则返回0。通过if not进行判别并输出主机localhost开放的端口，其中主机名称localhost可以替换成其他主机的名称或者IP地址。\n下篇 网络篇・并发端口扫描\n"
            }
    
        ,
            {
                "id": 66,
                "href": "https://bxtkezhan.github.io/%E7%BD%91%E7%BB%9C%E7%AF%87udp%E9%80%9A%E4%BF%A1/",
                "title": "网络篇・UDP通信",
                "section": "posts",
                "date" : "2021.05.22",
                "body": "返回教程主页\n上篇 网络篇・TCP通信\n之前我们尝试了TCP服务器与客户端的通讯，现在我们要实现一个服务器，通过UDP协议与客户端程序通讯。\nsocketserver 和TCP服务器的实现一样，我们使用Python的socketserver库就可以快速实现一个简单的报时务器:\nfrom socketserver import BaseRequestHandler, UDPServer import time class TimeHandler(BaseRequestHandler): def handle(self): print(\u0026#39;Got connection from\u0026#39;, self.client_address) msg, sock = self.request resp = time.ctime() sock.sendto(resp.encode(), self.client_address) if __name__ == \u0026#39;__main__\u0026#39;: serv = UDPServer((\u0026#39;\u0026#39;, 8000), TimeHandler) serv.serve_forever() 这里我们使用成功self.request获取的套接字sock发送时间刀指定客户端self.client_address。\n下面我们通过UDP连接的方式去获取服务器报时:\n\u0026gt;\u0026gt;\u0026gt; from socket import socket, AF_INET, SOCK_DGRAM \u0026gt;\u0026gt;\u0026gt; s = socket(AF_INET, SOCK_DGRAM) \u0026gt;\u0026gt;\u0026gt; s.sendto(b\u0026#39;\u0026#39;, (\u0026#39;localhost\u0026#39;, 8000)) 0 \u0026gt;\u0026gt;\u0026gt; s.recvfrom(8192) (b\u0026#39;Sun May 23 21:17:54 2021\u0026#39;, (\u0026#39;127.0.0.1\u0026#39;, 8000)) \u0026gt;\u0026gt;\u0026gt; ThreadingUDPServer UDPServer可以快速实现一个简单的服务器，但默认情况下只会得到一个单线程的服务器，不能同时连接多个客户端。使用ThreadingUDPServer则可以快速实现多线程的服务器:\nfrom socketserver import ThreadingUDPServer if __name__ == \u0026#39;__main__\u0026#39;: serv = ThreadingUDPServer((\u0026#39;\u0026#39;, 8000), TimeHandler) serv.serve_forever() 下篇 网络篇・端口扫描\n"
            }
    
        ,
            {
                "id": 67,
                "href": "https://bxtkezhan.github.io/%E7%BD%91%E7%BB%9C%E7%AF%87tcp%E9%80%9A%E4%BF%A1/",
                "title": "网络篇・TCP通信",
                "section": "posts",
                "date" : "2021.05.22",
                "body": "返回教程主页\n上篇 网络篇・Web爬虫\n现在我们要实现一个服务器，通过TCP协议与客户端程序通讯。\nsocketserver 我们使用Python的socketserver库就可以快速实现一个简单的应答服务器:\nfrom socketserver import BaseRequestHandler, TCPServer class EchoHandler(BaseRequestHandler): def handle(self): print(\u0026#39;Got connection from\u0026#39;, self.client_address) while True: msg = self.request.recv(8192) if not msg: break self.request.send(msg) if __name__ == \u0026#39;__main__\u0026#39;: serv = TCPServer((\u0026#39;\u0026#39;, 8000), EchoHandler) serv.serve_forever() 在这段代码中，我们定义了一个特殊的处理类EchoHandler，实现了一个handle()方法，用来为客户端连接服务。self.request属性用于获处理客户端socket，client_address为客户端地址。将EchoHandler传给TCPServer并指定8000端口号，我们就能得到一个服务器实例serv，运行方法serv.serve_forever可以启动它「如果想关停可以在命令行中敲击快捷键ctrl + c」。\n为了测试这个服务器，我们还需要创建客户端socket去连接它:\n\u0026gt;\u0026gt;\u0026gt; from socket import socket, AF_INET, SOCK_STREAM \u0026gt;\u0026gt;\u0026gt; s = socket(AF_INET, SOCK_STREAM) \u0026gt;\u0026gt;\u0026gt; s.connect((\u0026#39;localhost\u0026#39;, 8000)) \u0026gt;\u0026gt;\u0026gt; s.send(\u0026#39;Hello\u0026#39;.encode()) 5 \u0026gt;\u0026gt;\u0026gt; s.recv(8192).decode() \u0026#39;Hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; ThreadingTCPServer TCPServer可以快速实现一个简单的服务器，但默认情况下只会得到一个单线程的服务器，不能同时连接多个客户端。使用ThreadingTCPServer则可以快速实现多线程的服务器:\nfrom socketserver import BaseRequestHandler from socketserver import ThreadingTCPServer class EchoHandler(BaseRequestHandler): def handle(self): print(\u0026#39;Got connection from\u0026#39;, self.client_address) while True: msg = self.request.recv(8192) if not msg: break self.request.send(msg) if __name__ == \u0026#39;__main__\u0026#39;: serv = ThreadingTCPServer((\u0026#39;\u0026#39;, 8000), EchoHandler) serv.serve_forever() 使用两个客户端socket进行测试:\n\u0026gt;\u0026gt;\u0026gt; s1 = socket(AF_INET, SOCK_STREAM) \u0026gt;\u0026gt;\u0026gt; s2 = socket(AF_INET, SOCK_STREAM) \u0026gt;\u0026gt;\u0026gt; s1.connect((\u0026#39;localhost\u0026#39;, 8000)) \u0026gt;\u0026gt;\u0026gt; s2.connect((\u0026#39;localhost\u0026#39;, 8000)) \u0026gt;\u0026gt;\u0026gt; s1.send(b\u0026#39;Hello1\u0026#39;) 6 \u0026gt;\u0026gt;\u0026gt; s2.send(b\u0026#39;Hello2\u0026#39;) 6 \u0026gt;\u0026gt;\u0026gt; s1.recv(8192) b\u0026#39;Hello1\u0026#39; \u0026gt;\u0026gt;\u0026gt; s2.recv(8192) b\u0026#39;Hello2\u0026#39; \u0026gt;\u0026gt;\u0026gt; 下篇 网络篇・UDP通信\n"
            }
    
        ,
            {
                "id": 68,
                "href": "https://bxtkezhan.github.io/%E7%BD%91%E7%BB%9C%E7%AF%87web%E7%88%AC%E8%99%AB/",
                "title": "网络篇・Web爬虫",
                "section": "posts",
                "date" : "2021.05.22",
                "body": "返回教程主页\n上篇 网络篇・HTTP协议\n我们学习了如何使用Python访问网络上的HTTP资源，下面我们将使用一个叫煎蛋的网站来入手学习Web爬虫技术。\n目标介绍 我们需要使用Python获取煎蛋网中的宠物图像资源，实现批量下载宠物图像的功能。\ngraph TB Site[煎蛋网 jandan.net/zoo] -- HTTP请求 --\u003e Page[网页 HTML] Page -- 字符串查找 --\u003e Images[图像连接 URL] Images -- HTTP请求 --\u003e Storage[本地图像 JPG/PNG/...] 网页元素查找 我们可以使用浏览器自带的Web开发辅助工具来辅助爬虫项目的开发:\n在网页 https://jandan.net/zoo 页面右键点击元素审查「或者输入快捷键Ctr+Shift+I」开启辅助工具； 点击挑选页面元素的工具「或者输入快捷键Ctr+Shift+C」； 尝试点击页面中的图像然后观察元素面板的变化，就可以找到对应的图像资源； 经过反复的测试，我们得知大概有两种形式「如果考虑gif格式可能会更复杂」的目标图像:\n原图图像链接的格式 //wx4.sinaimg.cn/large/xxx.xxx 展示图像链接的格式 //wx4.sinaimg.cn/mw600/xxx.xxx 获取网页页面 使用urllib访问该网站时注意要自定义headers中的User-Agent项:\nfrom urllib.request import Request, urlopen url = \u0026#39;https://jandan.net/zoo\u0026#39; headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Chrome hkw 031 web\u0026#39;} request = Request(url, headers=headers) html = urlopen(request).read().decode() 搜索原图链接 使用正则表达式匹配查询原图链接:\nimport re pattern = re.compile(r\u0026#39;//wx4.sinaimg.cn/large/[^\u0026#34;]+\u0026#39;) links = re.findall(pattern, html) 批量下载图像 遍历links并构建Request对象请求图像资源:\nfor i, link in enumerate(links): request = Request(f\u0026#39;https:{link}\u0026#39;, headers=headers) ext = link.split(\u0026#39;.\u0026#39;)[-1] data = urlopen(request).read() with open(f\u0026#39;{i}.{ext}\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(data) print(i, link) 下篇 网络篇・TCP通信\n"
            }
    
        ,
            {
                "id": 69,
                "href": "https://bxtkezhan.github.io/%E7%BD%91%E7%BB%9C%E7%AF%87http%E5%8D%8F%E8%AE%AE/",
                "title": "网络篇・HTTP协议",
                "section": "posts",
                "date" : "2021.05.11",
                "body": "返回教程主页\n上篇 网络篇・操作环境准备\nHTTP是一种能够获取如HTML这样的网络资源的protocol(通讯协议)。它是在Web上进行数据交换的基础，是一种client-server协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。\n客户端和服务端通过交换各自的消息（与数据流正好相反）进行交互。由像浏览器这样的客户端发出的消息叫做requests，被服务端响应的消息叫做responses。\n作为客户端与HTTP服务交互 对于简单的操作，通常可以使用urllib.request模块。例如发送一个简单的HTTP/HTTPS请求，获取远程服务上的一张图像:\nfrom urllib import request url = \u0026#39;https://www.python.org/static/img/python-logo.png\u0026#39; resp = request.urlopen(url) with open(\u0026#39;python-logo.png\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(resp.read()) 以下是下载的图像:\n使用GET方法传递参数 如果需要在GET方法中传递参数可以这样:\nfrom urllib import request, parse # 设置基础URL url = \u0026#39;http://httpbin.org/get\u0026#39; # 使用字典结构存储请求参数 parms = { \u0026#39;name1\u0026#39; : \u0026#39;value1\u0026#39;, \u0026#39;name2\u0026#39; : \u0026#39;value2\u0026#39; } # 对请求进行编码 querystring = parse.urlencode(parms) # 构造GET请求 resp = request.urlopen(url+\u0026#39;?\u0026#39; + querystring) data = resp.read().decode() print(data) 运行结果:\n{ \u0026#34;args\u0026#34;: { \u0026#34;name1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;name2\u0026#34;: \u0026#34;value2\u0026#34; }, \u0026#34;url\u0026#34;: \u0026#34;http://httpbin.org/get?name1=value1\u0026amp;name2=value2\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;identity\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, ... 省略 ... 使用POST方法传递参数 如果需要使用POST方法在请求主体中发送查询参数，可以将参数编码后作为可选参数提供给urlopen函数:\nfrom urllib import request, parse url = \u0026#39;http://httpbin.org/post\u0026#39; parms = { \u0026#39;name1\u0026#39; : \u0026#39;value1\u0026#39;, \u0026#39;name2\u0026#39; : \u0026#39;value2\u0026#39; } querystring = parse.urlencode(parms) # 设置POST参数，构造POST请求 resp = request.urlopen(url, querystring.encode()) data = resp.read().decode() print(data) 运行结果:\n{ \u0026#34;args\u0026#34;: {}, \u0026#34;data\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;files\u0026#34;: {}, \u0026#34;form\u0026#34;: { \u0026#34;name1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;name2\u0026#34;: \u0026#34;value2\u0026#34; }, \u0026#34;headers\u0026#34;: { \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;identity\u0026#34;, \u0026#34;Content-Length\u0026#34;: \u0026#34;25\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, ... 省略 ... 自定义HTTP请求Headers 如果需要在发出的请求中提供一些自定义的HTTP头，例如修改user-agent字段,可以创建一个包含字段值的字典，并创建一个Request实例然后将其传给urlopen:\nfrom urllib import request, parse url = \u0026#39;http://httpbin.org/post\u0026#39; parms = { \u0026#39;name1\u0026#39; : \u0026#39;value1\u0026#39;, \u0026#39;name2\u0026#39; : \u0026#39;value2\u0026#39; } querystring = parse.urlencode(parms) # 添加额外的Headers信息 headers = { \u0026#39;User-agent\u0026#39; : \u0026#39;none/ofyourbusiness\u0026#39;, \u0026#39;Spam\u0026#39; : \u0026#39;Eggs\u0026#39; } req = request.Request(url, querystring.encode(), headers=headers) resp = request.urlopen(req) data = resp.read().decode() print(data) 运行结果:\n{ \u0026#34;args\u0026#34;: {}, \u0026#34;data\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;files\u0026#34;: {}, \u0026#34;form\u0026#34;: { \u0026#34;name1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;name2\u0026#34;: \u0026#34;value2\u0026#34; }, \u0026#34;headers\u0026#34;: { \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;identity\u0026#34;, \u0026#34;Content-Length\u0026#34;: \u0026#34;25\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, \u0026#34;Spam\u0026#34;: \u0026#34;Eggs\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;none/ofyourbusiness\u0026#34;, ... 省略 ... 下篇 网络篇・Web爬虫\n"
            }
    
        ,
            {
                "id": 70,
                "href": "https://bxtkezhan.github.io/%E7%BD%91%E7%BB%9C%E7%AF%87%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/",
                "title": "网络篇・操作环境准备",
                "section": "posts",
                "date" : "2021.05.11",
                "body": "返回教程主页\n上篇 密码篇・PyCryptodome示例「扩展」\n本章会使用Python进行一些网络相关的操作。除了需要安装Python外，我们还需要使用Chrome「可以用Chromium替代」或Firefox浏览器进行辅助。\nPython3.6+ Chrome / Chromium / Firefox 计算机可以访问互联网 下篇 网络篇・HTTP协议\n"
            }
    
        ,
            {
                "id": 71,
                "href": "https://bxtkezhan.github.io/%E5%AF%86%E7%A0%81%E7%AF%87pycryptodome%E7%A4%BA%E4%BE%8B%E6%89%A9%E5%B1%95/",
                "title": "密码篇・PyCryptodome示例「扩展」",
                "section": "posts",
                "date" : "2021.05.06",
                "body": "返回教程主页\n上篇 密码篇・并行密码猜解\nPyCryptodome是一个低级密码学原语的独立Python包，它支持Python2.6、Python2.7以及Python3.4或更新的版本，另外还包括PyPy。\n安装PyCryptodome 可以使用如下命令进行在线安装:\npip install pycryptodome 运行如下命令查看版本号:\npython3 -c \u0026#34;import Crypto;print(Crypto.__version__)\u0026#34; # 3.10.1 对称加密「AES标准」 我们可以使用PyCryptodome实现AES标准的对称加密与解密:\nfrom Crypto.Cipher import AES from Crypto.Random import get_random_bytes text = \u0026#39;你好吗？\u0026#39; # 加密 key = get_random_bytes(16) cipher = AES.new(key, AES.MODE_EAX) ciphertext = cipher.encrypt(text.encode()) with open(\u0026#39;encrypted.bin\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(cipher.nonce) f.write(ciphertext) # 解密 with open(\u0026#39;encrypted.bin\u0026#39;, \u0026#39;rb\u0026#39;) as f: nonce = f.read(16) ciphertext = f.read() cipher = AES.new(key, AES.MODE_EAX, nonce) text = cipher.decrypt(ciphertext).decode() print(text) 在加密时，先用get_random_bytes函数生成16个字节「128位」的随机密钥；然后实例化EAX模式的AES加密模型AES.new并对文本进行加密cipher.encrypt；在加密完成后将模型cipher的随机数与密文一并保存或传送；\n在解密时，先读取随机参数nonce与密文ciphertext；然后实例化EAX模式的AES加密模型AES.new并对文本进行解密cipher.decrypt，在解密后的明文通过decode就能转换成可读的文本形式。\n公钥加密的密钥生成「RSA算法」 使用PyCryptodome的公钥加密模块可以快速实现私钥与公钥的生成:\nfrom Crypto.PublicKey import RSA key = RSA.generate(2048) private_key = key.export_key() with open(\u0026#39;private.pem\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(private_key) public_key = key.publickey().export_key() with open(\u0026#39;receiver.pem\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(public_key) 使用RSA.generate方法生成RSA密钥；运行key.export_key方法导出私钥；运行key.publickey().export_key方法导出公钥。\n公钥加密的加密与解密「RSA算法」 使用公钥加密方法传送用于对称加密的密钥:\nfrom Crypto.PublicKey import RSA from Crypto.Random import get_random_bytes from Crypto.Cipher import PKCS1_OAEP session_key = get_random_bytes(16) print(session_key) # 公钥加密 with open(\u0026#39;receiver.pem\u0026#39;, \u0026#39;rb\u0026#39;) as f: recipient_key = RSA.import_key(f.read()) cipher_rsa = PKCS1_OAEP.new(recipient_key) enc_session_key = cipher_rsa.encrypt(session_key) # 私钥解密 with open(\u0026#39;private.pem\u0026#39;, \u0026#39;rb\u0026#39;) as f: private_key = RSA.import_key(f.read()) cipher_rsa = PKCS1_OAEP.new(private_key) dec_session_key = cipher_rsa.decrypt(enc_session_key) print(dec_session_key) 在加密时，使用公钥recipient_key作为参数创建RSA算法模型cipher_rsa；并使用cipher_rsa.encrypt方法进行加密；\n在解密时，使用私钥private_key作为参数创建RSA算法模型cipher_rsa；并使用cipher_rsa.decrypt方法进行解密。\n下篇 网络篇・操作环境准备\n"
            }
    
        ,
            {
                "id": 72,
                "href": "https://bxtkezhan.github.io/%E5%AF%86%E7%A0%81%E7%AF%87%E5%B9%B6%E8%A1%8C%E5%AF%86%E7%A0%81%E7%8C%9C%E8%A7%A3/",
                "title": "密码篇・并行密码猜解",
                "section": "posts",
                "date" : "2021.05.02",
                "body": "返回教程主页\n上篇 密码篇・密码猜解\n在上一节中我们实现了简单的ZIP压缩包密码猜解。为了充分利用计算机的性能我们可以同时使用多个CPU核心参与破译，这一节中我们将实现多核心版本或者称为并行版本的密码猜解程序。\n代码清单在末尾，我们先看一下运行效果，然后对程序的各部分进行介绍:\npython3 zip_decrypt_parallel.py password.dict myzipfile.zip 4 password is admin 整体结构 import zipfile from multiprocessing import Queue, Process def load_passwords(filename:str): # 省略 def check_passwords(filename:str, passwords:str, queue:Queue): # 省略 def main(password_dict:str, zip_filename:str, process_num:int): # 省略 if __name__ == \u0026#39;__main__\u0026#39;: # 省略 首先引入zipfile模块以及multiprocessing模块中的Queue与Process类:\nzipfile用于处理ZIP文件 Queue用于处理进程中的数据传输 Process用于启动进程来运行函数 然后定义了三个函数:\nload_passwords函数用于加载密码字典； check_passwords函数用于猜解密码； main函数作为程序的主体函数； 最后通过判断该脚本是否为入口来运行程序。\n程序入口 if __name__ == \u0026#39;__main__\u0026#39;: import sys password_dict = sys.argv[1] zip_filename = sys.argv[2] process_num = int(sys.argv[3]) password = main(password_dict, zip_filename, process_num) if password: print(\u0026#39;password is\u0026#39;, password) else: print(\u0026#39;no find password\u0026#39;) 我们通过变量__name__判断当前脚本是否为程序入口:\n如果__name__ == '__main__'为True则是入口； 如果__name__ == '__main__'为False则不是； 引入sys模块，使用sys.argv来获取参数:\nsys.argv[0]脚本文件名； sys.argv[1]第一个参数，用于指定字典文件； sys.argv[2]第二个参数，用于指定ZIP文件； sys.argv[3]第三个参数，用于设置进程数量； 获得参数后我们将其传入主体函数main中进行调用，然后根据main函数的返回结果password来打印输出。\n载入字典并启动进程 def main(password_dict:str, zip_filename:str, process_num:int): passwords = load_passwords(password_dict) queue = Queue(maxsize=process_num) batch_size = len(passwords) // process_num processes = [] for i in range(process_num): limit_l = i * batch_size limit_r = limit_l + batch_size limit_r = limit_r if i \u0026lt; process_num - 1 else None batches = passwords[limit_l:limit_r] process = Process( target=check_passwords, args=(zip_filename, batches, queue)) process.start() processes.append(process) # 省略 进入main函数后，我们使用load_passwords载入字典文件；然后创建一个队列queue「队列的最大长度可以设置为进程数量process_num」；将密码均分到每一个进程，得到单个进程应该负担的密码数量为batch_size。\n使用一个for启动进程来猜解密码。将passwords进行切片得到batches。创建Process对象并使用start方法启动进程。\n密码猜解函数 def check_passwords(filename:str, passwords:str, queue:Queue): with zipfile.ZipFile(filename) as zf: for password in passwords: try: zf.extractall(pwd=password.encode()) except RuntimeError: continue queue.put(password) return queue.put(\u0026#39;\u0026#39;) 逐一验证密码是否正确，如果正确则在队列中放入密码queue.put(password)并退出函数；如果最终没有找到密码则在队列中放入空字符串queue.put('')并结束函数。\n从队列中获取消息 def main(password_dict:str, zip_filename:str, process_num:int): # 省略 password = \u0026#39;\u0026#39; count = 0 while count \u0026lt; process_num: password = queue.get() count += 1 if password: break for process in processes: if process.is_alive(): process.terminate() return password 使用队列的queue.get方法可以取出队列中的消息，且当队列中没有消息时，该方法将持续等待，直到有新消息被放入队列。调用queue.get的次数不能大于process_num否则如果没有在字典中发现正确的密码程序将不会退出。\n最后我们需要使用process.terminate方法结束仍然在运行的进程。\n代码清单: import zipfile from multiprocessing import Queue, Process def load_passwords(filename:str): with open(filename) as f: passwords = f.read().splitlines() return passwords def check_passwords(filename:str, passwords:str, queue:Queue): with zipfile.ZipFile(filename) as zf: for password in passwords: try: zf.extractall(pwd=password.encode()) except RuntimeError: continue queue.put(password) return queue.put(\u0026#39;\u0026#39;) def main(password_dict:str, zip_filename:str, process_num:int): passwords = load_passwords(password_dict) queue = Queue(maxsize=process_num) batch_size = len(passwords) // process_num processes = [] for i in range(process_num): limit_l = i * batch_size limit_r = limit_l + batch_size limit_r = limit_r if i \u0026lt; process_num - 1 else None batches = passwords[limit_l:limit_r] process = Process( target=check_passwords, args=(zip_filename, batches, queue)) process.start() processes.append(process) password = \u0026#39;\u0026#39; count = 0 while count \u0026lt; process_num: password = queue.get() count += 1 if password: break for process in processes: if process.is_alive(): process.terminate() return password if __name__ == \u0026#39;__main__\u0026#39;: import sys password_dict = sys.argv[1] zip_filename = sys.argv[2] process_num = int(sys.argv[3]) password = main(password_dict, zip_filename, process_num) if password: print(\u0026#39;password is\u0026#39;, password) else: print(\u0026#39;no find password\u0026#39;) 下篇 密码篇・PyCryptodome示例「扩展」\n"
            }
    
        ,
            {
                "id": 73,
                "href": "https://bxtkezhan.github.io/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80linux/x86-64%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/",
                "title": "汇编语言「Linux/x86-64」・代码解析",
                "section": "posts",
                "date" : "2021.05.01",
                "body": "上一节中我们编译运行了一段NASM汇编代码，接下来我们将针对上一节的代码进行解析，了解一些具体的汇编知识。\n程序结构 我们先将上一节中的代码通过调整变成如下形式:\nglobal\t_start section\t.text _start:\tmov\trax, 1 mov\trdi, 1 mov\trsi, message mov\trdx, 13 syscall mov\trax, 60 xor\trdi, rdi syscall section\t.data message:\tdb\t\u0026#34;Hello, World\u0026#34;, 10 然后再整理成表格形式:\n主程序中需要指定代码从哪里开始运行，做法是设置_start标签并使用global将其暴露给汇编器；程序由指令和段组成，常见的段有代码段.text、数据段.data；指令语句主要由指令或指令+操作数组成，例如:mov rax, 1。\n通常我们会在代码段声明语句section .text后接上入口标签_start:并开始编写一系列的指令操作；对于数据段声明语句section .data，我们会在其后接上声明的数据以及对应的标签。\n操作指令 NASM的操作指令非常多，但是我们并不需要全部掌握，以下列举最常见的指令:\nmov x, y 将y的值给到x； and x, y 将x、y进行与运算，把结果给到x； or x, y 将x、y进行或运算，把结果给到x； xor x, y 将x、y进行亦或运算，把结果给到x； add x, y 将y累加到x； sub x, y 从x中减去y； inc x 让x自增1； dec x 让x自减1； 寄存器 寄存器主要用于存取数值，可以被当作高级程序语言中的数值变量来使用。\n当我们想进行64位数值操作的时候，我们常会使用英文字母r开头的寄存器，可以初步理解为64位的整型变量:\nRAX RCX RDX RBX RSP RBP RSI RDI 当我们想进行32位数值操作的时候，我们常使用英文字母e开头的寄存器，可以初步理解为32位的整型变量:\nEAX ECX EDX EBX ESP EBP ESI EDI 把64位寄存器的首字母r去掉，或者把32位寄存器的首字母e去掉则变为16位的寄存器，可以理解为16位的整型变量:\nAX CX DX BX SP BP SI DI 可以将16位的寄存器拆分为两个8位的寄存器，高位的部分称作高8位寄存器，低位的部分称作低8位寄存器。\n常见低8位寄存器:\nAL CL DL BL SPL BPL SIL DIL 常见高8位寄存器:\nAH CH DH BH 下面，我们类比C语言，使用NASM代码来实现对应的操作。\n有C语言如下:\nchar c; c = \u0026#39;a\u0026#39;; 变换成NASM:\nmov al, \u0026#39;a\u0026#39; 有C语言如下:\nc += 1; 变换成NASM:\nadd al, 1 内存寻址 由于寄存器数量有限，在处理较为复杂的数据结构时，我们需要利用内存来完成数据存取。\n在汇编中，我们可以指定一段内存地址，然后写入或者读取一段数据。通过汇编语言的寻址操作，我们可以得到目标地址:\n[数字] [寄存器] [寄存器 + 数字] [寄存器 + 寄存器*scale] scale 可以是 1, 2, 4, 8 [寄存器 + 寄存器*scale + 数字] 数字指的是偏移量，普通的寄存器被称作基址寄存器，寄存器*scale被称作索引。\n示例:\n[123] 偏移 [rbp] 基址 [rbx - 8] 基址 + 偏移量 -8「反向偏移8个单位」 [rcx + rsi*4] 基址 + 索引*scale [rbp + rdx] scale为1可以省略 [rax + rdi*8 + 500] 完整的写法 [rbx + message] 可以使用标签作为偏移量，这使得标签具备变量名的作用 立即数操作 在代码中我们可以直接使用数值，例如: 10进位的100；16进位的0xff；2进位的0b11……，有个好消息是我们仍旧可以使用字符「编译器会转换为ascii对应的数字，本质上也是数字的一种写法」。\n下面我们修改之前的代码，使用寻址操作将输出字符串Hello, World变为小写的hello, world，我们仅需要通过寻址修改两个字符:\nglobal _start section .text _start: ; 将偏移量交给rax mov rax, message ; 给rax所在的地址赋值\u0026#39;h\u0026#39;，需要声明是在字节范围进行的操作 mov byte [rax], \u0026#39;h\u0026#39; ; 给rax+7所在的地址赋值\u0026#39;w\u0026#39;，需要声明是在字节范围进行的操作 mov byte [rax + 7], \u0026#39;w\u0026#39; mov rax, 1 mov rdi, 1 mov rsi, message mov rdx, 13 syscall mov rax, 60 xor rdi, rdi syscall section .data message: db \u0026#34;Hello, World\u0026#34;, 10 系统调用 在C语言中我们常使用printf函数打印字符串，然而这个函数并不是由我们自己完成，一般来说系统库会为我们提供他。在汇编当中我们也可以使用类似的由系统提供的工具，在64位的NASM中称其为系统调用syscall。\n在我们的示例代码中有两次使用了系统调用。\n第一次是打印输出字符串:\nmov rax, 1 mov rdi, 1 mov rsi, message mov rdx, 13 syscall syscall前的寄存器操作是在设定我们以何种方式进行系统调用。rax的值决定使用哪一个系统调用，1对应的就是写入操作；此时rdi设置为1表示标准输出；rsi则存放字符串地址；rdx记录字符串长度。\n第二次是结束程序，相当于exit(0):\nmov rax, 60 xor rdi, rdi syscall 当rax的值为60时表示调用退出操作；此时rdi为0表示以0号状态进行退出，就像C语言中exit(0);。\n定义或声明数据 我们将数据的定义或声明放在数据段中，它的形式是这样: 标签: 类型 值。\ndb用于定义字节byte，例如:\nmessage: db \u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39; \u0026#39;, \u0026#34;World\u0026#34;, 10 ; dw用于定义字word，例如:\nnumber_dw: dw 1, 2, 3 dd用于定义双字double word，例如:\nnumber_dd: dd 1, 2, 3 "
            }
    
        ,
            {
                "id": 74,
                "href": "https://bxtkezhan.github.io/%E5%AF%86%E7%A0%81%E7%AF%87%E5%AF%86%E7%A0%81%E7%8C%9C%E8%A7%A3/",
                "title": "密码篇・密码猜解",
                "section": "posts",
                "date" : "2021.04.25",
                "body": "返回教程主页\n上篇 密码篇・实际应用\n几乎所有成熟的商用密码都能经受严格的密码破解分析，一般来说想要对一个加密的数据进行破译最简单的方法就是直接猜测密钥，如果条件允许甚至可以进行大量尝试。为了提高破译效率可以先准备好大量的可能性较高的密钥，然后依次遍历猜测密钥，这种做法有个名词叫“字典爆破”。\nZIP压缩文件读写 ZIP压缩包是被广泛使用的具备加密功能的文件类型，我们可以从爆破ZIP压缩文件入手学习如何使用Python进行“字典爆破”，不过在这之前我们得掌握ZIP压缩文件的读写操作:\nimport zipfile with zipfile.ZipFile(\u0026#39;myzipfile.zip\u0026#39;, \u0026#39;w\u0026#39;) as zf: zf.write(\u0026#39;message.txt\u0026#39;) 引入zipfile模块，将当前目录下的message.txt文件写入到 myzipfile.zip压缩包中。\nimport zipfile with zipfile.ZipFile(\u0026#39;myzipfile.zip\u0026#39;) as zf: print(zf.read(\u0026#39;message.txt\u0026#39;).decode()) 从myzipfile.zip压缩包中读入message.txt文件并打印输出。\nimport zipfile with zipfile.ZipFile(\u0026#39;myzipfile.zip\u0026#39;) as zf: zf.extractall() 解压myzipfile.zip中所有的文件。\n遍历字典猜解密码 首先我们准备一份密码字典:\njojo kk python password admin somebody gogogo bxtkezhan 然后我们随便选择其中一个密码用来制作加密的ZIP压缩包，我这边使用admin，然后运行如下Python代码进行密码猜解:\nimport zipfile with open(\u0026#39;password.dict\u0026#39;) as f: passwords = f.read().splitlines() with zipfile.ZipFile(\u0026#39;myzipfile.zip\u0026#39;) as zf: for password in passwords: try: zf.extractall(pwd=password.encode()) except RuntimeError: continue print(\u0026#39;password is\u0026#39;, password) break 运行结果:\npassword is admin 使用zf.extractall方法逐一测试密码字典password.dict中的密码，如果当前密码测试失败就进入下一轮，如果成功则打印密码并结束循环。\nNote! zf.extractall方法可以通过参数pwd指定密码；如果密码错误则会抛出RuntimeError错误，可以使用try except语句接收。\n下篇 密码篇・并行密码猜解\n"
            }
    
        ,
            {
                "id": 75,
                "href": "https://bxtkezhan.github.io/%E5%AF%86%E7%A0%81%E7%AF%87%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/",
                "title": "密码篇・实际应用",
                "section": "posts",
                "date" : "2021.04.25",
                "body": "返回教程主页\n上篇 密码篇・公开密钥加密\n之前我们学习了一些密码学的基本概念和原理，接下来我们研究一下密码学技术在实际应用中需要关注的一些问题。\n加密效率问题 虽然公钥加密能够确保密钥的安全，然而由于公钥加密运算量庞大，如果需要传递的数据比较多，那么一直使用公钥加密的方式就会使得通讯效率低下。\n对于这种情况我们可以结合公钥加密与对称加密进行数据的加密传递，我们可以使用公钥加密去安全地传递用于对称加密的密钥，然后再持续使用对称加密进行快速的加密通讯:\n使用公钥加密方法加密对称加密的密钥并传递给对方； 在之后的通讯中使用对称加密进行加密； 身份验证问题 在使用公钥加密的时候我们会广播自己生成的公钥，并要求对方使用公钥进行加密。这意味着别人也可以通过我们的公钥来加密数据并传递给我们，对我们进行身份欺骗攻击。\n对于这种情况我们可以将公钥加密的方式反过来运用进行数字签名:\n爱丽丝如果要将一串数据发送给鲍伯，首先可以对这串数据使用Hash算法生成一段摘要，然后使用自己的私钥加密这段摘要，最后将数据和加密后的摘要一同使用鲍伯的公钥进行加密并发送给鲍伯； 鲍伯在收到数据后先使用自己的私钥进行解密得到数据和该数据的加密摘要，然后使用爱丽丝的公钥对加密的摘要进行解密得到摘要A，同时对数据进行Hash得到摘要B，如果摘要A与摘要B相同则说明该数据来自爱丽丝； 由于伊夫没有爱丽丝的私钥，所以如果伊夫也对数据进行Hash并使用不属于爱丽丝的私钥进行加密就会导致鲍伯最终得到的A、B两个摘要不相同，因此无法冒充爱丽丝与鲍伯进行通讯； 维基百科: 散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。\n下篇 密码篇・密码猜解\n"
            }
    
        ,
            {
                "id": 76,
                "href": "https://bxtkezhan.github.io/%E6%87%92%E6%83%B0%E4%BA%BA%E5%93%AA%E4%BD%A0%E8%A6%81%E7%9D%A1%E5%88%B0%E5%87%A0%E6%97%B6%E5%91%A2/",
                "title": "懒惰人哪，你要睡到几时呢？",
                "section": "posts",
                "date" : "2021.04.24",
                "body": " 箴言 6\n6 懒惰人哪，你去察看蚂蚁的动作，就可得智慧。7 蚂蚁没有元帅，没有官长，没有君王，8 尚且在夏天预备食物，在收割时聚敛粮食。9 懒惰人哪，你要睡到几时呢？你何时睡醒呢？10 再睡片时，打盹片时，抱着手躺卧片时，11 你的贫穷就必如强盗速来，你的缺乏仿佛拿兵器的人来到。\n箴言 26\n15 懒惰人放手在盘子里，就是向口撤回，也以为劳乏。16 懒惰人看自己比七个善于应对的人更有智慧。\n愿我的心时常振作，少叫我的智慧打盹；愿我的脚走在正直的道上，不要让乖谬将我带离。\n"
            }
    
        ,
            {
                "id": 77,
                "href": "https://bxtkezhan.github.io/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80linux/x86-64%E7%AC%AC%E4%B8%80%E6%AD%A5/",
                "title": "汇编语言「Linux/x86-64」・第一步",
                "section": "posts",
                "date" : "2021.04.20",
                "body": "汇编语言是一系列用于电脑、处理器、控制器，或其他可以编程器件的低级语言的统称。通常不同的设备会对应不同的汇编语言。下面着重介绍Linux下的64位汇编语言 NASM x86-64，我这边主要使用Ubuntu系统进行作业，原则上其他版本的64位Linux也同样可以进行相应的操作，只不过某些命令会有所不同，需要大家注意。\n安装NASM 我们可以使用APT工具直接在联网的情况下安装NASM:\nsudo apt install nasm 安装完毕后，可以查看一下它的版本号:\nnasm -v # NASM version 2.14.02 Linux下64位汇编的“Hello World” 我们在文本编辑器中写入如下代码并进行保存「建议扩展名为.asm」:\nglobal _start section .text _start: mov rax, 1 mov rdi, 1 mov rsi, message mov rdx, 13 syscall mov rax, 60 xor rdi, rdi syscall section .data message: db \u0026#34;Hello, World\u0026#34;, 10 运行编译和链接命令生成可执行的二进制文件然后运行:\nnasm -f elf64 hello.asm \u0026amp;\u0026amp; ld hello.o ./a.out 输出结果:\nHello, World 成功编译并能输出正确的结果就说明Linux下64位NASM开发环境已经准备完毕，下一节将解析一下这段代码的含意，欢迎关注。\n"
            }
    
        ,
            {
                "id": 78,
                "href": "https://bxtkezhan.github.io/%E5%AF%86%E7%A0%81%E7%AF%87%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/",
                "title": "密码篇・公开密钥加密",
                "section": "posts",
                "date" : "2021.04.18",
                "body": "返回教程主页\n上篇 密码篇・对称密钥加密\n维基百科: 公开密钥密码学（英语：Public-key cryptography）也称非对称式密码学（英语：Asymmetric cryptography）是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。\n对称加密的密钥发送问题 如果用之前提到的对称加密算法传递数据，因为加密和解密使用的是同一个密钥，所以双方必须先传递这把密钥才能在加密的情况下进行信息交流。但是如果密钥在传递过程中被窃取就会出现泄密。\n为了能够安全传递密钥有人进行了一个设想: 我们可以做出两把密钥，一把用于加密但是不能解密，一把用于解密但是不能用于加密，同时加密用的密钥不能推导出解密用的密钥，那么我们就可以只发送那把加密用的密钥给对方，自己存留解密用的密钥，这样我们就可以确保不会因为分发密钥时密钥被窃取而导致加密信息被泄漏。由于过程中存在可以被公开使用的密钥因此这种加密方式也被称为“公开密钥加密”。其中，公开使用的密钥称为“公钥”；不被公开使用的密钥称为“私钥”。\n在数学上可以表示为: $d(c(x))=x$，让我们使用典型的爱丽丝与鲍伯假设来解释：\n爱丽丝与鲍伯事先互不认识，也没有可靠安全的沟通渠道，但爱丽丝现在却要透过不安全的互联网向鲍伯发送信息 爱丽丝撰写好原文，原文在未加密的状态下称之为明文$x$ 鲍伯使用“密码学安全伪随机数生成器”产生一对密钥，其中一个作为公钥为$c$，另一个作为私钥$d$ 鲍伯可以用任何方法发送公钥$c$给爱丽丝，即使伊夫在中间窃听到$c$也没问题 爱丽丝用公钥$c$把明文$x$进行加密，得到密文$c(x)$ 爱丽丝可以用任何方法传输密文$c(x)$给鲍伯，即使伊夫在中间窃听到密文$c(x)$也没问题 鲍伯收到密文，用私钥$d$对密文进行解密$d(c(x))$得到爱丽丝撰写的明文$x$ 由于伊夫没有得到鲍伯的私钥$d$，所以无法得知明文$x$ 如果爱丽丝丢失了她自己撰写的原文$x$，在没有得到鲍伯的私钥$d$的情况下，她的处境将等同伊夫，即无法透过鲍伯的公钥$c$和密文$c(x)$重新得到原文$x$ RSA算法 RSA算法就是公开密钥加密设想的一种实现方法，RAS算法通过巧妙的利用质因数拆解难题构造出公钥和私钥来实现公开密钥加密。\n给定两个非常大质数$p,q$，我们可以很容易得到他们乘积$m = p \\times q$，然而我们只知道$m$由两个质数相乘得到却很难得出$p,q$的确切值:\n$$ \\begin{align} 简单: p,q \\rightarrow m = p \\times q \\\\ 困难: p,q \\leftarrow m = p \\times q \\end{align} $$ 有了质因数的这个性质后我们还需要通过一个运算方法将其应用到实际操作中，“取模”就是一个不错的选项，即给定两个整数$a,n$可以相除得到余数$b$，数学上可以表示为:\n$$ a \\equiv b \\ (mod \\ n) $$\n在取模操作中有一个比较有趣的现象，我们若知道$a,n$就可以准确推出$b$，然而若只知道$b,n$却无法准确推出$a$。\n$$ 6 \\equiv 1 (mod \\ 7) \\text{ ; } 15 \\equiv 1 (mod \\ 7) \\text{ ; } 22 \\equiv 1 (mod \\ 7) \\text{ \u0026hellip;} $$\n有了质因数性质和取模运算，那么接下来我们就可以构建出公钥和私钥:\n$$ \\begin{align} p,q \u0026 \\quad 随机生成两个不相等的大质数p,q \\tag 1 \\\\ N = p \\times q \u0026 \\quad 计算p,q的乘积N \\tag 2 \\\\ \\Phi(N) = (p - 1)(q - 1) \u0026 \\quad 计算欧拉函数\\Phi(N) \\tag 3 \\\\ e \\in gcd(e,\\Phi(N)) = 1 \u0026 \\quad 取与\\Phi(N)互质且小于\\Phi(N)的自然数e \\tag 4 \\\\ ex + \\Phi y = 1 \u0026 \\quad 由e,\\Phi(N)互质可以构建方程并求整数解x,y \\tag 5 \\end{align} $$ $$ (N,e)\\ 将被作为公钥；(N,x)\\ 则作为私钥使用 $$\nNote! 1. 方程式(3)中提到的欧拉函数$\\Phi(n)$是指小于或等于$n$的正整数中与$n$互质的数的数目，例如$\\Phi(8) = 4$，因为1,3,5,7均和8互质；2. 方程式(5)可以用扩展欧几里得算法进行求解「感兴趣的朋友可以自己搜索了解扩展欧几里得算法的相关知识」。\n有了公钥$(N,e)$以及私钥$(N,x)$后我们就可以对数据进行加密与解密的操作:\n$$ \\begin{align} A \u0026 \\quad 将数字A作为需要加密的明文 \\tag 6 \\\\ A^e \\equiv R (mod \\ N) \u0026 \\quad 计算A的e次方并除N得到余数R，R\\ 即为密文 \\tag 7 \\\\ R^x \\equiv A (mod \\ N) \u0026 \\quad 计算R的x次方并除N得到余数A，A\\ 即为明文 \\tag 8 \\end{align} $$ Note! 关于运算式(7)、(8)为什么可以互相逆转可以使用费马小定理进行证明，感兴趣的朋友也可以搜索相关资料进行扩展学习。\n下面我们用一组比较简单的数据来验证一下上述方法:\n取质数$p = 5, q = 11$，求得$N = p \\times q = 55$； 计算欧拉函数$\\Phi(N) = (p - 1)(q - 1) = 40$； 取$e = 17$，满足$e \\in gcd(e,\\Phi(N)) = 1$； 当$x = 33,y = -14$时方程$ex + \\Phi y = 1$成立； $(55,17)$作为公钥；$(55,33)$作为私钥； 有数字14作为明文$A$，「注意确保$A$小于$N$」； 加密明文$A=14$得到密文$14^{17} \\equiv 9 (mod \\ 55) \\Rightarrow R = 9$； 解密密文$R=9$得到明文$9^{33} \\equiv 14 (mod \\ 55) \\Rightarrow A = 14$； 使用Python代码进行测试:\np, q = 5, 11 N = p * q Phi = (p - 1) * (q - 1) e = 17 x, y = 33, -14 print(\u0026#39;ex + Phi(N)y =\u0026#39;, e * x + Phi * y) print(\u0026#39;公钥:\u0026#39;, (N, e), \u0026#39;私钥:\u0026#39;, (N, x)) A = int(input(\u0026#39;明文: \u0026#39;).strip()) R = A**e % N _A = R**x % N print(\u0026#39;加密\u0026amp;解密: {} -\u0026gt; {} -\u0026gt; {}\u0026#39;.format(A, R, _A)) 运行效果:\nex + Phi(N)y = 1 公钥: (55, 17) 私钥: (55, 33) 明文: 14 加密\u0026amp;解密: 14 -\u0026gt; 9 -\u0026gt; 14 实际上公钥加密算法的类型也有很多种，而RSA只是利用质因数分解特性的一种方法，除此之外还有Rabin等利用质因数分解特性的公钥加密算法；另外还有根据离散对数问题设计的公钥加密算法，例如: 椭圆曲线加密算法、ElGamal加密算法……\n下篇 密码篇・实际应用\n"
            }
    
        ,
            {
                "id": 79,
                "href": "https://bxtkezhan.github.io/%E4%BF%9D%E5%AE%88%E5%85%AC%E4%B9%89%E7%9A%84%E5%BF%83%E8%A1%8C%E8%B5%B0%E6%AD%A3%E7%9B%B4%E7%9A%84%E8%B7%AF/",
                "title": "保守公义的心，行走正直的路",
                "section": "posts",
                "date" : "2021.04.17",
                "body": " 箴言 11\n1 诡诈的天平是耶和华所厌恶的，准确的法码是他所喜悦的。 2 傲慢来，羞辱也来；谦卑的人却有智慧。 3 正直人的纯正必引导他们自己，奸诈人的奸恶却毁灭自己。 4 在 神 发怒的日子，财物毫无益处；唯有公义能救人脱离死亡。 5 完全人的公义，必使自己的路平坦正直，但恶人必因自己的邪恶跌倒。 6 正直人的公义必拯救自己，但奸诈人必陷溺於自己的恶慾中。\n我希望自己能够做一个正直、谦逊的人，并愿意为此努力，愿 神 的话语成就。\n"
            }
    
        ,
            {
                "id": 80,
                "href": "https://bxtkezhan.github.io/%E5%AF%86%E7%A0%81%E7%AF%87%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/",
                "title": "密码篇・对称密钥加密",
                "section": "posts",
                "date" : "2021.04.11",
                "body": "返回教程主页\n上篇 密码篇・密码学简介\n维基百科: 对称密钥算法（英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。\n文本内容的数字化 在Python当中文本字符串可以被轻易转换为字节形式，转换后的字节序列的每一个元素都是一个数值，我们可以将其看作是一个数组，而这个数组就是原本字符串内容的数位形式。\n使用字符串的encode方法可以将字符串转换为字节数组，使用字符串的format格式化方法可以将其打印成0、1组合的二进制格式:\ntext = \u0026#39;hello world\u0026#39; text_bytes = text.encode() for b in text_bytes: print(\u0026#39;{:08b}\u0026#39;.format(b)) 运行结果:\n01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 加密操作的数字化 有一种特殊的运算方式可以非常简单的实现数字化的加密操作那便是“按位异或运算”^:\nk = 49 a = 1234 b = a ^ k c = b ^ k print(k, a, b, c) 运行结果:\n49 1234 1251 1234 我们首先对a与k进行按位异或运算得到b，然后对b与k进行按位异或运算得到c，发现c与a相等，如果你愿意尝试更多的数字就会发现规律，a ^ k ^ k会等于a，那么这时我们可以将一个数字k作为密钥，对某个数字a进行加密得到密文数字b，然后使用作为密钥的数字k来解密。\n先前我们知道了字符串可以转换成一串数字，那么我们完全可以使用按位异或的方法对字符串进行加密:\nsrc = input(\u0026#39;文本: \u0026#39;).strip() key = int(input(\u0026#39;密钥: \u0026#39;).strip()) dst = [] print(\u0026#39;key={:08b}({})\u0026#39;.format(key, key)) for a in src.encode(): b = a ^ key dst.append(b) print(\u0026#39;{:08b} -\u0026gt; {:08b}\u0026#39;.format(a, b)) # bytes函数可以将数字列表转换为字节序列 print(\u0026#39;密文:\u0026#39;, bytes(dst)) src_bytes = [] for b in dst: a = b ^ key src_bytes.append(a) # 使用字节序列的decode方法可以将其转回字符串 print(\u0026#39;明文:\u0026#39;, bytes(src_bytes).decode()) 运行效果:\n文本: hello world 密钥: 49 key=00110001(49) 01101000 -\u0026gt; 01011001 01100101 -\u0026gt; 01010100 01101100 -\u0026gt; 01011101 01101100 -\u0026gt; 01011101 01101111 -\u0026gt; 01011110 00100000 -\u0026gt; 00010001 01110111 -\u0026gt; 01000110 01101111 -\u0026gt; 01011110 01110010 -\u0026gt; 01000011 01101100 -\u0026gt; 01011101 01100100 -\u0026gt; 01010101 密文: b\u0026#39;YT]]^\\x11F^C]U\u0026#39; 明文: hello world 不难发现使用按位异或加密在加密过程和解密过程中所使用的密钥都是一样的，因此该方法也被归入对称密钥加密。\n子密钥 为了增加密码破译难度，我们可以使用多个密钥对明文进行加密。为了方便，通常我们会使用一个母密钥去生成多个子密钥，而不是每次去输入一堆密钥。\n字符串可以被转换成一系列的数字，我们可以将字符串作为母密钥用来生成一系列的数字作为子密钥:\nkey = input(\u0026#39;密钥: \u0026#39;).strip() sub_keys = key.encode() 使用子密钥进行加密的Python实现:\nsrc = input(\u0026#39;文本: \u0026#39;).strip() key = input(\u0026#39;密钥: \u0026#39;).strip() sub_keys = key.encode() dst = [] for a in src.encode(): b = a for k in sub_keys: b = b ^ k dst.append(b) print(\u0026#39;密文:\u0026#39;, bytes(dst)) src_bytes = [] for b in dst: a = b # [::-1] 用于将序列对象反向，例如: 1, 2, 3 -\u0026gt; 3, 2, 1 for k in sub_keys[::-1]: a = a ^ k src_bytes.append(a) print(\u0026#39;明文:\u0026#39;, bytes(src_bytes).decode()) 运行效果:\n文本: hello world 密钥: password 密文: b\u0026#39;wzssp?hpms{\u0026#39; 明文: hello world 需要注意的是由于对称式加密的特点，当我们输入的母密钥中存在对称重复的时候情况就会变得糟糕，例如我们输入\u0026quot;abba\u0026quot;作为母密钥，那么算法将完全失效:\n文本: hello world 密钥: abba 密文: b\u0026#39;hello world\u0026#39; 明文: hello world 显然我们需要对加密程序进行优化，通过制定更加科学的子密钥生成标准以及结合“费斯妥密码”算法架构就能有效地处理这类问题。\n维基百科: 在密码学中，费斯妥密码（英语：Feistel cipher）是用于构造分组密码的对称结构，以德国出生的物理学家和密码学家霍斯特·费斯妥（Horst Feistel）命名，他在美国IBM工作期间完成了此项开拓性研究。通常也称为费斯妥网络（Feistel network）。大部分分组密码使用该方案，包括数据加密标准（DES）。费斯妥结构的优点在于加密和解密操作非常相似，在某些情况下甚至是相同的，只需要逆转密钥编排。\n想要将对称式加密技术运用于商业活动，还有许多内容需要掌握，如果你足够感兴趣可以自己扩展学习更多的知识，例如: 费斯妥密码、ECB模式、CBC模式、DES标准、AES标准……\n下篇 密码篇・公开密钥加密\n"
            }
    
        ,
            {
                "id": 81,
                "href": "https://bxtkezhan.github.io/%E5%AF%86%E7%A0%81%E7%AF%87%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AE%80%E4%BB%8B/",
                "title": "密码篇・密码学简介",
                "section": "posts",
                "date" : "2021.04.10",
                "body": "返回教程主页\n上篇 密码篇・操作环境准备\n密码学（英语：Cryptography）可分为古典密码学和现代密码学。古典密码学主要关注信息的保密书写和传递，以及与其相对应的破译方法。而现代密码学不只关注信息保密问题，还同时涉及信息完整性验证（消息验证码）、信息发布的不可抵赖性（数字签名）、以及在分布式计算中产生的来源于内部和外部的攻击的所有信息安全问题。\n古典密码・凯撒密码 凯撒密码（英语：Caesar cipher），或称凯撒加密、凯撒变换、变换加密，是一种最简单且最广为人知的加密技术。凯撒密码是一种替换加密技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。\n例如确定偏移量为3，英文字母A被D替代，B被E替代，C被F替代并以此类推:\nA B C D \u0026hellip; X Y Z D E F G \u0026hellip; A B C 根据上述表格所示的规则，我们可以将明文\u0026ldquo;HELLO WORLD\u0026quot;加密成密文\u0026ldquo;KHOOR ZRUOG\u0026rdquo;。\n使用Python实现凯撒加密:\nimport string # 取出string模块内置的大写英文字母 case = string.ascii_uppercase length = len(case) bias = int(input(\u0026#39;偏移: \u0026#39;).strip()) src = input(\u0026#39;文本: \u0026#39;).strip().upper() # upper方法转换字母为大写 dst = \u0026#39;\u0026#39; for c in src: # 使用字符串的find方法找出字符c在字符串case中的位置 # 如果没有找到将返回-1，否则返回所在位置的下标 i = case.find(c) if i \u0026lt; 0: # 如果没有找到就直接将字符拼接到dst dst += c else: # 如果找到了，就通过转换得到偏移后的位置j j = (i + bias) % length dst += case[j] # 将偏移后的字母拼接到dst print(src, \u0026#39;-\u0026gt;\u0026#39;, dst) 运行效果:\n偏移: 3 文本: hello world HELLO WORLD -\u0026gt; KHOOR ZRUOG 凯撒密码破译难度非常低，一旦被人识破所使用的加密方式为凯撒加密，破解者只需要进行少量的排查就能完成密码破译工作。\n古典密码・简易替换密码 简易替换加密是一种以特定方式改变字母表上字母顺序，并以此顺序书写的加密方式。这样一张改变了字母次序的字母表即为‘替换表’。传统上会先把一个关键词写在字母表最前面，再删去重复字母，这样就能得到一个混合表。\n例如使用混合表系统，关键字为“zebras”:\n明文字母表 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n密文字母表 ZEBRASCDFGHIJKLMNOPQTUVWXY\n对\u0026quot;flee at once. we are discovered!\u0026ldquo;进行加密得到结果\u0026quot;SIAA ZQ LKBA. VA ZOA RFPBLUAOAR!\u0026quot;。\n使用Python实现简易替换密码:\nimport string p_case = string.ascii_uppercase c_case = input(\u0026#39;单词: \u0026#39;).strip().upper() for c in p_case: if c not in c_case: c_case += c print(\u0026#39;明文字母表:\u0026#39;, p_case) print(\u0026#39;密文字母表:\u0026#39;, c_case) src = input(\u0026#39;文本: \u0026#39;).strip().upper() dst = \u0026#39;\u0026#39; for c in src: i = p_case.find(c) if i \u0026lt; 0: dst += c else: dst += c_case[i] print(src, \u0026#39;-\u0026gt;\u0026#39;) print(dst) 运行效果:\n单词: zebras 明文字母表: ABCDEFGHIJKLMNOPQRSTUVWXYZ 密文字母表: ZEBRASCDFGHIJKLMNOPQTUVWXY 文本: flee at once. we are discovered! FLEE AT ONCE. WE ARE DISCOVERED! -\u0026gt; SIAA ZQ LKBA. VA ZOA RFPBLUAOAR! 虽然简易替换密码比凯撒密码复杂度高，然而还是可能被借用词频统计等方法推测出明文内容，随着加密文本量的增加还会使得破译的几率增大。\n除了简易替换密码，还有谐音替换法、多表替换加密、表格式替换加密、机械替换加密、一次性密码本等不同形式的替换式密码，如果大家感兴趣，可以在网上搜集资料扩展更多的知识。\n下篇 密码篇・对称密钥加密\n"
            }
    
        ,
            {
                "id": 82,
                "href": "https://bxtkezhan.github.io/%E4%BD%A0%E7%9A%84%E6%B3%89%E6%BA%90%E5%B2%82%E5%8F%AF%E6%B6%A8%E6%BA%A2%E5%9C%A8%E5%A4%96/",
                "title": "你的泉源岂可涨溢在外？",
                "section": "posts",
                "date" : "2021.04.09",
                "body": " 箴言 5\n15 你要喝自己池中的水，饮自己井里的活水。 16 你的泉源岂可涨溢在外？你的河水岂可流在街上？ 17 唯独归你一人，不可与外人同用。\n我们总是喜欢强调分享的观念，但是如果我们足够现实就会发现在一些事情上必须强调自己的“独享权”，特别是当某个事物如同水一样重要，关乎到自己的生存时更加如此。\n"
            }
    
        ,
            {
                "id": 83,
                "href": "https://bxtkezhan.github.io/%E5%AF%86%E7%A0%81%E7%AF%87%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/",
                "title": "密码篇・操作环境准备",
                "section": "posts",
                "date" : "2021.04.08",
                "body": "返回教程主页\n上篇 初学篇・猜字游戏「阶段练习」\nPython作为一门流行的脚本语言很早就被Mac OS、主流Linux发行版所预装，一般来说只需要确保自己系统的Python版本不要太旧「建议高于3.5」，如果是Windows用户可以去往Python的官方网站 www.python.org 进行下载安装，上述视频为Windows 10系统安装Python的示范。\n下篇 密码篇・密码学简介\n"
            }
    
        ,
            {
                "id": 84,
                "href": "https://bxtkezhan.github.io/%E5%88%9D%E5%AD%A6%E7%AF%87%E7%8C%9C%E5%AD%97%E6%B8%B8%E6%88%8F%E9%98%B6%E6%AE%B5%E7%BB%83%E4%B9%A0/",
                "title": "初学篇・猜字游戏「阶段练习」",
                "section": "posts",
                "date" : "2021.04.06",
                "body": "返回教程主页\n上篇 初学篇・面向对象\u0026amp;数据结构\n猜字游戏涉及的Python基础知识比较丰富且十分容易实现，可以作为《黑客之路・Python篇・初学者篇》的阶段性练习“项目”。\n下篇 密码篇・操作环境准备\n"
            }
    
        ,
            {
                "id": 85,
                "href": "https://bxtkezhan.github.io/%E5%88%9D%E5%AD%A6%E7%AF%87%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
                "title": "初学篇・面向对象\u0026数据结构",
                "section": "posts",
                "date" : "2021.04.04",
                "body": "返回教程主页\n上篇 初学篇・函数的定义与调用\n在Python当中，我们常常使用到的基本数据类型有整型int、浮点型float、字符串类型str……，以及结构类型列表list、元组tuple，事实上我们也可以自己来定义类型，这将涉及到Python的面向对象编程。\n类的定义与实例化 我们可以借助关键字class定义我们自己的数据结构类型:\nclass \u0026lt;类名称\u0026gt;: \u0026lt;类成员\u0026gt; 在完成类的定义后我们可以借助类名称来实例化我们的类型，即产生一个该类型的对象:\nclass Calc: pass # pass 用于占位，并无具体操作 calc = Calc() print(type(calc)) 运行结果:\n\u0026lt;class \u0026#39;pythonTmp.Calc\u0026#39;\u0026gt; 我们可以在类中定义一些变量作为该类的成员变量，并且使用点.进行调取:\nclass Number: one = 1 two = 2 pi = 3.14159 number = Number() print(number.one, number.two, number.pi) 运行结果:\n1 2 3.14159 我们也可以在类中定义一些函数作为该类的成员方法，并使用点.进行调用:\nclass Computer: def add(self, a, b): return a + b def sub(self, a, b): return a - b computer = Computer() print(computer.add(100, 100)) print(computer.sub(100, 100)) 运行结果:\n200 0 成员方法的第一个参数代表该对象本身，通常取名self，调用某对象的成员方法时该参数无须设定。借助这个参数，我们可以在某个成员方法中操作其它该类的成员变量或成员方法:\nclass Man: name = \u0026#34;kk\u0026#34; def say(self): print(\u0026#34;I\u0026#39;m\u0026#34;, self.name) man = Man() man.say() 运行结果:\nI\u0026#39;m kk 构造方法 实例化类的时候会调用到该类的构造方法__init__，如果编码人员没有自己设定Python将启用默认的设定。借助构造方法我们可以在实例化类的时候传入参数:\nclass MyClassOne: def __init__(self): print(\u0026#39;New a object\u0026#39;) mc1 = MyClassOne() class MyClassTwo: def __init__(self, message): print(message) mc2 = MyClassTwo(\u0026#39;Init message\u0026#39;) 运行结果:\nNew a object Init message 在构造方法中使用self参数设置类的成员:\nclass Man: def __init__(self, name): self.name = name def say(self): print(\u0026#34;I\u0026#39;m\u0026#34;, self.name) man = Man(\u0026#34;jojo\u0026#34;) man.say() 运行结果:\nI\u0026#39;m jojo 序列结构类型 Python当中最常用的序列结构类型就是: 列表list、元组tuple、字符串str，除了遍历的方法，我们也可以通过下标索引的方式将序列结构中的元素取出:\na = [1, 2, 3] print(a[0], a[1], a[2]) b = (1, 2, 3) print(b[0], b[1], b[2]) c = \u0026#34;123\u0026#34; print(c[0], c[1], c[2]) 运行结果:\n1 2 3 1 2 3 1 2 3 索引对象时需要注意: Python中的下标从0开始计数，也就是下标0的位置其实是序列的第一个:\nprint(\u0026#39;abcdefg\u0026#39;[0]) print((5, 4, 3, 2, 1)[0]) print([-1, -2, -3, -4, -5][0]) 运行结果:\na 5 -1 列表与元组和字符串有一个比较大的区别就是列表中的元素允许被修改:\n_list = [0, 0, 0] print(_list) _list[0] = 1 print(_list) _list[1] = 2 print(_list) _list[2] = 3 print(_list) 运行结果:\n[0, 0, 0] [1, 0, 0] [1, 2, 0] [1, 2, 3] Python中可以使用切片slice的方法来取得序列结构中的某一部分:\n_str = \u0026#34;123456789\u0026#34; print(_str[0:3]) _tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9) print(_tuple[1:4]) _list = [1, 2, 3, 4, 5, 6, 7, 8, 9] print(_list[2:5]) 运行结果:\n123 (2, 3, 4) [3, 4, 5] 切片索引具有以下形式:\n[n:]: 取序列第n个到最后一个； [:n]: 取序列第0个到第n-1个； [a:b]: 取序列第a个到第b-1个； [n::s]: 从序列第n个开始到序列最后，每跨s个元素进行取出； [:n:s]: 从序列第0个开始到第n-1个，每跨s个元素进行取出； [a:b:s]: 从序列第a个开始到第b-1个，每跨s个元素进行取出； sequence = [1, 2, 3, 4, 5, 6, 7, 8, 9] print(sequence[1:9:2]) 运行结果:\n[2, 4, 6, 8] Python当中的索引可以使用负数来表示倒数开始的位置，例如最后一位[-1]:\nword = \u0026#34;sequnece\u0026#34; print(word[-1]) print(word[-2]) print(word[-3]) 运行结果:\ne c e 可以使用列表list的append成员方法动态的为列表加入新的元素:\n_list = [] print(len(_list), _list) _list.append(1) print(len(_list), _list) _list.append(2) print(len(_list), _list) 运行结果:\n0 [] 1 [1] 2 [1, 2] 集合结构 Python还支持集合set类型。集合是由不重复元素组成的无序容器。基本用法包括成员检测、消除重复元素。集合对象支持合集、交集、差集、对称差分等数学运算。创建集合用花括号或set()函数，注意，创建空集合只能用set()，不能用{}:\nset_a = {1, 2, 3} print(set_a) set_b = {2, 3, 4} print(set_b) 运行结果:\n{1, 2, 3} {2, 3, 4} 字典结构 如果集合中的每一个元素都有自己对应的值，那么这种由集合与值映射所组成的结构就被称作字典dict，字典在定义时可以使用冒号:来指定对应关系，并且也支持索引、赋值、修改:\n_dict = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} print(_dict) print(_dict[\u0026#39;a\u0026#39;]) print(_dict[\u0026#39;b\u0026#39;]) print(_dict[\u0026#39;c\u0026#39;]) _dict[\u0026#39;a\u0026#39;] = 3 _dict[\u0026#39;b\u0026#39;] = 2 _dict[\u0026#39;c\u0026#39;] = 1 print(_dict) 运行结果:\n{\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} 1 2 3 {\u0026#39;a\u0026#39;: 3, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 1} 下篇 初学篇・猜字游戏「阶段练习」\n"
            }
    
        ,
            {
                "id": 86,
                "href": "https://bxtkezhan.github.io/%E5%88%9D%E5%AD%A6%E7%AF%87%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8/",
                "title": "初学篇・函数的定义与调用",
                "section": "posts",
                "date" : "2021.04.04",
                "body": "返回教程主页\n上篇 初学篇・循环控制语句\n函数是指可重复使用的程序片段。被用来为某个代码块赋予名字，通过这一特殊的名字可以在程序的任何地方来运行代码块，并可重复任何次数。这就是所谓的调用函数。我们已经使用过了许多内置的函数，例如: print、len和range。\n定义函数与调用函数 定义函数使用关键字def，后跟函数名与括号内的形参列表。函数语句从下一行开始，并且必须缩进:\ndef say_hello(name): print(\u0026#39;Hello\u0026#39;, name) 定义函数后，可以使用函数名跟括号内参数的形式调用函数，若该函数在定义的时候并没有设置参数则不能在调用的时候传入参数:\ndef add(a, b): return a + b print(add(100, 200)) def get_pi(): return 3.14159 print(get_pi()) 运行结果:\n300 3.14159 函数体中可以通过return语句指定需要返回的对象:\ndef get_str(): return \u0026#34;a string\u0026#34; _str = get_str() print(_str, type(_str)) def get_float(): return 123.321 _float = get_float() print(_float, type(_float)) 运行结果:\na string \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 123.321 \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; 默认值参数 为参数指定默认值是非常有用的方式。调用函数时，可以使用比定义时更少的参数，例如:\ndef say_hello(name=\u0026#39;kk\u0026#39;): print(\u0026#39;Hello\u0026#39;, name) say_hello() say_hello(\u0026#39;jojo\u0026#39;) 运行结果:\nHello kk Hello jojo 如果函数有多个参数需要确保默认值参数都在非默认值参数的右边:\ndef add(a, b=1): return a + b print(add(1)) print(add(1, 2)) 运行结果:\n2 3 调用函数时，可以指定函数的默认参数来传递值:\ndef dump(a=0, b=0, c=0, d=0): print(a, b, c, d) dump(a=1) dump(b=2) dump(c=3) dump(d=4) 运行结果:\n1 0 0 0 0 2 0 0 0 0 3 0 0 0 0 4 下篇 初学篇・面向对象\u0026amp;数据结构\n"
            }
    
        ,
            {
                "id": 87,
                "href": "https://bxtkezhan.github.io/%E5%88%9D%E5%AD%A6%E7%AF%87%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/",
                "title": "初学篇・循环控制语句",
                "section": "posts",
                "date" : "2021.04.04",
                "body": "返回教程主页\n上篇 初学篇・条件控制语句\n在Python中可以通过while与for两种循环语句来处理循环问题。\nwhile循环 while语句用于在表达式保持为真的情况下重复地执行语句块，和if语句类似可以选择性加上else:\nwhile \u0026lt;判断表达式\u0026gt;: \u0026lt;语句块\u0026gt; else: \u0026lt;语句块\u0026gt; 在while语句中会重复地检验表达式，并且如果其值为真就执行第一个子语句块；如果表达式值为假（这可能在第一次检验时就发生）则如果else子语句块存在就会被执行并终止循环:\nn = 3 while n \u0026gt; 0: print(\u0026#39;then\u0026#39;, n) n = n - 1 else: print(\u0026#39;else\u0026#39;, n) 运行结果:\nthen 3 then 2 then 1 else 0 可以使用break中断循环，当某个循环语句中运行到break时将立即跳出当前循环且不执行else的子语句块:\nn = 10 while True: print(\u0026#39;then entry\u0026#39;) if n == 5: break n = n - 1 else: print(\u0026#39;else entry\u0026#39;) 运行结果:\nthen entry then entry then entry then entry then entry then entry 可以使用continue跳过当前循环的子语句块中剩下的语句直接回到判断表达式的位置进行下一轮循环:\nn = 3 while n \u0026gt; 0: n = n - 1 print(\u0026#39;before\u0026#39;) continue print(\u0026#39;after\u0026#39;) 运行结果:\nbefore before before for循环 for语句用于对序列（例如字符串、元组或列表）或其他可迭代对象中的元素进行迭代，for语句也可以选择性的加入else:\nfor \u0026lt;单个或多个变量\u0026gt; in \u0026lt;可以被迭代的对象\u0026gt;: \u0026lt;语句块\u0026gt; else: \u0026lt;语句块\u0026gt; Python中常见的序列有列表list、元组tuple、字符串str。关于字符串之前有过描述；所谓元组tuple可以看作是由圆括号()括起来并通过逗号,分隔的一串对象；而list则可以看作是用方括号[]括起来并通过逗号,分隔的一串对象；\n_list = [1, 2, 3] print(_list, type(_list)) _tuple = (1, 2, 3) print(_tuple, type(_tuple)) _str = \u0026#34;123\u0026#34; print(_str, type(_str)) 运行结果:\n[1, 2, 3] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; (1, 2, 3) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; 123 \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 可以通过for语句轻松将序列结构中的每一个元素取出实现遍历序列元素:\nfor number in [1, 2, 3]: print(number) for character in \u0026#34;abc\u0026#34;: print(character) 运行结果:\n1 2 3 a b c 类似while，在for循环过程中如果在子语句块遇到break则会立刻中断循环，如果遇到continue则会跳过当前子语句块的剩余部分进入下一次循环:\nfor i in [1, 2, 3]: print(i) break print(\u0026#39;end of for\u0026#39;) for i in [1, 2, 3]: print(\u0026#39;before\u0026#39;) continue print(\u0026#39;after\u0026#39;) print(\u0026#39;end of for\u0026#39;) 运行结果:\n1 end of for before before before end of for 有时候为了方便我们会用range函数去构造一个可以遍历的对象来进行循环操作:\nfor i in range(2): print(i) for i in range(2): print(2 + i) 运行结果:\n0 1 2 3 range函数可以接收三个整数类型的参数，具有以下几种形式:\nrange(n): 生成0到n的整数序列，注意不包含n； range(a, b): 生成范围在a与b之间的整数序列，包含a不包含b； range(a, b, s): 生成范围在a与b之间的整数序列，且跨度为s，包含a不包含b； for i in range(3): print(i) for i in range(3, 6): print(i) for i in range(6, 12, 2): print(i) 运行结果:\n0 1 2 3 4 5 6 8 10 下篇 初学篇・函数的定义与调用\n"
            }
    
        ,
            {
                "id": 88,
                "href": "https://bxtkezhan.github.io/%E5%88%9D%E5%AD%A6%E7%AF%87%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/",
                "title": "初学篇・条件控制语句",
                "section": "posts",
                "date" : "2021.04.03",
                "body": "返回教程主页\n上篇 初学篇・逻辑运算\u0026amp;比较运算\nif语句用以根据条件判断如何执行代码: 如果条件为真True，我们将运行一块语句(称作 if-block 或 if 块)，否则我们将运行另一块语句(称作 else-block 或 else 块)。其中else从句是可选的。\nif语句大致形式如下:\nif \u0026lt;条件表达式\u0026gt;: \u0026lt;语句块\u0026gt; else: \u0026lt;语句块\u0026gt; 单一的if 一般来说具有同样的左缩进的行会被当作一个语句块，使用一个简单的if语句就可以根据条件来判断是否需要运行某个语句块，例如:\nif 100 \u0026gt; 0: print(\u0026#39;*\u0026#39;) print(\u0026#39;*\u0026#39; * 2) print(\u0026#39;*\u0026#39; * 3) print(\u0026#39;*\u0026#39; * 4) 运行结果:\n* ** *** **** if配合else if-else的组合可以根据条件判断是执行哪一个语句块:如果条件为真则执行紧跟if的语句块，否则执行紧跟else的语句块:\nif 100 \u0026gt; 0: print(\u0026#39;100 \u0026gt; 0\u0026#39;) else: print(\u0026#39;100 \u0026lt;= 0\u0026#39;) if -100 \u0026gt; 0: print(\u0026#39;-100 \u0026gt; 0\u0026#39;) else: print(\u0026#39;-100 \u0026lt;= 0\u0026#39;) 运行结果:\n100 \u0026gt; 0 -100 \u0026lt;= 0 插入elif if与else之间可以插入一个或多个elif来增加判断条件和对应的语句块，若if与elif中任意一个被匹配执行将不再执行其它语句块:\na = 100 b = 50 c = 0 if a \u0026gt; b * 2: print(\u0026#39;block 1\u0026#39;) elif a \u0026gt; c * 2: print(\u0026#39;block 2\u0026#39;) else: print(\u0026#39;block 3\u0026#39;) 运行结果:\nblock 2 嵌套 我们可以让判断语句进行嵌套实现更加复杂的判断:\na = 100 b = 0 if a \u0026gt; b: if a \u0026gt; b * 2: print(\u0026#39;good!\u0026#39;) else: print(\u0026#39;en..?\u0026#39;) else: print(\u0026#39;what?\u0026#39;) 运行结果:\ngood! 下篇 初学篇・循环控制语句\n"
            }
    
        ,
            {
                "id": 89,
                "href": "https://bxtkezhan.github.io/%E5%88%9D%E5%AD%A6%E7%AF%87%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97/",
                "title": "初学篇・逻辑运算\u0026比较运算",
                "section": "posts",
                "date" : "2021.04.03",
                "body": "返回教程主页\n上篇 初学篇・Python计算器\n逻辑运算 Python当中可以用and、or、not关键字来进行与、或、非逻辑运算，而True、False则用于表示布尔值中的真与假:\nt = True f = False print(t and t) print(t and f) print(f and f) print(t or t) print(t or f) print(f or f) print(not t) print(not f) 运行结果:\nTrue False False True True False False True 除了True、False外，其它类型的值也可以转换为对应的布尔值，通常数字中0为假，非0为真，字符串中空字符串为假，非空字符串为真，使用bool函数可以进行转换:\nnumber_100 = 100 number_0 = 0 print(bool(number_100)) print(bool(number_0)) string_text = \u0026#34;nice to meet you\u0026#34; string_empty = \u0026#34;\u0026#34; print(bool(string_text)) print(bool(string_empty)) 运行结果:\nTrue False True False 由于很多类型都可以转换成布尔型，这意味着并非只有True、False可以进行逻辑运算:\nprint(100 and 100) print(100 and 0) print(0 or 0) print(0 or 100) 运行结果:\n100 0 0 100 比较运算 Python当中可以使用\u0026gt;、\u0026gt;=、==、\u0026lt;=、\u0026lt;、!=符号来进行值的比较:\nA \u0026gt; B : 若A大于B则返回真否则返回假 A \u0026gt;= B : 若A大于或等于B则返回真否则返回假 A == B : 若A等于B则返回真否则返回假 A \u0026lt;= B : 若A小于或等于B则返回真否则返回假 A \u0026lt; B : 若A小于B则返回真否则返回假 A != B : 若A不等于B则返回真否则返回假 print(100 \u0026gt; 1) print(-100 \u0026lt; 1) print(\u0026#34;hello\u0026#34; != \u0026#34;world\u0026#34;) 运行结果:\nTrue True True 优先级 Python当中的表达式具备优先级别，计算表达式中* / %优先于+ -:\nprint(1 - 2 * 3) 运行结果:\n-5 计算表达式则整体优先于比较表达式:\nprint(1 \u0026gt; 2 - 3) 运行结果:\nTrue 比较表达式则整体优先于逻辑表达式:\nprint(1 or 2 \u0026lt; 3) 运行结果:\n1 下篇 初学篇・条件控制语句\n"
            }
    
        ,
            {
                "id": 90,
                "href": "https://bxtkezhan.github.io/%E5%88%9D%E5%AD%A6%E7%AF%87python%E8%AE%A1%E7%AE%97%E5%99%A8/",
                "title": "初学篇・Python计算器",
                "section": "posts",
                "date" : "2021.04.03",
                "body": "返回教程主页\n上篇 初学篇・第一步“你好，世界”\n我们可以使用Python来进行一系列的计算器操作，如果足够熟悉Python，那么它将胜过许多高级计算器，甚至某些高级计算器就内置了Python，例如: Casio 卡西欧 FX-9860 GIII 图形计算器。\n数字 在WIDLE中，输入表达式，点击run按钮运行就会得到答案，使用print函数可以使答案显示出来。表达式的语法很直接: 运算符+、-、*、/的用法和普通计算器一样，括号()用来处理优先级。例如:\nprint(1 + 2) print(3 - 4) print(5 * 6) print(7 / 8) print(1 + (2 - 3) * 4 / 5) 运行结果:\n3 -1 30 0.875 0.19999999999999996 整数（如，2、4、20 ）的类型是整型（int），带小数（如，5.0、1.6 ）的类型是浮点型（float）。\n除法运算/返回浮点数。用//运算符执行整数除法的结果是整数（忽略小数），计算余数用%:\nprint(10 / 3) print(10 // 3) print(10 % 3) 运行结果:\n3.3333333333333335 3 1 等号=用于给变量赋值。变量的概念可以参照数学中变量的概念，我们可以用变量来指代某一个值，A = B的意思就是把值/对象赋给A，之后就可以用A指代B:\nwidth = 10 height = 10 area = width * height print(area) 运行结果:\n100 需要注意Python当中变量名字母区分大小写，以下是比较推荐的Python变量命名规范:\n变量名以字母或下划线字符开头 变量名只包含字母数字字符和下划线(A-z、0-9和_) 字符串 除了数字，Python还可以操作字符串。字符串有多种表现形式，用单引号'……'或双引号\u0026quot;……\u0026quot;标注的效果相同:\nprint(\u0026#39;Hi! kk.\u0026#39;) print(\u0026#34;Hi! jojo.\u0026#34;) 运行结果:\nHi! kk. Hi! jojo. 使用反斜杠\\进行转义可以输出一些特殊字符:\nprint(\u0026#39;0\\t1\\t2\\t3\u0026#39;) print(\u0026#39;0\\n1\\n2\\n3\u0026#39;) 运行结果:\n0\t1\t2\t3 0 1 2 3 字符串字面值可以实现跨行连续输入。实现方式是用三引号:\u0026quot;\u0026quot;\u0026quot;...\u0026quot;\u0026quot;\u0026quot;或'''...'''，字符串行尾会自动加上回车换行，如果不需要回车换行，在行尾添加\\即可。示例如下:\nprint(\u0026#34;\u0026#34;\u0026#34;\\ Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to \u0026#34;\u0026#34;\u0026#34;) 运行结果:\nUsage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to 字符串可以用+拼接，也可以用*重复:\nprint(\u0026#39;123\u0026#39; + \u0026#39;456\u0026#39;) print(\u0026#39;abc\u0026#39; * 3) 运行结果:\n123456 abcabcabc 我们可以使用len函数计算字符串的长度:\nnumbers = \u0026#39;1234567890\u0026#39; print(len(numbers)) 运行结果:\n10 类型 可以使用type函数输出对象的类型名称:\na = 123 print(type(a)) b = 123.321 print(type(b)) c = \u0026#34;123.321\u0026#34; print(type(c)) 运行结果:\n\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 可以使用int、float、str函数进行类型转换:\na = 123 print(a, type(a)) b = float(a) print(b, type(b)) c = str(b) print(c, type(c)) e = float(c) print(e, type(e)) f = int(e) print(f, type(f)) 运行结果:\n123 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 123.0 \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; 123.0 \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 123.0 \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; 123 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 下篇 初学篇・逻辑运算\u0026amp;比较运算\n"
            }
    
        ,
            {
                "id": 91,
                "href": "https://bxtkezhan.github.io/%E5%88%9D%E5%AD%A6%E7%AF%87%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/",
                "title": "初学篇・第一步“你好世界”",
                "section": "posts",
                "date" : "2021.04.03",
                "body": "返回教程主页\nPython的维基简介: Python是一种广泛使用的直译式、进阶和通用的程式语言。Python支援多种程式设计范式，包括函数式、指令式、结构化、物件导向和反射式程式。它拥有动态型别系统和垃圾回收功能，能够自动管理记忆体使用，并且其本身拥有一个巨大而广泛的标准库。\n初学者工具: WIDLE 为了方便初学者体验Python编程，我这边制作了一个免费、免安装的在线Python编辑与运行工具。大家可以进入网址: https://www.bxtkezhan.xyz/widle/进行简单的体验。\n尝试运行一行代码 print函数是打印输出的常用工具，我们可以在函数名print后面的括号()中放入表达式进行打印输出。我们尝试将下方代码拷贝到WIDLE中点击按钮run运行它:\nprint(\u0026#39;Hello world\u0026#39;) 代码注释 若我们在某个语句前面加上井号#则表示将此语句作为注释，Python将不会运行被注释的部分:\n# print(\u0026#39;Hello world\u0026#39;) Python官方网站 如果你想在自己的电脑中安装Python，可以去往Python的官方网站:www.python.org下载安装包进行安装，整个过程非常简单与安装普通软件并没有太多不同。\n下篇 初学篇・Python计算器\n"
            }
    
        ,
            {
                "id": 92,
                "href": "https://bxtkezhan.github.io/%E9%BB%91%E5%AE%A2%E4%B9%8B%E8%B7%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
                "title": "黑客之路・编译原理",
                "section": "posts",
                "date" : "2021.03.31",
                "body": "状态: 连载中……\n描述:\n和编程相关的一些计算机技术，包括编译原理，汇编语言，llvm，gcc。\n目录:\n递归向下初步「自制编程语言」 1. 词法分析器 2. 使用BKLexer进行词法分析 3. 递归向下算法实现Calc 4. 使计算器支持语句块 5. 使程序语言支持变量 6. 支持If语句 7. 支持While语句 汇编语言「Linux/x86-64」 1. 第一步 2. 代码解析 3. 调用C程序 JIT「及时编译」 1. GNU/Lightning介绍 2. Lightning 示例「incr」 2. Lightning 示例「printf」 "
            }
    
        ,
            {
                "id": 93,
                "href": "https://bxtkezhan.github.io/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5%E8%A6%81%E7%B4%A0%E7%A0%94%E5%8F%91%E4%B8%8E%E6%96%B9%E6%A1%88/",
                "title": "技术实践・要素、研发与方案",
                "section": "posts",
                "date" : "2021.03.31",
                "body": "状态: 连载中……\n描述:\n系统地整理了实用开发知识和方案思路并分享出来。包括计算机编程，Web应用开发，机器人，机器学习，计算机视觉，自然语言处理，嵌入式开发，网络，物联网，3D打印……\n为了方便系统地整理和总结一些实用开发知识、技术以及方案思路，这里需要先定义一个术语：\n技术实践：指将技术知识应用在具体的项目研发中，通过实际的项目使得技术知识得以具体的表现。例如，使用图形化编程技术开发一个视觉小游戏或者基于数据库管理技术开发一整套业务管理系统。\n接下来我们将从 1. 要素；2. 研发；3. 方案；这三个角度出发来整理一系列 技术实践 的相关内容。需要注意的是本书对 1. 要素；2. 研发；3. 方案；这三个角度的叙述并不恪守固定的写作顺序，也不推荐读者刻意按照目录编号顺序进行阅读，在出现新的术语或概念并有上下文依赖的地方本书会进行注明。\n目录:\n第一篇、要素 1. 要素的具体定义与说明 2. \u0026hellip;\u0026hellip; \u0026hellip;\u0026hellip;\n第二篇、研发 1. 研发的具体定义与说明 2. \u0026hellip;\u0026hellip; \u0026hellip;\u0026hellip;\n第三篇、方案 1. 方案的具体定义与说明 2. \u0026hellip;\u0026hellip; \u0026hellip;\u0026hellip;\n"
            }
    
        ,
            {
                "id": 94,
                "href": "https://bxtkezhan.github.io/%E9%BB%91%E5%AE%A2%E4%B9%8B%E8%B7%AFpython%E7%AF%87/",
                "title": "黑客之路・Python篇",
                "section": "posts",
                "date" : "2021.03.31",
                "body": "状态: 更新完毕，偶尔校正中……\n描述:\n围绕Python程序语言展开的一系列或有趣或实用的技术，欢迎喜欢计算机技术，软硬件技术，Python编程的朋友参与学习。\n目录:\n初学者篇 1. 第一步“你好，世界” 2. Python计算器 3. 逻辑运算\u0026amp;比较运算 4. 条件控制语句 5. 循环控制语句 6. 函数的定义与调用 7. 面向对象\u0026amp;数据结构 *. 猜字游戏「阶段练习」 密码篇 1. 操作环境准备 2. 密码学简介 3. 对称密钥加密 4. 公开密钥加密 5. 实际应用 6. 密码猜解 7. 并行密码猜解 *. PyCryptodome示例「扩展」 网络篇 1. 操作环境准备 2. HTTP协议 3. Web爬虫 4. TCP通信 5. UDP通信 6. 端口扫描 7. 并发端口扫描 隐写术 1. 操作环境准备 2. 文件隐写术 2. 图像处理 6. 图像隐写术 3. QRCode 5. 图文隐写术 7. 将游戏存入图像 影像处理 1. 操作环境准备 2. OpenCV简介 3. 调用摄像头 4. 数据传输 5. 目标检测 6. 人脸识别 7. 视频编辑 数据分析 1. 操作环境准备 2. 多维数组的数值操作 3. 数据可视化 4. 资料的载入与导出 5. 矩阵运算 6. 最小二乘拟合 7. 聚类分析 人工神经网络 1. 操作环境准备 2. 逻辑回归 3. Softmax多分类 4. 多层感知器 5. Relu激活函数 6. 卷积神经网络 7. 批量标准化 "
            }
    
        ,
            {
                "id": 95,
                "href": "https://bxtkezhan.github.io/%E6%94%AF%E6%8C%81while%E8%AF%AD%E5%8F%A5/",
                "title": "支持While语句",
                "section": "posts",
                "date" : "2021.03.31",
                "body": "返回教程主页\n上篇 支持If语句\n下面我们来让程序语言支持While语句，这会使得bkcalclang能够解决一些依赖循环结构处理的问题。\n这次的代码以上一篇《支持If语句》的代码为基础编写，如果发现不熟悉当下的内容可以回顾一下之前的篇章。\n同样，直接放出代码清单有点劝退，先进行内容讲解。\n定义While节点的结构体 type While struct { condition Node then *Block } func NewWhile(condition Node, then *Block) *While { return \u0026amp;While{condition: condition, then: then} } While结构当中condition存储判断表达式节点，then存储代码块，使用NewWhile函数实例化。\n定义While节点的运行方法 func (while *While) Eval() float64 { for while.condition.Eval() != 0 { while.then.Eval(); } return 0. } 在循环结构中如果While的condition运行后的值不为0则始终运行代码块then，否则中断循环并返回0。\n处理While语句的解析 } else if token.Name == \u0026#34;WHILE\u0026#34; { lexer.NextToken() condition := parse_binary_add(lexer) if (condition == nil) { return nil } token = lexer.GetToken() if token.Name != \u0026#34;THEN\u0026#34; { return nil } then := parse(lexer) if then == nil { return nil } isBlockEnd = false return NewWhile(condition, then) 我们在parse_statement函数中编写处理While语句的内容。\n如果检测到token.Name为WHILE则尝试进行While语法解析，先跳过当前token然后进行表达式解析，若解析成功则将其作为While结构的condition成员:\n} else if token.Name == \u0026#34;WHILE\u0026#34; { lexer.NextToken() condition := parse_binary_add(lexer) if (condition == nil) { return nil } 接下来取出下一个token判断如果为THEN就进行代码块解析，否则返回nil，在返回NewWhile前，我们需要设定isBlockEnd为false:\ntoken = lexer.GetToken() if token.Name != \u0026#34;THEN\u0026#34; { return nil } then := parse(lexer) if then == nil { return nil } isBlockEnd = false return NewWhile(condition, then) 定义词法解析器规则 lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;NAME\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddRule(\u0026#34;=\u0026#34;, \u0026#34;ASSIGN\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) lexer.AddIgnores(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;) lexer.AddReserve(\u0026#34;set\u0026#34;) lexer.AddReserve(\u0026#34;echo\u0026#34;) lexer.AddReserve(\u0026#34;if\u0026#34;) lexer.AddReserve(\u0026#34;while\u0026#34;) lexer.AddReserve(\u0026#34;then\u0026#34;) lexer.AddReserve(\u0026#34;end\u0026#34;) 这里我们需要添加while保留字。\n使用一段测试脚本进行测试 测试内容【斐波那契数列】:\nset n = 15 set a = 0 set b = 1 while n then set n = n - 1 set b = a + b set a = b - a echo a end 运行结果:\n➜ go calc.go := 1 := 1 := 2 := 3 := 5 := 8 := 13 := 21 := 34 := 55 := 89 := 144 := 233 := 377 := 610 代码清单 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;./bklexer\u0026#34; ) var valueDict map[string]float64 var isBlockEnd bool = false type Node interface { Eval() float64 } type Block struct { statements []Node } func NewBlock() *Block { return \u0026amp;Block{} } func (block *Block) AddStatement(statement Node) { block.statements = append(block.statements, statement) } func (block *Block) Eval() { for _, statement := range block.statements { statement.Eval() } } type Number struct { value float64 } func NewNumber(token *BKLexer.Token) *Number { value, _ := strconv.ParseFloat(token.Source, 64) return \u0026amp;Number{value: value} } func (number *Number) Eval() float64 { return number.value } type Name struct { name string } func NewName(token *BKLexer.Token) *Name { return \u0026amp;Name{name: token.Source} } func (name *Name) Eval() float64 { if value, found := valueDict[name.name]; found { return value; } return 0. } type BinaryOpt struct { opt string lhs Node rhs Node } func NewBinaryOpt(token *BKLexer.Token, lhs Node, rhs Node) *BinaryOpt { return \u0026amp;BinaryOpt{opt: token.Source, lhs: lhs, rhs: rhs} } func (binaryOpt *BinaryOpt) Eval() float64 { lhs, rhs := binaryOpt.lhs, binaryOpt.rhs switch binaryOpt.opt { case \u0026#34;+\u0026#34;: return lhs.Eval() + rhs.Eval() case \u0026#34;-\u0026#34;: return lhs.Eval() - rhs.Eval() case \u0026#34;*\u0026#34;: return lhs.Eval() * rhs.Eval() case \u0026#34;/\u0026#34;: return lhs.Eval() / rhs.Eval() } return 0 } type Assign struct { name string value Node } func NewAssign(token *BKLexer.Token, value Node) *Assign { return \u0026amp;Assign{name: token.Source, value: value} } func (assign *Assign) Eval() float64 { value := assign.value.Eval() valueDict[assign.name] = value return value } type Echo struct { value Node } func NewEcho(value Node) *Echo { return \u0026amp;Echo{value: value} } func (echo *Echo) Eval() float64 { value := echo.value.Eval() fmt.Println(\u0026#34;:=\u0026#34;, value) return value } type If struct { condition Node then *Block } func NewIf(condition Node, then *Block) *If { return \u0026amp;If{condition: condition, then: then} } func (_if *If) Eval() float64 { condition := _if.condition.Eval() if condition != 0 { _if.then.Eval(); } return 0. } type While struct { condition Node then *Block } func NewWhile(condition Node, then *Block) *While { return \u0026amp;While{condition: condition, then: then} } func (while *While) Eval() float64 { for while.condition.Eval() != 0 { while.then.Eval(); } return 0. } func parse(lexer *BKLexer.Lexer) *Block { block := NewBlock() token := lexer.NextToken() for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } for token.TType != BKLexer.TOKEN_TYPE_EOF { statement := parse_statement(lexer) if isBlockEnd { return block } if statement == nil { return nil; } token = lexer.GetToken() if token.TType != BKLexer.TOKEN_TYPE_NEWLINE \u0026amp;\u0026amp; token.TType != BKLexer.TOKEN_TYPE_EOF { return nil; } block.AddStatement(statement) for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } } return block } func parse_statement(lexer *BKLexer.Lexer) Node { token := lexer.GetToken() if token.Name == \u0026#34;SET\u0026#34; { name := lexer.NextToken() if name.Name != \u0026#34;NAME\u0026#34; { return nil } token = lexer.NextToken() if token.Name != \u0026#34;ASSIGN\u0026#34; { return nil } lexer.NextToken() value := parse_binary_add(lexer) if value == nil { return nil } return NewAssign(name, value) } else if token.Name == \u0026#34;ECHO\u0026#34; { lexer.NextToken() value := parse_binary_add(lexer) if (value == nil) { return nil } return NewEcho(value) } else if token.Name == \u0026#34;IF\u0026#34; { lexer.NextToken() condition := parse_binary_add(lexer) if (condition == nil) { return nil } token = lexer.GetToken() if token.Name != \u0026#34;THEN\u0026#34; { return nil } then := parse(lexer) if then == nil { return nil } isBlockEnd = false return NewIf(condition, then) } else if token.Name == \u0026#34;WHILE\u0026#34; { lexer.NextToken() condition := parse_binary_add(lexer) if (condition == nil) { return nil } token = lexer.GetToken() if token.Name != \u0026#34;THEN\u0026#34; { return nil } then := parse(lexer) if then == nil { return nil } isBlockEnd = false return NewWhile(condition, then) } else if token.Name == \u0026#34;END\u0026#34; { lexer.NextToken() isBlockEnd = true return nil } return parse_binary_add(lexer) } func parse_binary_add(lexer *BKLexer.Lexer) Node { lhs := parse_binary_mul(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;+\u0026#34; || token.Source == \u0026#34;-\u0026#34; { lexer.NextToken() rhs := parse_binary_mul(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func parse_binary_mul(lexer *BKLexer.Lexer) Node { lhs := factor(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;*\u0026#34; || token.Source == \u0026#34;/\u0026#34; { lexer.NextToken() rhs := factor(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func factor(lexer *BKLexer.Lexer) Node { token := lexer.GetToken() if token.Name == \u0026#34;LPAR\u0026#34; { lexer.NextToken() expr := parse_binary_add(lexer) if expr == nil { return nil } token := lexer.GetToken() if token.Name != \u0026#34;RPAR\u0026#34; { return nil } lexer.NextToken() return expr } if token.Name == \u0026#34;NUMBER\u0026#34; { number := NewNumber(token) lexer.NextToken() return number } if token.Name == \u0026#34;NAME\u0026#34; { name := NewName(token) lexer.NextToken() return name } return nil } func main() { lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;NAME\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddRule(\u0026#34;=\u0026#34;, \u0026#34;ASSIGN\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) lexer.AddIgnores(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;) lexer.AddReserve(\u0026#34;set\u0026#34;) lexer.AddReserve(\u0026#34;echo\u0026#34;) lexer.AddReserve(\u0026#34;if\u0026#34;) lexer.AddReserve(\u0026#34;while\u0026#34;) lexer.AddReserve(\u0026#34;then\u0026#34;) lexer.AddReserve(\u0026#34;end\u0026#34;) bytes, err := ioutil.ReadFile(\u0026#34;../test.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;read faild\u0026#34;) return } code := string(bytes) lexer.Build(code) result := parse(lexer) if result == nil { fmt.Println(\u0026#34;null result\u0026#34;) return } valueDict = make(map[string]float64) result.Eval() } "
            }
    
        ,
            {
                "id": 96,
                "href": "https://bxtkezhan.github.io/%E6%94%AF%E6%8C%81if%E8%AF%AD%E5%8F%A5/",
                "title": "支持If语句",
                "section": "posts",
                "date" : "2021.03.29",
                "body": "返回教程主页\n上篇 使程序语言支持变量\n下面我们来让程序语言支持If语句，这会使得bkcalclang能够处理更加复杂的问题。\n这次的代码以上一篇《使程序语言支持变量》的代码为基础编写，如果发现不熟悉当下的内容可以回顾一下之前的篇章。\n直接放出代码清单有点劝退，先进行内容讲解。\n定义If节点的结构体 type If struct { condition Node then *Block } func NewIf(condition Node, then *Block) *If { return \u0026amp;If{condition: condition, then: then} } If结构当中condition存储判断表达式节点，then存储代码块，使用NewIf函数实例化。\n定义If节点的运行方法 func (_if *If) Eval() float64 { condition := _if.condition.Eval() if condition != 0 { _if.then.Eval(); } return 0. } 如果If的condition运行后的值不为0则运行代码块then，否则不运行。\n处理If语句的解析 } else if token.Name == \u0026#34;IF\u0026#34; { lexer.NextToken() condition := parse_binary_add(lexer) if (condition == nil) { return nil } token = lexer.GetToken() if token.Name != \u0026#34;THEN\u0026#34; { return nil } then := parse(lexer) if then == nil { return nil } isBlockEnd = false return NewIf(condition, then) } else if token.Name == \u0026#34;END\u0026#34; { lexer.NextToken() isBlockEnd = true return nil } 我们在parse_statement函数中编写处理If语句的内容。\n如果检测到token.Name为IF则尝试进行If语法解析，先跳过当前token然后进行表达式解析，若解析成功则将其作为If结构的condition成员:\n} else if token.Name == \u0026#34;IF\u0026#34; { lexer.NextToken() condition := parse_binary_add(lexer) if (condition == nil) { return nil } 接下来取出下一个token判断如果为THEN就进行代码块解析，否则返回nil，在返回NewIf前，我们需要设定isBlockEnd为false，它是一个用于parse函数判断是否需要提前返回的全局变量:\ntoken = lexer.GetToken() if token.Name != \u0026#34;THEN\u0026#34; { return nil } then := parse(lexer) if then == nil { return nil } isBlockEnd = false return NewIf(condition, then) 我们需要在parse函数中利用isBlockEnd判断当前代码块是否结束:\nfunc parse(lexer *BKLexer.Lexer) *Block { block := NewBlock() token := lexer.NextToken() for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } for token.TType != BKLexer.TOKEN_TYPE_EOF { statement := parse_statement(lexer) if isBlockEnd { return block } 当遇到token.Name为END，我们需要设置isBlockEnd为true用以终结当前代码块。\n} else if token.Name == \u0026#34;END\u0026#34; { lexer.NextToken() isBlockEnd = true return nil } 定义词法解析器规则 lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;NAME\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddRule(\u0026#34;=\u0026#34;, \u0026#34;ASSIGN\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) lexer.AddIgnores(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;) lexer.AddReserve(\u0026#34;set\u0026#34;) lexer.AddReserve(\u0026#34;echo\u0026#34;) lexer.AddReserve(\u0026#34;if\u0026#34;) lexer.AddReserve(\u0026#34;then\u0026#34;) lexer.AddReserve(\u0026#34;end\u0026#34;) 这里我们需要添加if、then、end保留字。\n使用一段测试脚本进行测试 测试内容:\nset a = 2 if a then echo a set a = a - 1 if a then echo a set a = a - 1 if a then echo a end end end echo a 运行结果:\n➜ go calc.go := 2 := 1 := 0 代码清单 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;./bklexer\u0026#34; ) var valueDict map[string]float64 var isBlockEnd bool = false type Node interface { Eval() float64 } type Block struct { statements []Node } func NewBlock() *Block { return \u0026amp;Block{} } func (block *Block) AddStatement(statement Node) { block.statements = append(block.statements, statement) } func (block *Block) Eval() { for _, statement := range block.statements { statement.Eval() } } type Number struct { value float64 } func NewNumber(token *BKLexer.Token) *Number { value, _ := strconv.ParseFloat(token.Source, 64) return \u0026amp;Number{value: value} } func (number *Number) Eval() float64 { return number.value } type Name struct { name string } func NewName(token *BKLexer.Token) *Name { return \u0026amp;Name{name: token.Source} } func (name *Name) Eval() float64 { if value, found := valueDict[name.name]; found { return value; } return 0. } type BinaryOpt struct { opt string lhs Node rhs Node } func NewBinaryOpt(token *BKLexer.Token, lhs Node, rhs Node) *BinaryOpt { return \u0026amp;BinaryOpt{opt: token.Source, lhs: lhs, rhs: rhs} } func (binaryOpt *BinaryOpt) Eval() float64 { lhs, rhs := binaryOpt.lhs, binaryOpt.rhs switch binaryOpt.opt { case \u0026#34;+\u0026#34;: return lhs.Eval() + rhs.Eval() case \u0026#34;-\u0026#34;: return lhs.Eval() - rhs.Eval() case \u0026#34;*\u0026#34;: return lhs.Eval() * rhs.Eval() case \u0026#34;/\u0026#34;: return lhs.Eval() / rhs.Eval() } return 0 } type Assign struct { name string value Node } func NewAssign(token *BKLexer.Token, value Node) *Assign { return \u0026amp;Assign{name: token.Source, value: value} } func (assign *Assign) Eval() float64 { value := assign.value.Eval() valueDict[assign.name] = value return value } type Echo struct { value Node } func NewEcho(value Node) *Echo { return \u0026amp;Echo{value: value} } func (echo *Echo) Eval() float64 { value := echo.value.Eval() fmt.Println(\u0026#34;:=\u0026#34;, value) return value } type If struct { condition Node then *Block } func NewIf(condition Node, then *Block) *If { return \u0026amp;If{condition: condition, then: then} } func (_if *If) Eval() float64 { condition := _if.condition.Eval() if condition != 0 { _if.then.Eval(); } return 0. } func parse(lexer *BKLexer.Lexer) *Block { block := NewBlock() token := lexer.NextToken() for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } for token.TType != BKLexer.TOKEN_TYPE_EOF { statement := parse_statement(lexer) if isBlockEnd { return block } if statement == nil { return nil; } token = lexer.GetToken() if token.TType != BKLexer.TOKEN_TYPE_NEWLINE \u0026amp;\u0026amp; token.TType != BKLexer.TOKEN_TYPE_EOF { return nil; } block.AddStatement(statement) for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } } return block } func parse_statement(lexer *BKLexer.Lexer) Node { token := lexer.GetToken() if token.Name == \u0026#34;SET\u0026#34; { name := lexer.NextToken() if name.Name != \u0026#34;NAME\u0026#34; { return nil } token = lexer.NextToken() if token.Name != \u0026#34;ASSIGN\u0026#34; { return nil } lexer.NextToken() value := parse_binary_add(lexer) if value == nil { return nil } return NewAssign(name, value) } else if token.Name == \u0026#34;ECHO\u0026#34; { lexer.NextToken() value := parse_binary_add(lexer) if (value == nil) { return nil } return NewEcho(value) } else if token.Name == \u0026#34;IF\u0026#34; { lexer.NextToken() condition := parse_binary_add(lexer) if (condition == nil) { return nil } token = lexer.GetToken() if token.Name != \u0026#34;THEN\u0026#34; { return nil } then := parse(lexer) if then == nil { return nil } isBlockEnd = false return NewIf(condition, then) } else if token.Name == \u0026#34;END\u0026#34; { lexer.NextToken() isBlockEnd = true return nil } return parse_binary_add(lexer) } func parse_binary_add(lexer *BKLexer.Lexer) Node { lhs := parse_binary_mul(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;+\u0026#34; || token.Source == \u0026#34;-\u0026#34; { lexer.NextToken() rhs := parse_binary_mul(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func parse_binary_mul(lexer *BKLexer.Lexer) Node { lhs := factor(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;*\u0026#34; || token.Source == \u0026#34;/\u0026#34; { lexer.NextToken() rhs := factor(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func factor(lexer *BKLexer.Lexer) Node { token := lexer.GetToken() if token.Name == \u0026#34;LPAR\u0026#34; { lexer.NextToken() expr := parse_binary_add(lexer) if expr == nil { return nil } token := lexer.GetToken() if token.Name != \u0026#34;RPAR\u0026#34; { return nil } lexer.NextToken() return expr } if token.Name == \u0026#34;NUMBER\u0026#34; { number := NewNumber(token) lexer.NextToken() return number } if token.Name == \u0026#34;NAME\u0026#34; { name := NewName(token) lexer.NextToken() return name } return nil } func main() { lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;NAME\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddRule(\u0026#34;=\u0026#34;, \u0026#34;ASSIGN\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) lexer.AddIgnores(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;) lexer.AddReserve(\u0026#34;set\u0026#34;) lexer.AddReserve(\u0026#34;echo\u0026#34;) lexer.AddReserve(\u0026#34;if\u0026#34;) lexer.AddReserve(\u0026#34;then\u0026#34;) lexer.AddReserve(\u0026#34;end\u0026#34;) bytes, err := ioutil.ReadFile(\u0026#34;../test.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;read faild\u0026#34;) return } code := string(bytes) lexer.Build(code) result := parse(lexer) if result == nil { fmt.Println(\u0026#34;null result\u0026#34;) return } valueDict = make(map[string]float64) result.Eval() } 下篇 支持While语句\n"
            }
    
        ,
            {
                "id": 97,
                "href": "https://bxtkezhan.github.io/%E4%BD%BF%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%E5%8F%98%E9%87%8F/",
                "title": "使程序语言支持变量",
                "section": "posts",
                "date" : "2021.03.26",
                "body": "返回教程主页\n上篇 使计算器支持语句块\n下面我们来让计算器程序支持变量的使用，使得程序可以设置和获取变量的值。从现在开始我将不掩藏我们要实现的是一个程序语言，因为出自计算器所以命名为 bkcalclang\n这次的代码以上一篇《使计算器支持语句块》的代码为基础编写，如果发现不熟悉当下的内容可以回顾一下之前的篇章。\n代码清单【go语言为例】 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;./bklexer\u0026#34; ) var ValueDict map[string]float64 type Node interface { Eval() float64 } type Block struct { statements []Node } func NewBlock() *Block { return \u0026amp;Block{} } func (block *Block) AddStatement(statement Node) { block.statements = append(block.statements, statement) } func (block *Block) Eval() { for _, statement := range block.statements { statement.Eval() } } type Number struct { value float64 } func NewNumber(token *BKLexer.Token) *Number { value, _ := strconv.ParseFloat(token.Source, 64) return \u0026amp;Number{value: value} } func (number *Number) Eval() float64 { return number.value } type Name struct { name string } func NewName(token *BKLexer.Token) *Name { return \u0026amp;Name{name: token.Source} } func (name *Name) Eval() float64 { if value, found := ValueDict[name.name]; found { return value; } return 0. } type BinaryOpt struct { opt string lhs Node rhs Node } func NewBinaryOpt(token *BKLexer.Token, lhs Node, rhs Node) *BinaryOpt { return \u0026amp;BinaryOpt{opt: token.Source, lhs: lhs, rhs: rhs} } func (binaryOpt *BinaryOpt) Eval() float64 { lhs, rhs := binaryOpt.lhs, binaryOpt.rhs switch binaryOpt.opt { case \u0026#34;+\u0026#34;: return lhs.Eval() + rhs.Eval() case \u0026#34;-\u0026#34;: return lhs.Eval() - rhs.Eval() case \u0026#34;*\u0026#34;: return lhs.Eval() * rhs.Eval() case \u0026#34;/\u0026#34;: return lhs.Eval() / rhs.Eval() } return 0 } type Assign struct { name string value Node } func NewAssign(token *BKLexer.Token, value Node) *Assign { return \u0026amp;Assign{name: token.Source, value: value} } func (assign *Assign) Eval() float64 { value := assign.value.Eval() ValueDict[assign.name] = value return value } type Echo struct { value Node } func NewEcho(value Node) *Echo { return \u0026amp;Echo{value: value} } func (echo *Echo) Eval() float64 { value := echo.value.Eval() fmt.Println(\u0026#34;:=\u0026#34;, value) return value } func parse(lexer *BKLexer.Lexer) *Block { block := NewBlock() token := lexer.NextToken() for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } for token.TType != BKLexer.TOKEN_TYPE_EOF { statement := parse_statement(lexer) if statement == nil { return nil; } token = lexer.GetToken() if token.TType != BKLexer.TOKEN_TYPE_NEWLINE \u0026amp;\u0026amp; token.TType != BKLexer.TOKEN_TYPE_EOF { return nil; } block.AddStatement(statement) for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } } return block } func parse_statement(lexer *BKLexer.Lexer) Node { token := lexer.GetToken() if token.Name == \u0026#34;SET\u0026#34; { name := lexer.NextToken() if name.Name != \u0026#34;NAME\u0026#34; { return nil } token = lexer.NextToken() if token.Name != \u0026#34;ASSIGN\u0026#34; { return nil } lexer.NextToken() value := parse_binary_add(lexer) if value == nil { return nil } return NewAssign(name, value) } else if token.Name == \u0026#34;ECHO\u0026#34; { lexer.NextToken() value := parse_binary_add(lexer) if (value == nil) { return nil } return NewEcho(value) } return parse_binary_add(lexer) } func parse_binary_add(lexer *BKLexer.Lexer) Node { lhs := parse_binary_mul(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;+\u0026#34; || token.Source == \u0026#34;-\u0026#34; { lexer.NextToken() rhs := parse_binary_mul(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func parse_binary_mul(lexer *BKLexer.Lexer) Node { lhs := factor(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;*\u0026#34; || token.Source == \u0026#34;/\u0026#34; { lexer.NextToken() rhs := factor(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func factor(lexer *BKLexer.Lexer) Node { token := lexer.GetToken() if token.Name == \u0026#34;LPAR\u0026#34; { lexer.NextToken() expr := parse_binary_add(lexer) if expr == nil { return nil } token := lexer.GetToken() if token.Name != \u0026#34;RPAR\u0026#34; { return nil } lexer.NextToken() return expr } if token.Name == \u0026#34;NUMBER\u0026#34; { number := NewNumber(token) lexer.NextToken() return number } if token.Name == \u0026#34;NAME\u0026#34; { name := NewName(token) lexer.NextToken() return name } return nil } func main() { lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;NAME\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddRule(\u0026#34;=\u0026#34;, \u0026#34;ASSIGN\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) lexer.AddIgnores(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;) lexer.AddReserve(\u0026#34;set\u0026#34;) lexer.AddReserve(\u0026#34;echo\u0026#34;) bytes, err := ioutil.ReadFile(\u0026#34;../test.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;read faild\u0026#34;) return } code := string(bytes) lexer.Build(code) result := parse(lexer) if result == nil { fmt.Println(\u0026#34;null result\u0026#34;) return } ValueDict = make(map[string]float64) result.Eval() } 引入需要使用的包 import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;./bklexer\u0026#34; ) fmt 打印输出 strconv 字符串转换 io/ioutil 读取文件 ./bklexer 用于词法解析 声明用于存储变量值的字典 var ValueDict map[string]float64 我们会使用一个map类型的对象来存取值，并以此实现变量赋值和取值的操作。\n定义命名节点结构体 type Name struct { name string } func NewName(token *BKLexer.Token) *Name { return \u0026amp;Name{name: token.Source} } Name结构体用于变量取值相关操作，函数NewName接收参数*BKLexer.Token并实例化Name。\n定义命名节点的运行方法 func (name *Name) Eval() float64 { if value, found := ValueDict[name.name]; found { return value; } return 0. } 原本Node的GetValue方法改名为Eval，这一点同样作用于其它相关结构体，需要注意。Name的Eval方法会查找ValueDict中的对应值并返回，如果不存在则返回0。\n定义赋值节点结构体 type Assign struct { name string value Node } func NewAssign(token *BKLexer.Token, value Node) *Assign { return \u0026amp;Assign{name: token.Source, value: value} } 定义Assign结构用于存放赋值语句信息，name为变量名，value为对应值的节点结构。使用NewAssign函数可以实例化Assign结构。\n定义赋值节点的运行方法 func (assign *Assign) Eval() float64 { value := assign.value.Eval() ValueDict[assign.name] = value return value } 该方法在执行时会将成员value的执行结果存入到ValueDict中然后返回该值。\n定义输出节点的结构 type Echo struct { value Node } func NewEcho(value Node) *Echo { return \u0026amp;Echo{value: value} } Echo结构存储一个类型为Node的成员value，我们使用NewEcho实例化它。\n定义输出节点的运行方法 func (echo *Echo) Eval() float64 { value := echo.value.Eval() fmt.Println(\u0026#34;:=\u0026#34;, value) return value } 在该方法中，我们先取得echo成员value的值然后将其打印输出，最后返回该值。\n增加一个函数用于专门处理语句 由于我们使用parse_statement函数作为处理语句的函数，所以我们在某些地方需要做出相应的修改，如语法解析的入口parse函数:\nfor token.TType != BKLexer.TOKEN_TYPE_EOF { statement := parse_statement(lexer) if statement == nil { return nil; } 我们定义如下函数处理语句 func parse_statement(lexer *BKLexer.Lexer) Node { token := lexer.GetToken() if token.Name == \u0026#34;SET\u0026#34; { name := lexer.NextToken() if name.Name != \u0026#34;NAME\u0026#34; { return nil } token = lexer.NextToken() if token.Name != \u0026#34;ASSIGN\u0026#34; { return nil } lexer.NextToken() value := parse_binary_add(lexer) if value == nil { return nil } return NewAssign(name, value) } else if token.Name == \u0026#34;ECHO\u0026#34; { lexer.NextToken() value := parse_binary_add(lexer) if (value == nil) { return nil } return NewEcho(value) } return parse_binary_add(lexer) } 如果发现起头的token名称为SET则判断为赋值操作，取下一个token作为变量名，再取下一个判断是否为赋值符号，如果都成功则解析后面的内容并以此构建赋值节点。\nif token.Name == \u0026#34;SET\u0026#34; { name := lexer.NextToken() if name.Name != \u0026#34;NAME\u0026#34; { return nil } token = lexer.NextToken() if token.Name != \u0026#34;ASSIGN\u0026#34; { return nil } lexer.NextToken() value := parse_binary_add(lexer) if value == nil { return nil } return NewAssign(name, value) 如果当前token名称为ECHO则判断为打印输出，需要跳过当前token并进行表达式解析。如果成功解析则用解析结果构建打印输出节点并返回，否则函数返回nil。\n} else if token.Name == \u0026#34;ECHO\u0026#34; { lexer.NextToken() value := parse_binary_add(lexer) if (value == nil) { return nil } return NewEcho(value) } 增加变量取值的解析 将之前的parse_number函数改名为factor【这并不是必要操作】:\nfunc factor(lexer *BKLexer.Lexer) Node { 我们在factor函数中添加变量名解析代码:\nif token.Name == \u0026#34;NAME\u0026#34; { name := NewName(token) lexer.NextToken() return name } 定义词法解析器规则 lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;NAME\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddRule(\u0026#34;=\u0026#34;, \u0026#34;ASSIGN\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) lexer.AddIgnores(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;) lexer.AddReserve(\u0026#34;set\u0026#34;) lexer.AddReserve(\u0026#34;echo\u0026#34;) 这里我们需要添加变量名规则、赋值符号规则以及增加set、echo这两个保留字。\n读取文件进行解析计算 bytes, err := ioutil.ReadFile(\u0026#34;../test.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;read faild\u0026#34;) return } code := string(bytes) lexer.Build(code) result := parse(lexer) if result == nil { fmt.Println(\u0026#34;null result\u0026#34;) return } ValueDict = make(map[string]float64) result.Eval() 需要注意，我们在执行result.Eval()之前必须先实例化ValueDict。\n使用一段测试脚本进行测试 测试内容:\necho 1 + 2 # plus echo 3 - 4 # here is a comment echo 5 * 6 # mul echo 7 / 8 echo 1 + (2 - 3) * 4 / 5 # composite set pi = 3.14 set r = 5 echo 2 * pi * r * r 运行结果:\n➜ go run calc.go := 3 := -1 := 30 := 0.875 := 0.19999999999999996 := 157 下篇 支持If语句\n"
            }
    
        ,
            {
                "id": 98,
                "href": "https://bxtkezhan.github.io/%E4%BD%BF%E8%AE%A1%E7%AE%97%E5%99%A8%E6%94%AF%E6%8C%81%E8%AF%AD%E5%8F%A5%E5%9D%97/",
                "title": "使计算器支持语句块",
                "section": "posts",
                "date" : "2021.03.24",
                "body": "返回教程主页\n上篇 递归向下算法实现Calc\n下面我们来为计算器程序增加语句块功能，使得程序可以做批量运算，类似于程序语言中的代码块。\n这次的代码以上一篇《递归向下算法实现Calc》的代码为基础编写，如果发现不熟悉当下的内容可以回顾一下之前的篇章。\n代码清单【go语言为例】 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;./bklexer\u0026#34; ) type Node interface { GetValue() float64 } type Block struct { statements []Node } func NewBlock() *Block { return \u0026amp;Block{} } func (block *Block) AddStatement(statement Node) { block.statements = append(block.statements, statement) } func (block *Block) Eval() { for i, statement := range block.statements { fmt.Printf(\u0026#34;out[%d] = %f\\n\u0026#34;, i, statement.GetValue()) } } type Number struct { value float64 } func NewNumber(token *BKLexer.Token) *Number { value, _ := strconv.ParseFloat(token.Source, 64) return \u0026amp;Number{value: value} } func (number *Number) GetValue() float64 { return number.value } type BinaryOpt struct { opt string lhs Node rhs Node } func NewBinaryOpt(token *BKLexer.Token, lhs Node, rhs Node) *BinaryOpt { return \u0026amp;BinaryOpt{opt: token.Source, lhs: lhs, rhs: rhs} } func (binaryOpt *BinaryOpt) GetValue() float64 { lhs, rhs := binaryOpt.lhs, binaryOpt.rhs switch binaryOpt.opt { case \u0026#34;+\u0026#34;: return lhs.GetValue() + rhs.GetValue() case \u0026#34;-\u0026#34;: return lhs.GetValue() - rhs.GetValue() case \u0026#34;*\u0026#34;: return lhs.GetValue() * rhs.GetValue() case \u0026#34;/\u0026#34;: return lhs.GetValue() / rhs.GetValue() } return 0 } func parse(lexer *BKLexer.Lexer) *Block { block := NewBlock() token := lexer.NextToken() for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } for token.TType != BKLexer.TOKEN_TYPE_EOF { statement := parse_binary_add(lexer) if statement == nil { return nil; } token = lexer.GetToken() if token.TType != BKLexer.TOKEN_TYPE_NEWLINE \u0026amp;\u0026amp; token.TType != BKLexer.TOKEN_TYPE_EOF { return nil; } block.AddStatement(statement) for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } } return block } func parse_binary_add(lexer *BKLexer.Lexer) Node { lhs := parse_binary_mul(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;+\u0026#34; || token.Source == \u0026#34;-\u0026#34; { lexer.NextToken() rhs := parse_binary_mul(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func parse_binary_mul(lexer *BKLexer.Lexer) Node { lhs := parse_number(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;*\u0026#34; || token.Source == \u0026#34;/\u0026#34; { lexer.NextToken() rhs := parse_number(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func parse_number(lexer *BKLexer.Lexer) Node { token := lexer.GetToken() if token.Name == \u0026#34;LPAR\u0026#34; { lexer.NextToken() expr := parse_binary_add(lexer) if expr == nil { return nil } token := lexer.GetToken() if token.Name != \u0026#34;RPAR\u0026#34; { return nil } lexer.NextToken() return expr } if token.Name == \u0026#34;NUMBER\u0026#34; { number := NewNumber(token) lexer.NextToken() return number } return nil } func main() { fmt.Println(\u0026#34;Hello My Calc.\u0026#34;) lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) lexer.AddIgnores(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;) bytes, err := ioutil.ReadFile(\u0026#34;../test.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;read faild\u0026#34;) return } code := string(bytes) fmt.Println(code) lexer.Build(code) result := parse(lexer) if result == nil { fmt.Println(\u0026#34;null result\u0026#34;) return } result.Eval() } 引入需要使用的包 import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;./bklexer\u0026#34; ) fmt 打印输出 strconv 字符串转换 io/ioutil 读取文件 ./bklexer 用于词法解析 定义语句块结构体 type Block struct { statements []Node } func NewBlock() *Block { return \u0026amp;Block{} } Block结构的成员statements用于存储每一条语句，我们使用NewBlock方法实例这个结构。\n为语句块结构添加成员方法 func (block *Block) AddStatement(statement Node) { block.statements = append(block.statements, statement) } func (block *Block) Eval() { for i, statement := range block.statements { fmt.Printf(\u0026#34;out[%d] = %f\\n\u0026#34;, i, statement.GetValue()) } } AddStatement用于插入新的语句，Eval用于批量计算结果并打印出来。\n定义语法解释器入口函数 func parse(lexer *BKLexer.Lexer) *Block { block := NewBlock() token := lexer.NextToken() for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } for token.TType != BKLexer.TOKEN_TYPE_EOF { statement := parse_binary_add(lexer) if statement == nil { return nil; } token = lexer.GetToken() if token.TType != BKLexer.TOKEN_TYPE_NEWLINE \u0026amp;\u0026amp; token.TType != BKLexer.TOKEN_TYPE_EOF { return nil; } block.AddStatement(statement) for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } } return block } parse中首先实例一个block结构对象，然后开始解析Token，使用循环解析的方法依序解析得到每一条statement并插入block中，最后返回block。\n需要注意的是我们每一条语句的末尾要么是换行要么是结尾，否则将被视为解析错误并返回nil:\ntoken = lexer.GetToken() if token.TType != BKLexer.TOKEN_TYPE_NEWLINE \u0026amp;\u0026amp; token.TType != BKLexer.TOKEN_TYPE_EOF { return nil; } 在我们解析完一条语句后，应当马上越过后面的换行符，这可以使得我们在批量计算中忽略空白行:\nfor token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } 有几处修改需要注意 func parse_number(lexer *BKLexer.Lexer) Node { token := lexer.GetToken() ...... 在parse_number函数中，token := lexer.NextToken()变为token := lexer.GetToken()，因此我们需要确保各个解析函数互相调用时需要先主动在当前函数中调用NextToken()方法。\n例如:\n...... func parse(lexer *BKLexer.Lexer) *Block { ...... token := lexer.NextToken() for token.TType == BKLexer.TOKEN_TYPE_NEWLINE { token = lexer.NextToken() } for token.TType != BKLexer.TOKEN_TYPE_EOF { statement := parse_binary_add(lexer) ...... func parse_binary_add(lexer *BKLexer.Lexer) Node { ...... for token.Source == \u0026#34;+\u0026#34; || token.Source == \u0026#34;-\u0026#34; { lexer.NextToken() rhs := parse_binary_mul(lexer) ...... 定义词法解析器规则 lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) lexer.AddIgnores(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;) 需要注意的是这里对无效字符的设定还增加了新的规则lexer.AddIgnores(\u0026quot;#[^\\\\r\\\\n]*\u0026quot;)，这使得程序支持Python的注释语法。\n读取文件进行解析计算 bytes, err := ioutil.ReadFile(\u0026#34;../test.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;read faild\u0026#34;) return } code := string(bytes) fmt.Println(code) lexer.Build(code) result := parse(lexer) if result == nil { fmt.Println(\u0026#34;null result\u0026#34;) return } result.Eval() 使用一段测试脚本进行测试 测试内容:\n1 + 2 # plus 3 - 4 # here is a comment 5 * 6 # mul 7 / 8 1 + (2 - 3) * 4 / 5 # composite 运行结果:\n➜ go run calc.go Hello My Calc. 1 + 2 # plus 3 - 4 # here is a comment 5 * 6 # mul 7 / 8 1 + (2 - 3) * 4 / 5 # composite out[0] = 3.000000 out[1] = -1.000000 out[2] = 30.000000 out[3] = 0.875000 out[4] = 0.200000 下篇 使程序语言支持变量\n"
            }
    
        ,
            {
                "id": 99,
                "href": "https://bxtkezhan.github.io/%E9%80%92%E5%BD%92%E5%90%91%E4%B8%8B%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0calc/",
                "title": "递归向下算法实现Calc",
                "section": "posts",
                "date" : "2021.03.17",
                "body": "返回教程主页\n上篇 使用BKLexer进行词法分析\n利用递归向下算法结合我们的BKLexer实现支持四则运算与括号优先级的计算器程序。\n代码清单【Golang】\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;bufio\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;./bklexer\u0026#34; ) type Node interface { GetValue() float64 } type Number struct { value float64 } func NewNumber(token *BKLexer.Token) *Number { value, _ := strconv.ParseFloat(token.Source, 64) return \u0026amp;Number{value: value} } func (number *Number) GetValue() float64 { return number.value } type BinaryOpt struct { opt string lhs Node rhs Node } func NewBinaryOpt(token *BKLexer.Token, lhs Node, rhs Node) *BinaryOpt { return \u0026amp;BinaryOpt{opt: token.Source, lhs: lhs, rhs: rhs} } func (binaryOpt *BinaryOpt) GetValue() float64 { lhs, rhs := binaryOpt.lhs, binaryOpt.rhs switch binaryOpt.opt { case \u0026#34;+\u0026#34;: return lhs.GetValue() + rhs.GetValue() case \u0026#34;-\u0026#34;: return lhs.GetValue() - rhs.GetValue() case \u0026#34;*\u0026#34;: return lhs.GetValue() * rhs.GetValue() case \u0026#34;/\u0026#34;: return lhs.GetValue() / rhs.GetValue() } return 0 } func parse(lexer *BKLexer.Lexer) Node { result := parse_binary_add(lexer) token := lexer.GetToken() if token.TType != BKLexer.TOKEN_TYPE_EOF { return nil } return result } func parse_binary_add(lexer *BKLexer.Lexer) Node { lhs := parse_binary_mul(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;+\u0026#34; || token.Source == \u0026#34;-\u0026#34; { rhs := parse_binary_mul(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func parse_binary_mul(lexer *BKLexer.Lexer) Node { lhs := parse_number(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;*\u0026#34; || token.Source == \u0026#34;/\u0026#34; { rhs := parse_number(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } func parse_number(lexer *BKLexer.Lexer) Node { token := lexer.NextToken() if token.Name == \u0026#34;LPAR\u0026#34; { expr := parse_binary_add(lexer) if expr == nil { return nil } token := lexer.GetToken() if token.Name != \u0026#34;RPAR\u0026#34; { return nil } lexer.NextToken() return expr } if token.Name == \u0026#34;NUMBER\u0026#34; { number := NewNumber(token) lexer.NextToken() return number } return nil } func main() { fmt.Println(\u0026#34;Hello My Calc.\u0026#34;) lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) reader := bufio.NewReader(os.Stdin) for true { fmt.Print(\u0026#34;\u0026gt; \u0026#34;) inputs, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) inputs = strings.Trim(inputs, \u0026#34; \\f\\t\\n\u0026#34;) if inputs == \u0026#34;quit\u0026#34; { break } if inputs != \u0026#34;\u0026#34; { lexer.Build(inputs) result := parse(lexer) if result == nil { positon := lexer.GetToken().Col fmt.Println(\u0026#34;error in :\u0026#34;, positon) continue } fmt.Println(\u0026#34;out =\u0026#34;, result.GetValue()) } } fmt.Println(\u0026#34;bye!\u0026#34;) } 运行测试 ➜ go calc.go Hello My Calc. \u0026gt; 1 + (2 - 3) * 4 / 5 out = 0.19999999999999996 \u0026gt; quit bye! 引入需要的包 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;bufio\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;./bklexer\u0026#34; ) fmt 打印输出 os + bufio 读取用户输入 strings 处理字符串 strconv 解析字符串 bklexer 用于词法分析 定义接口 type Node interface { GetValue() float64 } Node作为接口将用于指向其它的结构，其GetValue方法可以获得节点的数值。\n定义数字节点 type Number struct { value float64 } func NewNumber(token *BKLexer.Token) *Number { value, _ := strconv.ParseFloat(token.Source, 64) return \u0026amp;Number{value: value} } Number作为数字类型的节点，有成员value用于存储数值，使用NewNumber函数可以实例它。\n实现数字节点的接口方法 func (number *Number) GetValue() float64 { return number.value } 定义运算操作节点 type BinaryOpt struct { opt string lhs Node rhs Node } func NewBinaryOpt(token *BKLexer.Token, lhs Node, rhs Node) *BinaryOpt { return \u0026amp;BinaryOpt{opt: token.Source, lhs: lhs, rhs: rhs} } BinaryOpt作为运算操作节点，成员opt记录运算符号，lhs、rhs分别为表达式左、右两边的内容，如1+2中的1与2。使用NewBinaryOpt函数实例它。\n实现运算节点的接口方法 func (binaryOpt *BinaryOpt) GetValue() float64 { lhs, rhs := binaryOpt.lhs, binaryOpt.rhs switch binaryOpt.opt { case \u0026#34;+\u0026#34;: return lhs.GetValue() + rhs.GetValue() case \u0026#34;-\u0026#34;: return lhs.GetValue() - rhs.GetValue() case \u0026#34;*\u0026#34;: return lhs.GetValue() * rhs.GetValue() case \u0026#34;/\u0026#34;: return lhs.GetValue() / rhs.GetValue() } return 0 } 我们需要根据运算操作符号opt判断lhs与rhs的值究竟以怎样的方式进行计算。\n定义语法解析的入口函数 func parse(lexer *BKLexer.Lexer) Node { result := parse_binary_add(lexer) token := lexer.GetToken() if token.TType != BKLexer.TOKEN_TYPE_EOF { return nil } return result } 入口函数parse接收到*BKLexer.Lexer类型的参数后，立即将其发送到parse_binary_add中，尝试解析运算等级与加法操作相同的运算操作。最后判断当前token是否为结尾，若不是则返回nil否则返回解析结果。\n定义加法等级运算操作的解析函数 func parse_binary_add(lexer *BKLexer.Lexer) Node { lhs := parse_binary_mul(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;+\u0026#34; || token.Source == \u0026#34;-\u0026#34; { rhs := parse_binary_mul(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } 当函数接收到参数lexer并运行时会先尝试解析乘法等级的运算操作，如果解析完毕并成功返回则判断当前token的字面量决定是否需要构建加法等级运算节点，如果需要则尝试进行另一个乘法等级的运算操作解析，解析成功则根据opt构建当前运算等级的节点对象。\n定义乘法等级运算操作的解析函数 func parse_binary_mul(lexer *BKLexer.Lexer) Node { lhs := parse_number(lexer) if lhs == nil { return nil } token := lexer.GetToken() for token.Source == \u0026#34;*\u0026#34; || token.Source == \u0026#34;/\u0026#34; { rhs := parse_number(lexer) if rhs == nil { return nil } lhs = NewBinaryOpt(token, lhs, rhs) token = lexer.GetToken() } return lhs } parse_binary_mul基本和parse_binary_add一样，只是在运行开始是尝试解析数字或括号表达式的内容，在判断需要构建乘法等级运算节点的时候也是尝试解析另一个数字或括号表达式的内容。\n定义数字与括号表达式的解析函数 func parse_number(lexer *BKLexer.Lexer) Node { token := lexer.NextToken() if token.Name == \u0026#34;LPAR\u0026#34; { expr := parse_binary_add(lexer) if expr == nil { return nil } token := lexer.GetToken() if token.Name != \u0026#34;RPAR\u0026#34; { return nil } lexer.NextToken() return expr } if token.Name == \u0026#34;NUMBER\u0026#34; { number := NewNumber(token) lexer.NextToken() return number } return nil } 首先取得下一个token，判断是否是左括号，如果是则可能为括号表达式，需要尝试进行解析，如果解析成功还需要判断结尾是否为右括号，全部成功则返回解析的表达式节点，否则返回nil。若一开始的token不是左括号而是数字则实例一个数字节点并返回。若既不是左括号又不是数字则返回nil。\n定义词法分析器规则 lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.?\\\\d*\u0026#34;, \u0026#34;NUMBER\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;\\\\(\u0026#34;, \u0026#34;LPAR\u0026#34;) lexer.AddRule(\u0026#34;\\\\)\u0026#34;, \u0026#34;RPAR\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) 循环读取用户输入并解析计算 reader := bufio.NewReader(os.Stdin) for true { fmt.Print(\u0026#34;\u0026gt; \u0026#34;) inputs, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) inputs = strings.Trim(inputs, \u0026#34; \\f\\t\\n\u0026#34;) if inputs == \u0026#34;quit\u0026#34; { break } if inputs != \u0026#34;\u0026#34; { lexer.Build(inputs) result := parse(lexer) if result == nil { positon := lexer.GetToken().Col fmt.Println(\u0026#34;error in :\u0026#34;, positon) continue } fmt.Println(\u0026#34;out =\u0026#34;, result.GetValue()) } } fmt.Println(\u0026#34;bye!\u0026#34;) 当解析函数parse返回的内容不是nil时可以使用GetValue函数计算表达式并得到结果。\n下篇 使计算器支持语句块\n"
            }
    
        ,
            {
                "id": 100,
                "href": "https://bxtkezhan.github.io/%E4%BD%BF%E7%94%A8bklexer%E8%BF%9B%E8%A1%8C%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/",
                "title": "使用BKLexer进行词法分析",
                "section": "posts",
                "date" : "2021.03.13",
                "body": "返回教程主页\n上篇 词法分析器\n前几天我已经封装好了词法分析器并命名BKLexer，当前BKLexer分别支持Go/C++/Python。\n程序代码放在Github项目当中: 点进项目页\n可以参考每一个版本的try_lexer代码进行学习，下面以Go为例:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;./bklexer\u0026#34; ) func main() { fmt.Println(\u0026#34;Test Code:\u0026#34;) code := \u0026#34;声明 变量 = PI * 100 - fda\\n1024 * 4 * 3.14 ### \\n123\u0026#34; fmt.Println(code) fmt.Println(\u0026#34;--------------------------------\u0026#34;) lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.\\\\d*\u0026#34;, \u0026#34;FLOAT\u0026#34;) lexer.AddRule(\u0026#34;\\\\d+\u0026#34;, \u0026#34;INT\u0026#34;) lexer.AddRule(\u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;NAME\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;=\u0026#34;, \u0026#34;ASSIGN\u0026#34;) lexer.AddRule(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;, \u0026#34;COMMENT\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) lexer.Build(code) for true { token := lexer.NextToken() if (token.TType != BKLexer.TOKEN_TYPE_EOF) { fmt.Printf(\u0026#34;%s\\t%s\\tt%d\\t%d\\t%d,%d\\n\u0026#34;, token.Name, strconv.Quote(token.Source), token.TType, token.Position, token.Row, token.Col) } if (token.TType == BKLexer.TOKEN_TYPE_EOF || token.TType == BKLexer.TOKEN_TYPE_ERROR) { break } } } 首先引入bklexer在内的包 import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;./bklexer\u0026#34; ) fmt 用于打印输出 strconv 用于优化字面量的显示 ./bklexer 引入BKLexer包 实例化词法分析器并设定规则 lexer := BKLexer.NewLexer() lexer.AddRule(\u0026#34;\\\\d+\\\\.\\\\d*\u0026#34;, \u0026#34;FLOAT\u0026#34;) lexer.AddRule(\u0026#34;\\\\d+\u0026#34;, \u0026#34;INT\u0026#34;) lexer.AddRule(\u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;NAME\u0026#34;) lexer.AddRule(\u0026#34;\\\\+\u0026#34;, \u0026#34;PLUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\-\u0026#34;, \u0026#34;MINUS\u0026#34;) lexer.AddRule(\u0026#34;\\\\*\u0026#34;, \u0026#34;MUL\u0026#34;) lexer.AddRule(\u0026#34;/\u0026#34;, \u0026#34;DIV\u0026#34;) lexer.AddRule(\u0026#34;=\u0026#34;, \u0026#34;ASSIGN\u0026#34;) lexer.AddRule(\u0026#34;#[^\\\\r\\\\n]*\u0026#34;, \u0026#34;COMMENT\u0026#34;) lexer.AddIgnores(\u0026#34;[ \\\\f\\\\t]+\u0026#34;) NewLexer 实例化词法分析器 AddRule 增加匹配规则，参数分别为正则表达式，对应的类型名称 AddIgnores 用于设定需要忽略的字符内容 构建并循环匹配 lexer.Build(code) for true { token := lexer.NextToken() if (token.TType != BKLexer.TOKEN_TYPE_EOF) { fmt.Printf(\u0026#34;%s\\t%s\\tt%d\\t%d\\t%d,%d\\n\u0026#34;, token.Name, strconv.Quote(token.Source), token.TType, token.Position, token.Row, token.Col) } if (token.TType == BKLexer.TOKEN_TYPE_EOF || token.TType == BKLexer.TOKEN_TYPE_ERROR) { break } } 使用Build方法，将代码code作为参数进行构建，然后循环调用NextToken方法获得下一个Token，并打印相关信息。需要注意的是应当对Token的类型进行检测判断是否为EOF或ERROR以决定是否终止。\n运行结果如下 Test Code: 声明 变量 = PI * 100 - fda 1024 * 4 * 3.14 ### 123 -------------------------------- NAME\t\u0026#34;声明\u0026#34;\tt3\t0\t0,0 NAME\t\u0026#34;变量\u0026#34;\tt3\t7\t0,3 ASSIGN\t\u0026#34;=\u0026#34;\tt8\t14\t0,6 NAME\t\u0026#34;PI\u0026#34;\tt3\t16\t0,8 MUL\t\u0026#34;*\u0026#34;\tt6\t19\t0,11 INT\t\u0026#34;100\u0026#34;\tt2\t21\t0,13 MINUS\t\u0026#34;-\u0026#34;\tt5\t25\t0,17 NAME\t\u0026#34;fda\u0026#34;\tt3\t27\t0,19 NEWLINE\t\u0026#34;\\n\u0026#34;\tt0\t30\t0,22 INT\t\u0026#34;1024\u0026#34;\tt2\t31\t1,0 MUL\t\u0026#34;*\u0026#34;\tt6\t36\t1,5 INT\t\u0026#34;4\u0026#34;\tt2\t38\t1,7 MUL\t\u0026#34;*\u0026#34;\tt6\t40\t1,9 FLOAT\t\u0026#34;3.14\u0026#34;\tt1\t42\t1,11 COMMENT\t\u0026#34;### \u0026#34;\tt9\t47\t1,16 NEWLINE\t\u0026#34;\\n\u0026#34;\tt0\t51\t1,20 INT\t\u0026#34;123\u0026#34;\tt2\t52\t2,0 下篇 递归向下算法实现Calc\n"
            }
    
        ,
            {
                "id": 101,
                "href": "https://bxtkezhan.github.io/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/",
                "title": "词法分析器",
                "section": "posts",
                "date" : "2021.03.06",
                "body": "返回教程主页\n维基百科介绍：词法分析是计算机科学中将字符序列转换为标记序列的过程。进行词法分析的程序或者函数叫作词法分析器。️\n有如下原始程序代码\nadd_result = 1 + 2 通过词法分析得到以下结果\nNAME `add_result` 0, 0 SYMBOL `=` 0, 11 INT `1` 0, 13 SYMBOL `+` 0, 15 INT `2` 0, 17 整理成表格形式\n标记类型 字面值 行号 列号 NAME add_result 0 0 SYMBOL = 0 11 INT 1 0 13 SYMBOL + 0 15 INT 2 0 17 我们可以利用Go语言轻松实现可用的词法分析器 😃️\nGo语言实现词法分析器 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;unicode/utf8\u0026#34; \u0026#34;os\u0026#34; ) var exprs = []string{\u0026#34;\\\\d+\u0026#34;, \u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;[\\\\+\\\\-=]\u0026#34;} var names = []string{\u0026#34;INT\u0026#34;, \u0026#34;NAME\u0026#34;, \u0026#34;SYMBOL\u0026#34;} func main() { rules := []*regexp.Regexp{} for i, expr := range exprs { rule, _ := regexp.Compile(\u0026#34;^\u0026#34; + expr) rules = append(rules, rule) fmt.Println(names[i], rule) } fmt.Println(\u0026#34;--------------------------------\u0026#34;) for row, code := range os.Args[1:] { position := 0 col := 0 for true { for position \u0026lt; len(code) \u0026amp;\u0026amp; (code[position] == \u0026#39; \u0026#39; || code[position] == \u0026#39;\\t\u0026#39;) { position += 1 col += 1 } if position \u0026gt;= len(code) { break } source := \u0026#34;\u0026#34; tokenType := -1 for i, rule := range rules { source = rule.FindString(code[position:]) if source != \u0026#34;\u0026#34; { tokenType = i break } } if tokenType \u0026gt;= 0 { fmt.Printf(\u0026#34;%s\\t`%s`\\t%d\\t%d\\n\u0026#34;, names[tokenType], source, row, col) position += len(source) col += utf8.RuneCountInString(source) } else { fmt.Printf(\u0026#34;error in: %d, %d\\n\u0026#34;, row, col) break } } } } 在命令行中运行测试\n➜ go run lexer.go \u0026#34;数值 = PI + 100\u0026#34; INT\t^\\d+ NAME\t^[\\p{L}\\d_]+ SYMBOL\t^[\\+-=] -------------------------------- NAME\t`数值`\t0\t0 SYMBOL\t`=`\t0\t3 NAME\t`PI`\t0\t5 SYMBOL\t`+`\t0\t8 INT\t`100`\t0\t10 Go语言代码说明 引入需要用到的包: package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;unicode/utf8\u0026#34; \u0026#34;os\u0026#34; ) fmt 用于打印输出 regexp 正则表达式 unicode/utf8 统计utf8的符文数量 os 获取用户输入 指定正则表达式和字段类型名称: var exprs = []string{\u0026#34;\\\\d+\u0026#34;, \u0026#34;[\\\\p{L}\\\\d_]+\u0026#34;, \u0026#34;[\\\\+\\\\-=]\u0026#34;} var names = []string{\u0026#34;INT\u0026#34;, \u0026#34;NAME\u0026#34;, \u0026#34;SYMBOL\u0026#34;} 创建两个字符串数组分别用于存储正则表达式与对应的字段类型名称。\n初始化字段匹配规则: func main() { rules := []*regexp.Regexp{} for i, expr := range exprs { rule, _ := regexp.Compile(\u0026#34;^\u0026#34; + expr) rules = append(rules, rule) fmt.Println(names[i], rule) } 需要注意的是必须为每一个正则表达式头前插入^用来确保匹配的字符串包括最左边的一个字符，避免“跳跃匹配”。\n循环匹配字段: for row, code := range os.Args[1:] { position := 0 col := 0 for true { for position \u0026lt; len(code) \u0026amp;\u0026amp; (code[position] == \u0026#39; \u0026#39; || code[position] == \u0026#39;\\t\u0026#39;) { position += 1 col += 1 } if position \u0026gt;= len(code) { break } source := \u0026#34;\u0026#34; tokenType := -1 for i, rule := range rules { source = rule.FindString(code[position:]) if source != \u0026#34;\u0026#34; { tokenType = i break } } if tokenType \u0026gt;= 0 { fmt.Printf(\u0026#34;%s\\t`%s`\\t%d\\t%d\\n\u0026#34;, names[tokenType], source, row, col) position += len(source) col += utf8.RuneCountInString(source) } else { fmt.Printf(\u0026#34;error in: %d, %d\\n\u0026#34;, row, col) break } } } 使用遍历os.Args[1:]的方法将用户输入的每一个参数作为一行代码进行词法分析。\n跳过【忽略】空字符: for position \u0026lt; len(code) \u0026amp;\u0026amp; (code[position] == \u0026#39; \u0026#39; || code[position] == \u0026#39;\\t\u0026#39;) { position += 1 col += 1 } 因为我们的正则表达式必须匹配最左边的一个字符所以需要跳过一些常常没有意义的空字符。\n判断是否需要中断循环: if position \u0026gt;= len(code) { break } 遍历匹配规则尝试匹配: source := \u0026#34;\u0026#34; tokenType := -1 for i, rule := range rules { source = rule.FindString(code[position:]) if source != \u0026#34;\u0026#34; { tokenType = i break } } 循环遍历设定的规则进行匹配，如果成功则将下标设定为tokenType的值，如果始终没有匹配则tokenType默认-1。\n根据匹配结果判断后续行为: if tokenType \u0026gt;= 0 { fmt.Printf(\u0026#34;%s\\t`%s`\\t%d\\t%d\\n\u0026#34;, names[tokenType], source, row, col) position += len(source) col += utf8.RuneCountInString(source) } else { fmt.Printf(\u0026#34;error in: %d, %d\\n\u0026#34;, row, col) break } 如果tokenType不为-1，则匹配成功，将打印字段名称，字面量，行列信息，并且设置position使之跳过当前字段，需要注意下一个字段起始的列号col的增量需要使用utf8的符文计数方法获得，否则遇到一些unicode/utf8编码将无法得到正确指向。\nPython使用者也可以轻松的实现 😁️\nPython词法分析器 import re import sys exprs = [\u0026#39;\\\\d+\u0026#39;, \u0026#39;\\\\w+\u0026#39;, \u0026#39;[\\\\+\\\\-=]\u0026#39;] names = [\u0026#39;INT\u0026#39;, \u0026#39;NAME\u0026#39;, \u0026#39;SYMBOL\u0026#39;] def main(): rules = [] for i, expr in enumerate(exprs): rules.append(re.compile(\u0026#39;^\u0026#39; + expr)) print(names[i], rules[-1].pattern) print(\u0026#39;-\u0026#39; * 32) for row, code in enumerate(sys.argv[1:]): position = 0 while True: while position \u0026lt; len(code) and (code[position] == \u0026#39; \u0026#39; or code[position] == \u0026#39;\\t\u0026#39;): position += 1 if position \u0026gt;= len(code): break source = \u0026#39;\u0026#39; tokenType = -1 for i, rule in enumerate(rules): result = rule.findall(code[position:]) if len(result) \u0026gt; 0: source = result[0] tokenType = i break if tokenType \u0026gt;= 0: print(f\u0026#39;{names[tokenType]}\\t`{source}`\\t{row}\\t{position}\u0026#39;) position += len(source) else: print(f\u0026#39;error in {row}, {position}\u0026#39;) break if __name__ == \u0026#34;__main__\u0026#34;: main() 作为补充内容这里也提供C++方案 😆️\nC++实现词法分析器 #include \u0026lt;locale\u0026gt; #include \u0026lt;regex\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;codecvt\u0026gt; std::vector\u0026lt;std::wstring\u0026gt; exprs{L\u0026#34;\\\\d+\u0026#34;, L\u0026#34;\\\\w+\u0026#34;, L\u0026#34;[\\\\+\\\\-=]\u0026#34;}; std::vector\u0026lt;std::string\u0026gt; names{\u0026#34;INT\u0026#34;, \u0026#34;NAME\u0026#34;, \u0026#34;SYMBOL\u0026#34;}; int main(int argc, char *argv[]) { std::locale old; std::locale::global(std::locale(\u0026#34;en_US.UTF-8\u0026#34;)); std::wstring_convert\u0026lt;std::codecvt_utf8\u0026lt;wchar_t\u0026gt;\u0026gt; codecvt_utf8; std::vector\u0026lt;std::wregex\u0026gt; rules; for (size_t i = 0, count = exprs.size(); i \u0026lt; count; ++i) { rules.push_back(std::wregex(L\u0026#34;^\u0026#34; + exprs[i])); printf(\u0026#34;%s ^%s\\n\u0026#34;, names[i].c_str(), codecvt_utf8.to_bytes(exprs[i]).c_str()); } printf(\u0026#34;--------------------------------\\n\u0026#34;); for (int row = 0; row \u0026lt; argc - 1; ++row) { std::wstring code = codecvt_utf8.from_bytes(argv[row + 1]); size_t position = 0; while (true) { while (position \u0026lt; code.size() \u0026amp;\u0026amp; (code[position] == L\u0026#39; \u0026#39; || code[position] == L\u0026#39;\\t\u0026#39;)) position += 1; if (position \u0026gt;= code.size()) break; auto subcode = code.substr(position); std::wsmatch match; int tokenType = -1; for (size_t i = 0, count = rules.size(); i \u0026lt; count; ++i) { if (std::regex_search(subcode, match, rules[i])) { tokenType = i; break; } } if (tokenType \u0026gt;= 0) { auto source = match.str(0); printf(\u0026#34;%s\\t`%s`\\t%d\\t%ld\\n\u0026#34;, names[tokenType].c_str(), codecvt_utf8.to_bytes(source).c_str(), row, position); position += source.size(); } else { printf(\u0026#34;error in: %d, %ld\\n\u0026#34;, row, position); break; } } } std::locale::global(old); return 0; } 下篇 使用BKLexer进行词法分析\n"
            }
    
]
